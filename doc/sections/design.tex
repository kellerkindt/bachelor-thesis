
\chapter{Systementwurf}

In diesem Kapitel wird ein Entwurf für die Implementation des Systems aufgezeigt.
Die Struktur des Systems wird durch einen Architekturentwurf visualisiert und die zu verwendeten Technologien erläutert.

\section{Kein ASN.1 Compiler für Rust}

Eine frühe Recherche hat ergeben, dass kein ASN.1 Compiler für Rust verfügbar ist.
Mit \textit{yasna}, \textit{raisin} und \textit{rust-asn1} wird teilweise ASN.1 Funktionalität in Rust zur Verfügung gestellt, aber keine unterstützt die benötigte UPER Codierung.
Auch kann keine der genannten Crates die in ASN.1 Notation definierten Nachrichten in native Rust Datenstrukturen übersetzten.
Die von der ITU genannten Compiler\footnote{\url{https://www.itu.int/en/ITU-T/asn1/Pages/Tools.aspx}} unterstützen Rust auch nicht.
Dieser Umstand erzwingt die Nutzung der C-Datenstrukturen, wie die Referenzimplementierung, mittels \gls{ffi} (siehe \autoref{rust:ffi}).
Zur besseren Kapselung ist die Einbindung der ASN.1 Nachrichten deswegen in mehreren Schritten in zwei Crates ausgelagert.

\section{Framework Tokio}
\label{design:tokio}

Das Framework Tokio wird als Grundlage für die Umsetzung der Architektur genutzt.
Tokio\footnote{\url{https://crates.io/crates/tokio}} bietet eine \enquote{Laufzeit zum schreiben von zuverlässigen, asynchrone und schlanke Anwendungen in Rust} \cite{rust:crate:tokio}.

Tokio nutzt die Crates \textit{mio} und \textit{Future} um eine ereignisorientierte, asynchrone und daher nicht blockierende Ein-/Ausgabeplattform zu bieten.
Bearbeitungsschritte sind in \enquote{Futures} (dt. Zukunft, hier in etwa: \enquote{ein zukünftiger Wert}) aneinandergereiht und verpackt.

Neben den genannten technischen Funktionen ist hervorzuheben, dass das Framework von vielen Entwicklern aus dem Rust-Entwicklerteam mindestens mitentwickelt wird\footnote{u.a. Alex Crichton, Carl Lerche, Aaron Turon: \url{https://github.com/tokio-rs/tokio/graphs/contributors}}.
Aufgrund dessen ist ein hoher Grad an Qualität und Aktualität des Frameworks zu erwarten.
%Daher ist ein höherer Grad an Vertrauen in Qualität, Funktionstüchtigkeit und Aktualität gegeben.

%\section{Rust Version 1.26}
%\todo{nötig? impl ..., }


\section{Architektur}
		
In \autoref{draft:architecture} ist der Entwurf der Architektur visualisiert.
Blau markierte Objekte haben als Aufgabengebiet die Kommunikation, grün markierte Objekte bilden die Geschäftslogik ab und rot markierte Objekte sind Spezialisierungen für ASN.1.


\begin{figure}[H]
	\centering
	\includegraphics[width=2.0\textwidth]{dia/architecture}
	\caption{Architekturentwurf}
	\label{draft:architecture}
\end{figure}

Die Implementation ist in drei Crates aufgeteilt:
\begin{itemize}
	\item \textbf{libmessages-sys}: Enthält bindings für die ASN.1 Datenstrukturen und Funktionen der C-Bibliothek (siehe \autoref{rust:ffi}).
	Unsichere Funktionsaufrufe nach C, wie zur Serialisierung und Deserialisierung, sind durch sichere Rust Funktionen gekapselt.
	Eine ordnungsgemäße Allokation und Deallokation der Nachrichten wird hier sichergestellt.
	
	\item \textbf{libmessages}: Stellt Datenstrukturen und Implementationen bereit um unabhängig von der eingesetzten Nachrichtentechnologie eine Nachricht abbilden zu können.
	Hierzu wird in \textit{RawMessage} der Kopf (siehe \autoref{analysis:messages}) und der binären Inhalt einer Nachricht dargestellt.
	
	Zusätzlich ist in dieser Crate für jede Verwendete Technologie (in dieser Bachelorarbeit nur ASN.1) die Wandlung zwischen einer \textit{RawMessage} und einer entsprechenden Datenstruktur implementiert sein.
	
	\item \textbf{MECViewServer}: Enthält die Logik für den Sensor, das Fahrzeug und den Algorithmus und bündelt sie mit der Kommunikationslogik zu einem ausführbaren Kompilat.
\end{itemize}

\subsubsection{Erklärung Server}

Der Server lädt zu beginn eine Algorithmus Implementation, öffnet einen TCP-Port und wartet auf dem daraus resultierenden \textit{TcpListener} auf neue Clients.
Jedem neuen Client wird eine Referenz auf den Algorithmus mitgegeben.

\subsubsection{Erklärung Client, Sensor und Vehicle}

Der Client hält eine Referenz auf einen Algorithmus und einen Adapter.
Im Falle eines \textit{Vehicle}s kann ein \textit{EnvironmentListener} am Algorithmus registriert werden um neue Umgebungsmodelle zu erhalten.
Im Falle eines \textit{Sensor}s kann ein \textit{CountListener} am Algorithmus registriert werden um über Änderungen bei der Anzahl der registrierten Fahrzeuge informiert zu werden.

\subsubsection{Erklärung Adapter}

Der Adapter bietet  Schnittstelle, damit eine Clientinstanz Nachrichten versenden kann, ohne die eingesetzte Nachrichtentechnologie zu kennen.
Hierzu wird der Clientinstanz Funktionen bereitgestellt, die von der Adapterimplementation in entsprechende Nachrichten übersetzt werden.

\subsubsection{Erklärung Mapper}

Der Mapper ruft für Empfangene Nachrichten der eingesetzten Nachrichtentechnologie Funktionen der Clientinstanz auf und agiert somit als Gegenstück zum Adapter.

\subsubsection{Erklärung Encoder / Decoder}

Der Encoder schreibt \textit{RawMessage}s auf den TCP-Datenstrom, während der Encoder \textit{RawMessage}s vom TCP-Datenstrom liest.
Hierzu wird eine Wandlung, wie in \autoref{analysis:messages} beschrieben, vorgenommen.

\subsubsection{Nachrichtentechnologie kapseln}

Innerhalb der MECViewServer Crate sollen möglichst wenige Klassen die eingesetzt Nachrichtentechnologie kennen.
Hierzu zählen die Algorithmus- (\textit{SampleAlgorithmus}), Mapper- und Adapterimplementationen (\textit{AsnAdapter}).
Dies ist unumgänglich, weil sowohl der eingesetzte Algorithmus, der Mapper und der Adapter Felder einer Nachricht sowohl lesen als auch schreiben muss.
Zudem muss der Server mindestens indirekt die eingesetzte Technologie kennen, um die richtigen und zueinander kompatiblen Algorithmus-, Mapper- und Adapterimplementation zu instantiieren.
Weitere Klassen agieren dagegen unabhängig von der eingesetzten Nachrichtentechnologie.

\subsection{Kommunikationsarchitektur}
\label{design:communication:architecture}

Um ein Mehrkernsystem effizient zu nutzen, arbeiten einige Klassen asynchron zueinander.
Hierzu zählt der Server, der fortlaufend neue Verbindungen annimmt.
Die daraus resultierenden Clientinstanzen bearbeiteten asynchron eingehende Anfragen.
Letztendlich aktualisiert auch der Algorithmus asynchron zu den Clientinstanzen und dem Server das Umfeldmodell.

Die Kommunikation zwischen einem TCP-Datenstrom und einer Clientinstanz soll mittels des \enquote{Channel Architektur Pattern} \cite[157]{douglass2003real} verwirklicht werden.
Das Muster eignet sich besonders gut, da auf eingehende und ausgehende Datensätze eine immer gleiche Transformation angewandt werden muss:

\begin{figure}[h]
	\centering
	\includegraphics[width=\textwidth]{dia/channel}
	\caption{\enquote{Channel Architektur Pattern} zwischen einem TCP-Datenstrom (unten) und einer Clientinstanz (oben). Zu lesen von links unten, nach oben, nach rechts unten.}
	\label{design:channel}
\end{figure}

\autoref{design:channel} beschreibt die nötigen Transformationen bis eine Anfrage bearbeitet werden kann und die nötigen Transformationen um eine Antwort zu versenden:
\begin{itemize}
	\item \textbf{Daten empfangen}: Die eingehenden Daten (hier Bytes) müssen angesammelt werden, bis sie eine komplette Anfrage abbilden.
	\item \textbf{RawMessage dekodieren}: Die angesammelten Daten werden in eine RawMessage gewandelt. Nachrichtentyp und Korpus werden hierbei extrahiert.
	\item \textbf{asn::Message dekodieren}: Aus dem Korpus wird eine ASN-Nachricht des entsprechenden Typs dekodiert.
	\item \textbf{Anfrage zuordnen}: Die ASN-Nachricht wird einer Anfrage zugeordnet.
	\item \textbf{Anfrage berabeiten}: Die Anfrage wird bearbeitet und eine Antwort generiert.
	\item \textbf{asn::Message zuordnen}: Die Antwort wird eine ASN-Nachricht eingebettet.
	\item \textbf{asn::Message encodieren}: Die ASN-Nachricht wird in eine RawMessage encodiert. Der Nachrichtentyp wird entsprechend gesetzt.
	\item \textbf{RawMessage encodieren}: Die RawMessage wird in Bytes gewandelt.
	\item \textbf{Daten versenden}: Die Bytes werden über den TCP-Datenstrom versandt.
\end{itemize}

Nach dem \enquote{Channel Architektur Pattern} ist eine sequentielle Bearbeitung zwischen dem TCP-Datenstrom und der Clientinstanz in jede Richtung als Kanal interpretierbar.
Da jeder Zwischenschritt innerhalb eines Kanals lediglich von dem Ergebnis des vorhergehenden abhängig ist, können die einzelnen Schritte parallel zueinander bearbeiten werden.
\todo{}
Durch einen zusätzlichen, vorangestellten Multiplexer und nachfolgenden Demultiplexer könnten in einer späteren Version mehrere Kanäle parallel den Client oder den Datenstrom speisen.
Hiervon wird in der ersten Implementierung jedoch abgesehen, da je Client keine derart große Datenflut erwartet wird, die dies verlangen würde.
Stattdessen soll lediglich jeder Kanal eines Clients parallel zu allen den Kanälen anderer Clients ausgeführt werden.

Als Framework zur Umsetzung wird \textit{Tokio} (siehe \autoref{design:tokio}) verwendet.
Durch die Kombinationsmöglichkeiten von \textit{Future}s nicht blockierenden Kommunikationskanäle ermöglicht es, ein System nach diesem Prinzip zu erstellen.

%Bei einer großen Datenmenge kann dies helfen, die Anforderungen von echtzeitnahen System zu erfüllen (\cite[161]{douglass2003real}).

%Das \enquote{Channel Architektur Pattern} \cite[157]{douglass2003real}, welches bereits von \textit{Tokio} (siehe \autoref{design:tokio}) verwendet wird, wird dies ermöglichen.

%\todo{explain more channel system}



~\\ ~\\ ~\\






\todo{Ausgliederung von libmessages weil ASN-Bindings + weil von Protokolländerungen unabhängig sein soll}

\todo{Prüfen tokio, queues, async + proxy pattern}

\todo{Abbildung vereinfacht, Kommunikation via Queues im tokio context}


\todo{\cite[446]{goll2012methoden}, example \cite[457]{goll2012methoden}}

\todo{Component diagrams tikz-uml: server, algorithm, encoder/...}		


\section{Sequenzdiagramme}

\section{..}
\todo{Hochperformant -> parallel?}

\todo{Design Pattern, Gamma et al, four important aspects}

\todo{Real Time Design Patterns Buch: Ab Seite 141, verschiedene Systempatterns, microkernel \cite[151]{douglass2003real}? channel architektur pattern \cite[167]{douglass2003real}?}

\todo{Message Queuing Pattern \cite[207]{douglass2003real}}

\todo{kein hartes Echtzeitsystem, gerade mal weiches Echtzeitsystem \autoref{real_time_system}}

\todo{Clean Architecture / Clean Code}