
\chapter{Die Programmiersprache Rust}

Rust ist eine Programmiersprache, die versucht performant -- und daher durch Abstraktionen mit keinem zusätzlichen \enquote{Kosten} \todo{ref zero cost abstractions} -- sichere Programmierung zu ermöglichen.
Ziel ist eine \todo{Systemprogrammiersprache}, die sowohl sicher \todo{cite chapter} als auch performant ist und ohne eine Laufzeit ausgeführt werden kann.
Verschiedene Fehlerquellen -- wie \enquote{dangling pointers}, \enquote{double free} oder \enquote{memory leaks} \todo{ref} --  werden durch Abstraktionen und mit Hilfe des Kompilers verhindert.
Anders als Programmiersprachen, die dies mit Hilfe einer Laufzeit ermöglichen (zbsp. Java oder C\#), wird dies in Rust durch eine statische Analyse und einem Eigentümerprinzip bei der Kompilation gewährleistet.


\section{Geschichte}
\label{rust:history}

In 2006 \cite{rust:faq} begann Graydon Hoare die Programmiersprache Rust in seiner Freizeit als Hobbyprojekt zu entwickeln.
Als Grund nannte er seine Unzufriedenheit mit der Programmiersprache C++, in der es sehr schwierig sei, fehlerfreien, speichersicheren und nebenläufigen Code zu schreiben.
Zudem beschrieb er C++ als \enquote{ziemlich fehlerträchtig}. \cite{rust:heise_interview_graydon}

Auch Federico Mena-Quintero -- Mitbegründer des Gnome projekts \todo{cite \url{https://people.gnome.org/~federico/} or so} --
äußerte in einem Interview mit Golem im Juli 2017 seine Bedenken an der Verwendung der \enquote{feindseligen} Sprache C \cite{rust:c_is_hostile_golem}.
In Vorträgen \todo{nix mehrzahl?} vermittelt er seither, wie Bibliotheken durch Implementierungen in Rust ersetzt werden können \cite{rust:c_is_hostile_mena}.

Ab 2009 begann Mozilla die Weiterentwicklung finanziell zu fördern, da einfache Tests und die Kernprinzipien demonstriert werden konnten.
Die Entwicklung findet dabei öffentlich einsehbar auf GitHub unter \url{https://github.com/rust-lang/rust} statt und wird dabei nicht ausschließlich von Mozilla Angestellten koordiniert.
Die Stabilität des Kompilers trotz hoher Flexibilität während der Entwicklung wird dabei durch Unterscheidung von drei Veröffentlichungskanälen -- release, stable und nightly -- in Kombination mit automatisierten Tests \todo{ref?} gewährleistet. \cite{rust:faq}



\todo{hobbyprojekt, mozilla, open-source, Entwicklung auf GitHub - jeder kann sich beteiligen, test(coverage), automatisierte builds, stable/beta/nightly}

\section{Anwendungsgebiet}

Das Ziel von Rust ist es, das designen und implementieren sicheren, nebenläufig und auch praktisch tauglichen blubber zu machen \cite{rust:faq}.
\todo{intro paragraph}

Rust nutzt den \gls{llvm}-Kompiler und erbt daher auch eine große Anzahl an Zielplattformen für die Rust kompiliert werden kann.
Es wird aber zwischen drei Stufen unterschieden, bei denen verschieden stark ausgeprägte Garantien vergeben sind.
Es wird zwischen \enquote{Stufe 1: Funktioniert garantiert} (u.a. X86, X86-64), \enquote{Stufe 2: Kompiliert garantiert} (u.a. ARM, PowerPC, PowerPC-64) und \enquote{Stufe 3} (u. a. Thumb) unterschieden \cite{rust:platform_support}.
Diese Unterscheidung wirkt sich auch auf die Stabilisierungsphase und Implementation neuer Funktionen aus (Beispiel \enquote{128-bit Integer Support} \cite{rust:github:128bit_integer}).

\section{Aufbau eines Projektverzeichnisses}

\subsection{Klassisch}
\label{rust:structure:classic}
\begin{wrapfigure}{l}[-1em]{.4\textwidth}
	\begin{rustc}
		src/
		|-- main.rs
		|-- functionality.rs
		|-- module/
		    |-- mod.rs
		    |-- functionality.rs
		    |-- submodule/
		        |-- mod.rs
		        |-- functionality.rs
	\end{rustc}
	\caption{Verzeichnisstruktur des Quelltext-Verzeichnisses}
	\label{fig:rust:structure:classic}
\end{wrapfigure}

Das Quelldatei-Verzeichnis sollte entweder eine \textit{main.rs} für Ausführbare Programme oder eine \textit{lib.rs} für Bibliotheken enthalten.
Während der Paketmanager Cargo (\autoref{rust:structure:cargo}) eine solche Benennung als Standardkonvention erwartet, kann bei manueller Nutzung des Kompilers auch ein anderer Name für die Quelldatei vergeben werden.

Der Kompiler startet in der Wurzeldatei und lädt weitere Module, die durch \rustcinline{mod module;} gekennzeichnet sind (ähnlich \ccinline{# include "module.h"} in C/C++).
Ein Modul kann dabei eine weitere Quelldatei oder ganzes Verzeichnis sein.
Ein Verzeichnis wird aber nur als Modul interpretiert, wenn sich eine \textit{mod.rs} Datei darin befindet.
%Module (Verzeichnisse oder Quelldateien) gesucht wird. , in der Module durch \rustcinline{mod module;} und Quelldateien durch \rustcinline{mod functionality;} \enquote{inkludiert} werden können.
%Eine Datei \textit{mod.rs} ist die Wurzeldatei eines Moduls.

\subsection{Mit Cargo}
\label{rust:structure:cargo}

\begin{wrapfigure}{r}[-1em]{.4\textwidth}
	\hspace{1em}
	\begin{rustc}
		crate/
		|-- Cargo.toml
		|-- src/
		    |-- ...
	\end{rustc}
	\caption{Vereinfachte Verzeichnisstruktur einer \enquote{crate}}
	\label{fig:rust:structure:cargo}
\end{wrapfigure}

\todo{text is shit}
Im Gegensatz zu einem klassischen Aufbau (\autoref{rust:structure:classic}) wird von der Rust Gemeinschaft das Werkzeug \enquote{Cargo} (dt. Fracht/Ladung\todo{.}) angeboten.
Mit Cargo können ähnlich wie zum Beispiel mit Maven \todo{cite?} in Java, Abhängigkeiten zu anderen Bibliotheken verwaltet werden.
Ein Cargo Projekt wird dabei als \enquote{Crate} (dt. Kiste/Kasten\todo{.}) bezeichnet.
Eine offizielles Verzeichnis befindet sich auf \url{https://crates.io/}.
Von \url{https://crates.io/} werden standardmäßig Abhängigkeiten nachgeladen.
Jeder kann neue Bibliotheken hochladen/veröffentlichen, für den Namen gilt dabei \enquote{first come, first serve}.

\todo{dependencies}
\todo{Cargo init --bin <name>}
\todo{missing .gitignore / .git mention / git alltogether}
\todo{Cargo.toml}
\todo{[crates.io]}

\section{Hello World}


\begin{wrapfigure}{l}{.5\textwidth}
	\begin{rustc}
		fn main() {
			println!("Hello World");
		}
	\end{rustc}
	\caption{\enquote{Hello World} in Rust}
	\label{fig:rust:hello_world}
\end{wrapfigure}

\todo{println!, writeln! formatting}

\todo{official format/naming convetion, use, function, macro}

\section{Alles hat einen Rückgabewert}

\section{use mod pub}

\section{Variables, Structs, Enums, Traits}

\section{Eigentümer- und Verleihprinzip}

\section{Scope / Memory Management}


\todo{autodrop, auto file close}

\section{Rust als funktionale Programmiersprache}
\todo{functional programming -> no global state, no exceptions, find literature}
\todo{prove via code}

\section{Rust als Objekt-Orientierte Programmiersprache}
\todo{trait}
\todo{prove via design patterns, a few? from faq::  Is Rust object oriented? It is multi-paradigm. Many things you can do in OO languages you can do in Rust, but not everything, and not always using the same abstraction you’re accustomed to.}


\section{Versprechen von Rust}
\label{rust:guarantees}
\subsection{Sichere Nebenläufigkeit}
\todo{Send, Sync}
\subsection{Zero Cost Abstraction}
\subsection{Kein undefiniertes Verhalten}
\todo{ref oreilly}
\subsection{Kein Null-Pointer}
\todo{explain option}
\subsection{Kein vergessene Fehlerprüfung}
\todo{explain result}
\subsection{No dangling pointer}
\todo{src https://www.youtube.com/watch?v=d1uraoHM8Gg}
\subsection{Statische Speicher- und Lebenszeitanalyse}
\todo{while compiling, does not compile on error / unprovable code, trait Drop}
\subsection{type safety langauge}





Rust ist...
% \lipsum

\todo{Rust -> MIR -> assembler} \\
\todo{MIR/assemblerbeispiele?} \\
\cite{rust:orly_programming}


\section{Einbinden von Bibliotheken}

\subsubsection{Externe Datentypen}
\label{rust:ffi:datatypes}

Rust bietet durch das \gls{ffi} die Möglichkeit, andere (System-)Bibliotheken einzubinden.
Entsprechende Strukturen und Funktionen werden durch einen \rustcinline{extern}-Block
oder im Falle von Strukturen optional mit einem \rustcinline{#[repr(C)]} gekennzeichnet.

In einem Beispiel, soll die Nutzung von \gls{ffi} demonstriert werden.

\begin{figure}[H]
	\begin{cc}
		typedef struct PositionOffset {
			long position_north;
			long position_east;
			long *std_dev_position_north /* OPTIONAL */;
			long *std_dev_position_east  /* OPTIONAL */;
			
			// ...
		} PositionOffset_t;
	\end{cc}
	\caption{Ausschnitt von \enquote{PositionOffset} \todo{ref mecview lib} in C}
	\label{fig:rust:ffi:position_offset_c}
\end{figure}

Die Struktur in \autoref{fig:rust:ffi:position_offset_c} muss zur Nutzung in Rust zuerst bekannt gemacht werden.
Dabei gibt es mehrere Möglichkeiten:
\begin{enumerate}
	\item Falls Inhalt der Struktur nicht von Bedeutung ist, kann es ausreichen, den neuen Typ lediglich bekannt zu machen: \rustcinline{#[repr(C)] struct PositionOffset;} \label{rust:ffi:example:enumerate:repr}
	
	\item Der Inhalt ist wie bei \autoref{rust:ffi:example:enumerate:repr} unbedeutend, es soll aber ausdrücklich auf einen externen Typ hingewiesen werden: \rustcinline{extern { type PositionOffset; }} \cite{rust:github:extern_type} (\todo{nightly})
	
	\item Der Inhalt der Struktur ist von Bedeutung, da darauf zugegriffen werden soll oder in Rust eine Instanz erzeugbar sein soll. In diesem Fall muss die Struktur wiedergegeben werden:
	\begin{figure}[H]
		\begin{rustc}
			use std::os::raw::c_long;
			
			#[repr(C)]
			pub struct PositionOffset {
				pub position_north: c_long,
				pub position_east: c_long,
				pub std_dev_position_north: *mut c_long,
				pub std_dev_position_east: *mut c_long,
				// ...
			}
			
		\end{rustc}
		\caption{Ausschnitt von \enquote{PositionOffset} \todo{ref mecview lib} in Rust}
		\label{fig:rust:ffi:position_offset_rust}
	\end{figure}
	
	In \autoref{fig:rust:ffi:position_offset_rust} ist die Struktur \enquote{PositionOffset} definiert,
	die durch das Attribut \rustcinline{#repr(C)} wie eine C-Struktur im Speicher organisiert wird.
	Somit ist sie kompatibel zu der C-Struktur aus \autoref{fig:rust:ffi:position_offset_c}.
	
	Da auf eine C-Struktur zugegriffen wird, sollten auch, wie in \autoref{fig:rust:ffi:position_offset_rust} zu sehen, spezielle Datentypen (\rustcinline{c_long}, \rustcinline{c_void}, \rustcinline{c_char}, ...) verwendet werden, um die Kompatibilität mit verschiedenen Systemen und C-Kompilern zu wahren. \todo{u32 immer 32bit, aber int nicht immer gleich (Beispiel!?) --> Probleme}
	
%	\rustcinline{*mut c_long} entspricht dabei dem C-Pointer für \rustcinline{&mut c_long}, also \ccinline{long*}, ein C-Pointer für \rustcinline{&c_long} entspricht \rustcinline{*const c_long}.
	
%	C-Pointer werden in Rust \enquote{Raw-Pointer} genannt und \rustcinline{*mut c_long} für  \rustcinline{&mut c_long} bzw. \rustcinline{*const c_long} für \rustcinline{&c_long} geschrieben.
	
	Ein C-Pointer \ccinline{*long} wird in Rust \enquote{Raw-Pointer} genannt und entweder als \rustcinline{*mut c_long} oder als \rustcinline{*const c_long} geschrieben. Der Unterschied ist wie zwischen \rustcinline{&mut c_long} und \rustcinline{&c_long} und dient dem \todo{Rusttypsystem!? ref!?} zur Unterscheidung \todo{Erzwinungt im Besitz von entsprechender Mutability zu sein}, während es für die C-Seite keinen Unterschied macht \cite{rust:book:raw_ptr}:
	
	\begin{figure}[H]
		\centering
		\begin{tabular}{c|c|c}
			Referenz in Rust & Raw-Pointer in Rust & C-Pointer \\
			\hline
			\rustcinline{&mut c_long}  &   \rustcinline{*mut   c_long}  &   \ccinline{long*} \\
			\rustcinline{    &c_long}  &   \rustcinline{*const c_long}  &   \ccinline{long*}
		\end{tabular}
		\caption{Vergleich Rust Raw-Pointer und Referenz zu C-Pointer}
	\end{figure}
	
\end{enumerate}

\subsubsection{Externer Funktionsaufruf}
\label{rust:ffi:functioncall}

Während eine Struktur, die eine externe Struktur darstellen soll, optional in einem \rustcinline{extern {}} Block definiert sein kann, ist das für externe Funktionen zwingend:

\begin{figure}[H]
	\begin{rustc}
		use std::os::raw::c_void;
		
		#[link(name = "messages", kind = "static")]
		extern {
			type asn_TYPE_descriptor_s;
			type asn_enc_rval_t;
			
			fn uper_encode_to_buffer(
				type_descriptor: *const asn_TYPE_descriptor_s,
				struct_ptr: *const c_void,
				buffer: *mut c_void,
				buffer_size: usize,
			) -> asn_enc_rval_t;
		}
	\end{rustc}
	\caption{Externe Funktionsdefinition der ASN.1 Funktion zum Enkodieren}
	\label{fig:rust:ffi:uper_encode_to_buffer}
\end{figure}

Wie in \autoref{fig:rust:ffi:uper_encode_to_buffer} zu sehen ist, können auch \rustcinline{extern {}} Blöcke mit Attributen versehen werden. Zwingend ist bei der Verwendung eines \rustcinline{#[link(..)]} Attributes der Name der Bibliothek, auf die sich der im \rustcinline{extern {}} Block stehende Code bezieht. Optional kann auch wie in \autoref{fig:rust:ffi:uper_encode_to_buffer} die Art der \todo{Linkung} (dylib, static) angegeben werden.

Die Art der Definition einer externen Funktion unterscheidet sich nicht von einer normalen Funktionsdefinition. Es sollten aber, wie in \autoref{rust:ffi:datatypes} beschrieben, zu C bzw. der externen Sprache kompatiblen Datentypen verwendet werden.
 

\section{Warum Rust?}

\begin{quotation}
	\textit{\enquote{[..]Leute, die [..] sichere Programmierung haben wollen, [..] können das bei Rust haben, ohne die [von D] undeterministischen Laufzeiten oder Abstraktionskosten schlucken zu müssen. }}
	\cite{rust:fefe}
\end{quotation}




\begin{quotation}
	\textit{\enquote{It’s not bad programmers, it’s that C is a hostile language}} 
	(Seite 54, \cite{rust:c_is_hostile_mena})
\end{quotation}

\begin{quotation}
	\textit{\enquote{I’m thinking that C is actively hostile to writing and maintaining reliable code}} 
	(Seite 129, \cite{rust:c_is_hostile_mena})
\end{quotation}

\begin{quotation}
	\textit{\enquote{[..] Rust makes it safe, and  provides nice tools}} 
	(Seite 130, \cite{rust:c_is_hostile_mena})
\end{quotation}


\begin{quotation}
	\textit{\enquote{Rust hilft beim Fehlervermeiden}} 
	\cite{rust:c_is_hostile_golem}
\end{quotation}

\begin{quotation}
	\textit{\enquote{Rust is [..] a language that cares about very tight control}}
	\cite{rust:tight_control}
\end{quotation}

\todo{unused orly rust} \cite{rust:orly_y_rust}

\section{Kernfeatures}

https://www.youtube.com/watch?v=d1uraoHM8Gg \\
\todo{no need for a runtime, all static analytics} \\
\todo{memory safety} \\
\todo{data-race freedom} \\
\todo{active community} \\
\todo{concurrency: no undefined behavior} \\
\todo{ffi binding} \gls{ffi} \\
\todo{zero cost abstraction} \\
\todo{package manager: cargo} \\

https://www.youtube.com/watch?v=-Tj8Q12DaEQ \\
\todo{static type system with local type inference } \\
\todo{explicit notion of mutability } \\
\todo{zero-cost abstraction *(do not introduce new cost through implementation of abstraction)} \\
\todo{errors are values not exceptions}
\todo{no null} \\
\todo{"static automatic memory management" - no garbage collection } \\
\todo{often compared to GO and D (~44min)} \\


\section{Schwächen}

https://www.youtube.com/watch?v=-Tj8Q12DaEQ \\
\todo{compile-times} \\
\todo{Rust is a vampire language, it does not reflect at all!} \\
\todo{depending on the field -> majority of libraries?} \\


\section{Performance Fallstricke}

\todo{\cite{rust:performance_pitfalls}}

\section{Beispiele von Verwendung von Rust}

\todo{firefox} \\

https://www.youtube.com/watch?v=-Tj8Q12DaEQ \\
\todo{GTK binding heavily to rust} \\

\todo{unstable}
\todo{ffi}
