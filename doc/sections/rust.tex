
\chapter{Die Programmiersprache Rust}
\label{rust}

%Rust ist eine Programmiersprache, die versucht performante -- und daher durch Abstraktionen mit keinem zusätzlichen \enquote{Kosten} \todo{ref zero cost abstractions} -- und sichere Programmierung zu ermöglichen.
Rust hat als Ziel, eine sichere (siehe \autoref{rust:guarantees}) und performante Systemprogrammiersprache zu sei.
Abstraktionen sollen die Sicherheit, Lesbarkeit und Nutzbarkeit verbessern aber keine unnötigen Performance-Einbußen verursachen (siehe \autoref{rust:zero_cost}).

Aus anderen Programmiersprachen bekannte Fehlerquellen -- wie vergessene \ccinline{NULL}-Pointer Prüfung, vergessene Fehlerprüfung, \enquote{dangling pointers} oder \enquote{memory leaks} --  werden durch strikte Regeln und mit Hilfe des Compilers verhindert (\autoref{rust:guarantees}).
Im Gegensatz zu Programmiersprachen, die dies mit Hilfe ihrer Laufzeitumgebung\footnote{u.a. Java Virtual Maschine (JVM), Common Language Runtime (CLR)} sicherstellen, werden diese Regeln in Rust durch eine statische Lebenszeitanalyse (\autoref{rust:static_analysis}) und mit dem Eigentümerprinzip (\autoref{rust:ownership}) bei der Compilation überprüft und erzwungen.
\todo{Anderswo als Best Practice Vorschläge, hier in Regeln erzwungen, ändert nicht viel, erzwingt nur korrekte programmierung}

Diese erlaubt Rust eine zur Laufzeit hohe Ausführgeschwindigkeit zu erreichen.
Das Eigentümerprinzip (siehe \autoref{rust:ownership}) und die Markierung durch von Datentypen durch Merkmale (siehe \autoref{rust:traits}) vereinfacht es, nebenläufige und sichere Programme zu schreiben.

Rust hat in den letzten Jahren viel an Beliebtheit gewonnen und ist 2018 das dritte Jahr in Folge als die beliebteste Programmiersprache in einer Umfrage auf Stack Overflow gewählt worden \cite{rust:stack_overflow:mose_loved}.
Rust scheint dem Anspruch, eine sichere und performante Programmiersprache zu sein, gerecht zu werden:

\begin{quotation}
	\textit{\enquote{Again, Rust guides you toward good programs}}
	\cite[497]{rust:orly_programming}
\end{quotation}

\begin{quotation}
	\textit{\enquote{[..]Leute, die [..] sichere Programmierung haben wollen, [..] können das bei Rust haben, ohne [..] undeterministischen Laufzeiten oder Abstraktionskosten schlucken zu müssen. }}
	\cite[Felix von Leitner in einem Blogeintrag]{rust:fefe}
\end{quotation}

\begin{quotation}
	\textit{\enquote{[..] Rust makes it safe, and  provides nice tools}} 
	\cite[Folie 130, Federico Mena-Quintero in \enquote{Ersetzen von C Bibliotheken durch Rust}]{rust:c_is_hostile_mena}
\end{quotation}

\begin{quotation}
	\textit{\enquote{Rust hilft beim Fehlervermeiden}} 
	\cite[Federico Mena-Quintero in einem Interview]{rust:c_is_hostile_golem}
\end{quotation}

\begin{quotation}
	\textit{\enquote{Rust is [..] a language that cares about very tight control}}
	\cite[Diskussion zwischen Programmierern auf Reddit]{rust:tight_control}
\end{quotation}


%Durch Merkmale (siehe \autoref{rust:traits}) kann die Zugriffsart auf Datentypen über verschiedene Threads hinweg festgelegt oder verhindert werden, wodurch falsche nebenläufige Programmierung zur Compilezeit erkannt und verhindert wird.
%Dies begünstigt parallelisierte Architekturen und ermöglicht es, die vielen CPU-Kerne auf modernen Computern einfacher zu nutzen.
%\todo{rust performance very wow, much parallel, great safety}

%Programmierer müssen sich für Rust an ein striktes Regelwerk und einen \enquote{besorgten} Compiler (siehe \autoref{rust:worried_compiler}) gewöhnen, erhalten im Gegenzug aber eine Sprache, die ein undefiniertes Verhalten nur in absoluten Ausnahmefällen kennt (siehe \autoref{rust:undefined}).
%Eine vom Compiler bemängelte Formatierung des Programmcodes und Benennung von Datentypen, Felder und Funktionen (siehe \autoref{rust:styleguide}) erlaubt ein einheitliches Auftreten des Programmcodes innerhalb der \todo{Community}.

%\todo{rust sehr sauber, nahezu nix undefined (ref), nix uninitalized access(ref), datentypen namen u/i..(ref), styleguide}


\clearpage
\section{Geschichte}
\label{rust:history}

In 2006 begann Graydon Hoare die Programmiersprache Rust in seiner Freizeit als Hobbyprojekt zu entwickeln \cite{rust:faq}.
Als Grund nannte er seine Unzufriedenheit mit der Programmiersprache C++, in der es sehr schwierig sei, fehlerfreien, speichersicheren und nebenläufigen Programmcode zu entwickeln.
Zudem beschrieb er C++ als \enquote{ziemlich fehlerträchtig} \cite{rust:heise_interview_graydon}.

Auch Federico Mena-Quintero -- Mitbegründer des GNOME-Projekts \cite{rust:gnome:federico}  --
äußerte in einem Interview mit Golem im Juli 2017 seine Bedenken an der Verwendung der \enquote{feindseligen} Sprache C \cite{rust:c_is_hostile_golem}.
In Vorträgen vermittelt er seither, wie Bibliotheken durch Implementationen in Rust ersetzt werden können \cite{rust:c_is_hostile_mena}.

Ab 2009 begann Mozilla die Weiterentwicklung finanziell zu fördern, als mit einfachen Tests die Kernprinzipien demonstriert werden konnten.
Die Entwicklung der Programmiersprache, des Compilers, des Buchs, von Cargo, von crates.io und von weiteren Bestandteilen findet öffentlich einsehbar auf \gls{github}  unter \url{https://github.com/rust-lang} statt.
Dadurch kann sich jeder an Diskussionen oder Implementation beteiligen, seine Bedenken äußern oder Verbesserungen vorschlagen.

Durch automatisierte Tests (siehe \autoref{rust:tests}) in Kombination mit drei Veröffentlichungskanälen (\enquote{release}, \enquote{stable} und \enquote{nightly}) und \enquote{feature gates} (siehe \autoref{rust:feature_gates}) wird die Stabilität des Compilers und die der Standardbibliothek (\autoref{rust:stdlib}) gewährleistet.

Rust ist wahlweise unter MIT oder der Apache Lizenz in Version 2 verfügbar \cite{rust:copyright}.

\section{Anwendungsgebiet}

Das Ziel von Rust ist es, das Designen und Implementieren von sicheren und nebenläufigen Programmen möglich zu machen.
Gleichzeitig soll der Spagat geschaffen werden, nicht nur ein sicheres aber lediglich theoretisches Konstrukt zu sein, sondern  in der Praxis anwendbar zu sein.
Als Beweis könnte hierbei auf die Umstellung von Firefox auf Rust und Servo -- ein minimaler Webbrowser komplett in Rust geschrieben -- verwiesen werden \cite{rust:faq}.

Interessant ist eine Diskussion von 2009, bei der \enquote{sicher aber nutzlos} und \enquote{unsicher aber brauchbar} gegenübergestellt wurde.
Programmiersprachen scheinen auf der Suche nach dem nicht existierende \enquote{Nirvana} zu sein, das sowohl sichere als auch brauchbare Programmierung verspricht \cite[ab ca Minute 58:20]{rust:infoq:null}.
Rust möchte dieses Nirvana gefunden haben.
% bei einer Diskussion \footnote{Siehe auch \enquote{unsafe but useful}/\enquote{safe but useless} \cite[ab ca Minute 58:20]{rust:infoq:null}}.

\subsection{Kompatibilität}
Da Rust den \gls{llvm}-Compiler nutzt, erbt Rust auch eine große Anzahl der Zielplattformen die \gls{llvm} unterstützt.
Die Zielplattformen sind in drei Stufen unterteilt, bei denen verschieden stark ausgeprägte Garantien vergeben werden. Es wird zwischen
\begin{itemize}
	\item \enquote{Stufe 1: Funktioniert garantiert} (u.a. X86, X86-64),
	\item \enquote{Stufe 2: Compiliert garantiert} (u.a. ARM, PowerPC, PowerPC-64) und
	\item \enquote{Stufe 3} (u. a. Thumb (Cortex-Microcontroller))
\end{itemize}
unterschieden \cite{rust:platform_support}.
Diese Unterscheidung wirkt sich auch auf die Stabilisierungsphase und Implementation neuer Funktionen aus (Beispiel \enquote{128-bit Integer Support} \cite{rust:github:128bit_integer}).

\subsection{Veröffentlichungszyklus}
\label{rust:feature_gates}

Es stehen Versionen in drei verschieden Veröffentlichungskanälen zur Verfügung:
\begin{itemize}
	\item \textbf{nightly}:
	Version, die einmal am Tag mit dem aktuellen Stand des Quellcodes gebaut wird.
	Experimentelle und nicht fertige Features sind hier zwar enthalten, aber hinter \enquote{feature gates} versteckt.
	Diese \enquote{Tore} können durch entsprechende Anmerkungen (siehe \autoref{rust:annotations}) geöffnet werden, so ermöglicht (\rustcinline{#[feature(const_fn)]} die Definition von konstanten Funktionen (Stand \today).
	
	\item \textbf{beta}: Alle sechs Wochen wird die aktuellste Nightly zur Beta befördert und es werden nur noch Fehler aus dieser Version getilgt.
	Dieser Prozess könnte auch als Reifephase bezeichnet werden.
	\item \textbf{stable}: Nach sechs Wochen wird die aktuellste Beta zur Stable befördert und veröffentlicht.
	Gleichzeitig wird auch eine neue Beta veröffentlicht.
\end{itemize}

\subsection{Ökosystem}

Mit Rust wird nicht nur eine Programmiersprache, sondern auch ein umfassendes Ökosystem angeboten.

Cargo ist vermutlich das größte angebotene Werkzeug.
Es löst Abhängigkeiten auf, indem es auf das öffentliche Verzeichnis unter \url{https://crates.io} zurückgreift und diese entsprechend herunterlädt und compiliert.
Zum jetzigen Zeitpunkt (\today) sind über 14.000 Crates öffentlich erreichbar und nutzbar.
Zudem wird durch Crago eine \textit{Cargo.toml} verlangt, in der Metainformationen einer Crate hinterlegt sind.
Dies umfasst u.a. Name, Version, Autor, Lizenz und Abhängigkeiten.

Eine Crate kann von jedem veröffentlicht werden, insofern derjenige ein \gls{github}-Konto besitzt, der Name der Crate noch nicht vergeben ist und der Programmcode compiliert.
Die API-Dokumentation der jeweiligen Crate wird dabei automatisiert auf \url{https://docs.rs} veröffentlicht.

Unter \url{https://www.rust-lang.org} ist die Website von Rust erreichbar und unter \url{https://doc.rust-lang.org} sowohl die API-Dokumentation der Standardbibliothek als auch das hauseigene Rust Buch in Version 1 und 2.
Die Entwicklung findet dagegen auf \gls{github} unter \url{https://github.com/rust-lang} statt.

Kleine Testprogramme und Experimente können auf dem \enquote{Spielplatz} unter \url{https://play.rust-lang.org} compiliert und ausgeführt werden, ohne lokal etwas zu installieren.


\section{Aufbau eines Projektverzeichnisses}

Der Aufbau eines Rust Projektverzeichnis ist auf zwei verschiedene Arten möglich.
Zum einen gibt es den klassische Aufbau, in dem lediglich der Programmcode liegt und der Compiler direkt aufgerufen und parametrisiert wird.
Zum anderen wird der Aufbau als Crate (siehe \autoref{rust:structure:crate}) empfohlen, da dadurch Abhängigkeiten automatisch aufgelöst werden können aber auch Metainformationen bezüglich des Autors, der Version und der Abhängigkeiten hinterlegt werden müssen.
Ein klassischer Aufbau ist daher nur selten anzutreffen.


\subsection{Klassisch}
\label{rust:structure:classic}
\begin{wrapfigure}{L}[-1em]{.5\textwidth}
	\rustcinclude
		{rust:structure:classi}
		{Verzeichnisstruktur des Quelltext-Verzeichnisses}
		{sections/rust.classic.txt}
\end{wrapfigure}

Das Quelldatei-Verzeichnis sollte entweder eine \textit{main.rs} für ausführbare Programme oder eine \textit{lib.rs} für Bibliotheken enthalten.
Während der Paketmanager Cargo eine solche Benennung als Standardkonvention erwartet, kann bei manueller Nutzung des Compilers auch ein anderer Name für die Quelldatei vergeben werden.

Der Compiler startet in der Wurzeldatei und lädt weitere Module, die durch \rustcinline{mod module;} gekennzeichnet sind (ähnlich \ccinline{#include "module.h"} in C/C++).
Ein Modul kann dabei eine weitere Quelldatei oder ein ganzes Verzeichnis sein.
Ein Verzeichnis wird aber nur als gültiges Modul interpretiert, wenn sich eine \textit{mod.rs} Datei darin befindet.
Um Datentypen und Funktionen aus einem Modul nutzen zu können, ohne dessen kompletten Pfad jedes mal auszuschreiben, müssen sie durch zum Beispiel \rustcinline{use module::functionality::Data;} in dem aktuellen Namensraum bekannt gemacht werden.

Wie bereits angedeutet, wird in Rust nicht eine \enquote{Klasse}, Datenstruktur oder Aufzählung pro Datei erwartet, sondern eine Quelldatei entspricht einem Modul.
Diese umfasst in vielen Fällen wenige aber mehrere Datenstrukturen, zugehörige Aufzählungen und Fehlertypen.
%Module (Verzeichnisse oder Quelldateien) gesucht wird. , in der Module durch \rustcinline{mod module;} und Quelldateien durch \rustcinline{mod functionality;} \enquote{inkludiert} werden können.
%Eine Datei \textit{mod.rs} ist die Wurzeldatei eines Moduls.

\subsection{Als Crate}
\label{rust:structure:crate}

\begin{wrapfigure}{R}{.4\textwidth}
	\rustcincludeml
		{rust:structure:cargo}
		{Vereinfachte Verzeichnisstruktur einer \enquote{crate}}
		{sections/rust.cargo.txt}
\end{wrapfigure}



Eine \enquote{Crate} (dt. Kiste/Kasten) erweitert den klassischen Aufbau um eine \textit{Cargo.toml} Datei, in der Metainformationen zum Projekt hinterlegt werden.
Durch die Benutzung des Werkzeugs \enquote{Cargo} (dt. Fracht/Ladung) können Abhängigkeiten automatisch aufgelöst, heruntergeladen und compiliert werden.

Eine Crate kann entweder ein ausführbares Programm oder eine Bibliothek sein.
Davon abhängig ist die Wurzeldatei \textit{src/main.rs} (für ein ausführbares Programm) oder \textit{src/lib.rs} (für eine Bibliothek).
Mit dem Erzeugen einer Crate (\rustcinline{cargo new --bin meinProg} bzw. \rustcinline{cargo new --lib meineBib}) wird auch gleichzeitig \gls{git} für das Verzeichnis initialisiert.

\section{Hello World}


\begin{wrapfigure}{L}{.5\textwidth}
	\rustcinclude
		{rust:hello_world}
		{\enquote{Hello World} in Rust}
		{sections/rust.hello_world.rs}
\end{wrapfigure}

Der Programmcode in \autoref{rust:hello_world} gibt auf der Konsole \monospaceinline{Hello World} aus.
Dass \rustcinline{fn} die Funktion \rustcinline{main} definiert und diese der Startpunkt des Programms ist, wird vermutlich wenig überraschend sein.
Viel überraschender ist vermutlich eher das Ausrufezeichen in Zeile 2, da es auf den ersten Blick dort nicht hingehören sollte.
In Rust haben Ausrufezeichen und Fragezeichen besondere Bedeutungen, weswegen die Verwendung in Zeile 2 trotzdem richtig ist.

Die Bedeutung des Fragezeichens dient zum schnelleren Auswerten von \rustcinline{Rusult<_, _>}-Werten und wird in \autoref{rust:result} genauer erklärt.
Das Ausrufezeichen kennzeichnet, dass der ansonsten augenscheinliche Funktionsaufruf tatsächlich ein Aufruf einer Makrofunktion ist.

Eine Funktion \rustcinline{println} gibt es nicht, auch keine aus C erwarteten Funktionen wie \ccinline{printf}, \ccinline{fputs} oder \ccinline{sprintf}.
Eine Ausgabe erfolgt durch das \rustcinline{println!} Makro, welches einen String durch Nutzung des \rustcinline{format!} Makros formatiert und erstellt.
Daraufhin wird das \rustcinline{writeln!} Makro verwendet, um die formatierte Zeichenkette auf die Standardausgabe zu schreiben.

\section{Einfache Datentypen}
\label{rust:types:simple}

Die Datentypen in Rust sind im wesentlichen die üblichen  Verdächtigen: \rustcinline{bool} für boolische Ausdrücke; \rustcinline{char} für ein einzelnes Unicode Zeichen; \rustcinline{str} für eine Zeichenkette; \rustcinline{u8}, \rustcinline{i8}, \rustcinline{u16}, \rustcinline{i16}, \rustcinline{u32}, \rustcinline{i32}, \rustcinline{u64}, \rustcinline{i64}, (bald \rustcinline{u128}, \rustcinline{i128} \cite{rust:github:128bit_integer:rfc}) und \rustcinline{usize}, \rustcinline{isize}  für ganzzahlige Werte; \rustcinline{f32}, \rustcinline{f64} für Fließkommazahlen in einfacher und zweifacher Präzision; Arrays und Slices \cite{rust:book:primitives}.

Ganzzahlige Datentypen mit einem führenden \rustcinline{u} sind vorzeichenlos (\enquote{unsigned}), vorzeichenbehaftete Datentypen (\enquote{signed}) sind dagegen mit einem \rustcinline{i} gekennzeichnet.
Fließkommazahlen sind stattdessen mit einem führenden \rustcinline{f} (\enquote{floating point}) gekennzeichnet.
Die darauf folgende Zahl gibt die Anzahl der Bits wieder, die für den Datentyp verwendet wird.
Die einzige Ausnahme sind die ganzzahligen Datentypen \rustcinline{usize} und \rustcinline{isize}, da diese immer so groß sind, wie die Architektur der Zielplattform.
Für die Indexierung eines Arrays oder einer Slice würden andere Datentypen, mit einer fest definierten Größe, keinen Sinn ergeben, da das Maximum an adressierbaren Elementen von der Architektur der Zielplattform abhängig ist.

Durch dieses Schema bei der Bezeichnung der Datentypen wird eine Verwirrung wie zum Beispiel in C unterbunden, wo die primitiven Datentypen (\ccinline{short}, \ccinline{int}, \ccinline{long}, ..) keine definierte Größe haben, sondern abhängig vom eingesetzten Compiler und der Zielplattform sind \cite[187]{deitel2013c}. Erst ab C99 wurden zusätzliche, aber optionale, ganzzahlige Datentypen mit festen Größe definiert \cite[141]{goll2014c}.

Konstanten können in Rust direkt einem Datentyp zugewiesen werden, indem dieser angehängt wird: \rustcinline{4711u16} ist vom Datentyp \rustcinline{u16}.
Unterstriche dürfen an beliebiger Stelle Ziffern trennen, um die Lesbarkeit zu erhöhen: \rustcinline{1_000_000_f32}.
Eine Schreibweise in Binär (\rustcinline{0b0000_1000_u8}), in Hexadezimal (\rustcinline{0xFF_08_u16}) oder in Oktal (\rustcinline{0o64_u8}) ist auch möglich. 
Konstante Zeichen und Zeichenketten können auch automatisch durch ein vorangestelltes \textit{b} in Bytes gewandelt werden: \rustcinline{b'b'} entspricht \rustcinline{0x62_u8} und \rustcinline{b"abc"} entspricht \rustcinline{&[0x61_u8, 0x62_u8, 0x63_u8]}.

Arrays haben immer eine zur Compilezeit bekannte Größe und müssen auch immer mit einem Wert initialisiert werden (siehe \autoref{rust:no_unitialized_usage}).
Dynamische Arrays auf dem Stack gibt es (noch? \cite{rust:github:alloca}) nicht,
stattdessen wird auf die Vektor Implementation der Standardbibliothek verwiesen (siehe \autoref{rust:stdlib}).
Die Notation für Arrays ist \rustcinline{[<Füllwert>; <Größe>]}, wobei die Größe ein konstanter Wert sein muss.
\rustcinline{[0_u8; 128]} steht demnach für ein 128 Byte langes Array vom Datentyp \rustcinline{u8}, das mit 0-en initialisiert ist.

\enquote{Slices} (dt. Scheiben/Stücke) bezeichnet in Rust Referenzen auf Arrays oder auf Teilbereiche von Arrays und Slices.
In einem so genannten \enquote{fat pointer} wird der Startpunkt und die Größe der Slice gespeichert  (siehe auch \autoref{rust:memory_layout:vec_slice} auf Seite \pageref{rust:memory_layout:vec_slice}).
Der Compiler kann hierdurch einen Zugriff außerhalb einer Slice oder eines Arrays entweder zur Laufzeit, oder, falls möglich, zur Compilezeit verhindern (siehe \autoref{rust:zero_cost}).
Ein Buffer-Overflow ist in Rust daher nicht möglich.

Die Notation ähnelt der eines Arrays, aber ohne Größenspezifikation: \rustcinline{&[<Datentyp>]}.
Eine Slice kann zudem immer nur über eine eine Referenz angesprochen werden (siehe \autoref{rust:reference}).
Um eine Slice auf ein Array oder eine andere Slice zu erhalten, muss der Start- und  Endindex des Teilbereiches angegeben werden.
Falls kein Start- oder Endindex angegeben wird, wird das jeweilige Limit übernommen.


Folgendes Beispiel soll die Notation von Arrays und Slices verdeutlichen:

\rustcinclude
	{rust:slices:example}
	{Beispiel eines Arrays und einer Slice}
	{sections/rust.slices.rs}
	
Das in \autoref{rust:slices:example} gezeigte Programm, gibt auf der Konsole \rustcinline{2, 3, 4, } aus.

Variablen werden durch das \rustcinline{let} Schlüsselwort gebunden, das heißt, der Variable wird die Eigentümerschaft über den Wert zugewiesen.
Ausnahmen können Datentypen mit dem Merkmal \rustcinline{Copy} bilden, da diese ein implizite Kopie erlauben (siehe \autoref{rust:generics}).
Anstatt eine Variable optional als unveränderlich zu kennzeichnen (\ccinline{const} in C, \javacinline{final} in Java), wird eine Variable in Rust optional als veränderlich gekennzeichnet (\rustcinline{mut}), während standardmäßig Variablen unveränderlich sind.

\subsubsection{Lokale Typinferenz}

Da Rust ein statisches Typensystem mit lokaler Typinferenz besitzt, muss der Datentyp einer Variable nicht notiert werden, sondern dieser wird automatisch erkannt.
Dies gilt aber nur lokal, also innerhalb von Funktionen und Closures, für Parameterlisten und Rückgabewerte von Funktionen müssen die Datentypen explizit angegeben werden (siehe \autoref{rust:fn}).

\rustcinclude
	{rust:type_interference}
	{Beispiel für lokale Typinferenz}
	{sections/rust.type_interference.rs}
	



\section{Zusammengesetzen Datentypen}
\label{rust:types:composed}

Die Programmiersprache Rust kennt neben den einfachen Datentypen (\autoref{rust:types:simple}) weitere Möglichkeiten Daten zu organisieren:
\begin{itemize}
	\item ein Tupel, das mehrere Werte namenlos zusammenfasst: \rustcinline{(f32, u8)}: \rustcinline{a.0 = 1.0_f32},
	\item eine Datenstruktur, die wie in C Datentypen namenbehaftet zusammenfasst: \linebreak\rustcinline{struct Punkt \{ x: f32, y: f32 \} }: \rustcinline{p.x = 1.0_f32},
	\item und Aufzählungen: \rustcinline{enum Bildschirm \{ Tv, Monitor, Leinwand \}}.
\end{itemize}

Im Vergleich zu C kann ein Eintrag in einem \rustcinline{enum} gleichzeitig Daten wie eine Datenstruktur oder ein Tupel halten, oder lediglich einen Ganzzahlwert repräsentieren.

Mit dem \rustcinline{type} Schlüsselwort können Aliase erstellt oder im Falle von FFI (siehe \autoref{rust:ffi}) aufgelöst werden: \rustcinline{type Vektor = (f32, f32);}
Felder einer Struktur können zudem mit \rustcinline{pub} oder \rustcinline{pub(crate)} gekennzeichnet werden (siehe \autoref{rust:access_modifier}).

Seit Version 1.19 ist auch der Datentyp \rustcinline{union} in Rust verfügbar \cite{rust:v1.19}.
Eine \rustcinline{union} kann aber nur in \rustcinline{unsafe}-Blöcken verwendet werden, da der Compiler eine ordnungsgemäße Nutzung nicht überprüfen kann.
Für diese Abschlussarbeit hat der Datentyp aber keine Relevanz und wird daher nicht weiter erwähnt.

\subsubsection{Referenzen}
\label{rust:reference}

Auf alle Datentypen können Referenzen erstellt werden, um auf diese zuzugreifen, ohne sie zu konsumieren.
In Rust spricht man dann oft davon, den Wert zu \enquote{leihen}, da sich der Eigentümer nicht ändert, sondern für den Gültigkeitsbereich der Referenz eine andere Variable auf den Wert verweist.
Wie bei Variablen, wird zwischen Referenzen auf unveränderlichen und veränderlichen Werte unterschieden (siehe \autoref{rust:ownership}).
Die Notation für Referenzen auf unveränderliche Werte ist \rustcinline{&<Datentyp>}.
Erwartungsgemäß ist \rustcinline{&mut <Datentyp>} die Notation für Referenzen auf veränderliche Werte.
Referenzen auf Referenzen sind möglich.
Eine manuelle Dereferenzierung einer Referenz ist in den allermeisten Fällen nicht nötig, sondern wird vom Compiler vorgenommen.
In Fällen, in denen dies nicht wie erwartet automatisch geschieht, kann eine manuelle Dereferenzierung durch den \rustcinline{*}-Operator erzwungen werden.

\section{Funktionen, Ausdrücke und Statements}
\label{rust:fn}

Funktionen werden durch \rustcinline{fn} gekennzeichnet, gefolgt von dem Funktionsnamen, der Parameterliste und zuletzt der Datentyp für den Rückgabewert.
Selbst wenn kein expliziter Rückgabetyp angegeben wird, wird formal \rustcinline{()} zurück gegeben; \rustcinline{()} entspricht etwa \ccinline{void} aus bekannten Programmiersprachen.
Die Parameterliste unterscheidet sich von bekannten Programmiersprachen wie C und Java, indem zuerst der Variablenname und darauf folgend der Datentyp notiert wird.

\rustcinclude
	{rust:fn:add}
	{Beispiel einer Funktion}
	{sections/rust.fn.add.rs}
	
Obwohl in Zeile 2 von \autoref{rust:fn:add} kein \rustcinline{return} zu sehen ist, wird trotzdem das Ergebnis der Addition zurückgegeben.
Dies liegt daran, dass in Rust vieles ein Ausdruck ist und somit einen Rückgabewerte liefert \cite{rust:book:statements}.
Auch ein if-else ist ein Ausdruck und kann einen Rückgabewert haben.
Ein bedingter Operator (?:) is somit unnötig, da stattdessen ein if-else verwendet werden kann: \rustcinline{let a = if b \{ c \} else \{ d \};}. 
Auch eine Zeile mit einem Semikolon hat formal einen Rückgabewert: \rustcinline{()}.

\todo{Closures Lambdas}

\todo{großes Thema, nur anschneiden? ... es gibt etwas wie Lambdas, nennt sich Closures... besonders weil move / Eigentümerschaft übernehmen, Fn/FnMut/FnOnce + Notation nicht erwähnten?}

\todo{closures are fast, orly, p.310}


\section{Implementierung einer Datenstruktur}

Zu einer Datenstruktur oder Aufzählung kann ein individuelles Verhalten implementiert werden.
In dieser Kombination ähneln diese Konstrukte sehr einer Klasse aus bekannten objektorientierten Programmiersprachen, wie zum Beispiel Java, C\# oder C++ (siehe auch \autoref{rust:oop}).

Einen Konstruktor gibt es jedoch nicht; lediglich die Konvention, eine statische Funktion \rustcinline{new} stattdessen zu verwenden \cite{rust:book:constructors}:

\rustcinclude
	{rust:struct:impl}
	{Punkt Datenstruktur mit einem \enquote{Konstruktor}}
	{sections/rust.struct.impl.rs}
	
In seltenen Fällen wird auch \rustcinline{Default} implementiert (siehe \autoref{rust:trait:default}), wodurch eine statische Funktion \rustcinline{default()} als Konstruktor ohne Parameter bereitgestellt wird.

Da eine Funktionsüberladung nicht möglich ist, sollen stattdessen sprechende Name verwendet werden.
Der \rustcinline{Vec<_>} der Standardbibliothek (siehe \autoref{rust:stdlib}) bietet zum Beispiel zusätzlich \rustcinline{Vec::with_capacity(capacity: usize)} an, um einen Vektor mit einer bestimmten Kapazität zu initialisieren.

Funktionen die sich auf eine Instanz beziehen, haben als ersten Parameter die Variable \rustcinline{self} (konsumierend), \rustcinline{&self} (lesend leihend) oder \rustcinline{&mut self} (exklusiv leihend) deklariert.
Die \rustcinline{self}-Variable entspricht dabei dem \ccinline{this} aus C, C\# oder Java:
\rustcinline{fn x_eq_y(&self) -> bool \{ self.x == self.y \}}.
Ein großgeschriebenes \rustcinline{Self} bezieht sich auf den eigenen Typ, deshalb könnte die Funktion aus \autoref{rust:struct:impl} auch folgende Signatur haben: \rustcinline{pub fn new(x: f32, y: f32) -> Self ...}.
Dies ist aber selten und oft nur in generischem Code anzutreffen (siehe \autoref{rust:traits}).

Für Funktionen können auch die Zugriffsmodifikatoren festgelegt werden (siehe \autoref{rust:access_modifier}).

\section{Generalisierung durch Traits}
\label{rust:traits}
\label{rust:generics}
\label{rust:trait:default}

Ähnlich wie Java oder C\# bietet Rust durch einen eigenen Typ die Möglichkeit, ein gewünschtes Erscheinungsbild zu generalisieren, ohne gleichzeitig eine Implementation vorzugeben.
Im Rust wird dieser Typ \enquote{Trait} (dt. Merkmal) genannt.

Für Merkmale werden Funktionen in einem entsprechenden \rustcinline{trait <Name> \{ \}}-Block ohne Rumpf deklariert.
Optional kann auch ein Standardrumpf implementiert werden, der bei einer Spezialisierung überschrieben werden darf.
Auch auf ein Merkmal kann ein Zugriffsmodifikator gesetzt werden (siehe \autoref{rust:access_modifier}).

Die Implementation eines Merkmals wird für jeden Datentyp in einem separaten Block vorgenommen und entspricht der Notation \rustcinline{impl Merkmal for Datentyp \{ fn ... \} }.
Alternativ können Implementationen auch für ganze Gruppen von anderen Merkmalen vorgenommen werden: \rustcinline{impl<T> Merkmal for T where T: Clone \{ ... \} } (entspricht: \enquote{implementiere \rustcinline{Merkmal} für alle, die \rustcinline{Clone}-bar sind}).

In Zukunft -- oder jetzt in \enquote{nightly} und hinter dem \enquote{feature gate} \rustcinline{specialization} -- wird es möglich sein, ein Standardverhalten für Gruppen zu implementieren und dieses später, für einen spezialisierten Fall, zu überschreiben \cite{rust:github:specialization}.

Merkmale unterscheiden sich in ihrer Handhabung gegenüber anderen Datentypen, da sie im Allgemeinen keine bekannte Größe zur Compilezeit haben.
Während dies in Programmiersprachen wie Java und C\# automatisch durch die Darstellung abstrahiert und versteckt wird, hat ein Entwickler in Rust mehr Kontrolle über die Handhabung.

Dabei gibt es mehrere Vorgehensweisen:
\begin{itemize}
	\item Die einfachste Art erfolgt über das Leihen mittels Referenz: \rustcinline{fn foo(bar: \&Bar)} oder \rustcinline{fn foo(bar: \&mut Bar)} -- ein Unterschied zu anderen Datentypen ist nicht zu erkennen.
	Hierbei werden Funktionen aber dynamisch über eine \enquote{vtable} aufgerufen, weswegen dies höhere Laufzeitkosten mit sich bringt.
	In Zukunft soll dieser Syntax eventuell durch \rustcinline{fn foo(bar: \&dyn Bar)} und \rustcinline{fn foo(bar: \&mut dyn Bar)} ersetzt werden, um auf den dynamischen Aufruf besser hinzuweisen \cite{rust:github:dyn}.
	
	\item Alternativ kann das Objekt, das das geforderte Merkmal implementiert, auf den Heap verschoben und anschließend davon die Eigentümerschaft übertragen werden.
	Dies ist möglich, da nach dem Verschieben auf den Heap die Größe der \rustcinline{Box} bekannt ist.
	Eine \rustcinline{Box} ist letztendlich nur ein Pointer auf einen Speicherbereich auf dem Heap.
	Ein Merkmal in einer \rustcinline{Box} wird \enquote{Trait-Object} genannt und eine Funktionsdeklaration könnte so aussehen: \rustcinline{fn foo(bar: Box<Bar>)}.
	
	\item Die performanteste Alternative ist eine spezialisierte Funktion.
	Der Compiler dupliziert automatisch für jeden Datentyp die Funktion, setzt diesen ein und führt Optimierungen für den Datentyp durch (ähnlich einer Templateklasse in C++).
	In der Notation wird ein lokaler Typ deklariert, der als Bedingung ein oder mehrere Merkmale implementiert haben muss: \rustcinline{fn foo<T: Bar>(bar: T)}.
\end{itemize}

Eine Deklaration \rustcinline{fn foo(bar: Bar)} für das Merkmal \monospaceinline{Bar} ist nicht möglich, da zur Compilezeit eine eindeutige Größe nicht bekannt ist.
Der zu reservierende Speicher für die Variable kann nicht bestimmt werden, weswegen eine Übergabe über den Stack nicht möglich ist.


Im Folgenden werden oft anzutreffende und wichtige Merkmale aus der Standardbibliothek kurz erläutert:
\begin{itemize}
	\item \monospaceinline{Send}: Markiert einen Datentyp als zwischen Threads übertragbar. Automatisch für alle Datentypen implementiert, bei denen auch alle beinhalteten Datentypen von Typ Send sind. Manuelle Implementation ist nicht sicher \cite{rust:book:send_sync}.
	
	\rustcinline{!Send} verhindert dagegen, dass ein Wert zu anderen Threads übertragen werden darf.
	Somit können ansonsten rein textuell beschriebene Beschränkungen, wie zum Beispiel für der OpenGL-Kontext, durch den Compiler überprüft und erzwungen werden.
	
	\item \monospaceinline{Sync}: Markiert einen Datentype als zwischen Threads synchronisierbar, d.h. mehrere Threads dürfen gleichzeitig lesend darauf zugreifen.
	\rustcinline{!Sync} verbietet dies hingegen.
	Automatisch für alle Datentypen implementiert, bei denen auch alle beinhalteten Datentypen von Typ \rustcinline{Sync} sind. Manuelle Implementation ist nicht sicher \cite{rust:book:send_sync}.
	
	\item \monospaceinline{Sized}: Verlangt eine zur Compilezeit bekannte Größe. \monospaceinline{?Sized} erlaubt dagegen eine unbekannte Größe zur Compilezeit.
	
	\item \monospaceinline{Copy}: Markiert einen Datentyp, der durch einfaches Speicherkopieren (etwa \enquote{memcpy}) vervielfacht werden kann. Verlangt, dass alle beinhalteten Datentypen auch \monospaceinline{Copy} sind.
	Alle einfachen Datentypen sind bereits \monospaceinline{Copy}.
	
	\item \monospaceinline{Clone}: Markiert einen Datentyp, der vervielfacht werden kann, dies jedoch nicht durch Kopieren des Speichers möglich ist -- zum Beispiel da der Referenzzähler von \rustcinline{Arc} oder \rustcinline{Rc} erhöht werden muss.
	Stellt die Funktion \rustcinline{clone} bereit, die dafür explizit aufgerufen werden muss.
	Verlangt für eine automatisierte Implementation, dass alle beinhalteten Datentypen auch \monospaceinline{Clone} sind.
	Alle einfachen Datentypen sind bereits \monospaceinline{Clone}.
	
	\item \monospaceinline{Debug} und \monospaceinline{Display}: Erzwingt die Implementation von Funktionen, um einen Datentyp als Text darzustellen. Entweder mit möglichst vielen Zusatzinformationen (\monospaceinline{Debug}) oder schön (\monospaceinline{Display}).
	Verlangt für eine automatisierte Implementation, dass alle beinhalteten Datentypen auch \monospaceinline{Debug} bzw \monospaceinline{Display} sind.
	
	\item \monospaceinline{Default}: Erzwingt die Implementation einer statische Methode \monospaceinline{default()}, die wie ein leerer Standardkonstruktor von Java oder C\# wirkt: Erzeugung einer neuen Instanz mit Standardwerten.
	Verlangt für eine automatisierte Implementation, dass alle beinhalteten Datentypen auch \monospaceinline{Default} sind.
	
	\item \rustcinline{PartialEq}: Verlangt die Implementation einer Funktion, um mit Instanzen des gleichen Typs verglichen werden zu können.
	Im Vergleich zu \monospaceinline{Eq} erlaubt \monospaceinline{PartialEq}, dass Typen keine volle Äquivalenzrelation haben.
	Dies ist zum Beispiel für den Vergleich von Fließkommazahlen wichtig, da laut IEE754  \rustcinline{Nan} ungleich zu allem ist, auch zu sich selbst (\rustcinline{Nan != Nan}) \cite{wiki:nan}\cite[272-275]{rust:orly_programming}\cite{rust:doc:partialeq}.
	
	\item \rustcinline{Eq}: Erlaubt dem Compiler einen Vergleich auf Bit-Ebene durchzuführen, ungeachtet des Datentyps \cite{rust:doc:eq}.
	
	\item \rustcinline{PartialOrd}: Verlangt die Implementation einer Funktion, damit Instanzen des gleichen Typs sortiert werden können. Erlaubt aber auch, dass Werte zueinander nicht sortierbar sind.
	Dies ist zum Beispiel für Fließkommazahlen wichtig, da laut IEE754  \rustcinline{Nan} nicht sortiert werden kann (weder \rustcinline{Nan <= 0} noch \rustcinline{Nan > 0} ergibt \rustcinline{true}) \cite{wiki:nan}\cite[275-277]{rust:orly_programming}\cite{rust:doc:partialord}.
	
	\item \rustcinline{Ord}: Erzwingt im Gegensatz zu \rustcinline{PartialOrd}, dass Werte zueinander immer geordnet werden können.
	
	\item \monospaceinline{Drop}: Verlangt die Implementation einer Funktion, die kurz vor der Speicherfreigabe eines Objekts aufgerufen wird (ähnlich Destruktor aus C++).
\end{itemize}

Mit der Anmerkung \rustcinline{#[derive(..)]} ist eine automatisierte Implementation genannter Merkmale oft möglich, insofern die jeweiligen Bedingungen erfüllt sind.
So kann im allgemeinen \rustcinline{#[derive(Clone)]} genutzt werden, um eine Datenstruktur oder eine Aufzählung automatisch klonbar zu machen oder \rustcinline{#[derive(Debug)]}, um automatisch alle Felder in Text wandeln zu können.
Ein ergonomisches aber auch Fehler reduzierendes Feature.
%Dadurch wird der menschliche Faktor als Fehlerquelle für oft genutzte aber im Prinzip einfache Mechanismen ausgeschlossen.

\section{Zugriffsmodifikatoren}
\label{rust:access_modifier}

Zugriffsmodifikatoren erlauben es in Rust, Module, Datenstrukturen, Aufzählungen, Merkmale und Funktionen gegenüber Nutzern einer Crate und anderen Modulen sichtbar zu machen.
Der standardmäßige Zugriffsmodifikator limitiert die Sichtbarkeit auf das Modul, in dem die Deklaration stattgefunden hat, und wird durch keine Notation eines Zugriffsmodifikators erreicht.
Um die Sichtbarkeit auf die gesamte Crate zu erhöhen, wird ein \rustcinline{pub(crate)} vorangestellt.
Mit \rustcinline{pub} ist die Deklaration für alle sichtbar.

Zugriffsmodifikatoren können auch vor \rustcinline{use} Anweisungen geschrieben werden, um entsprechende Datentypen zusätzlich unter einem neuen Namensraum bekannt zu machen.


\section{Musterabgleich}
\label{rust:match}

Der \rustcinline{match} Ausdruck ist ein sehr mächtiges Werkzeug in Rust und entspricht einem stark erweiterten \ccinline{switch} aus Programmiersprachen wie C, Java oder C\#.
Mit ihm ist es nicht nur möglich, einen Wert einer Aufzählung aufzulösen, sondern Muster inklusive Konstanten zu vergleichen und gleichzeitig auf eventuell beinhaltete Werte zuzugreifen oder diese zu konsumieren.
In einem \rustcinline{match} wird immer der erste kompatible Codepfad ausgeführt.

\rustcinclude
	{rust:match:large}
	{Kompletter \rustcinline{match} Ausdruck}
	{sections/rust.match.large.rs}

Die Ausgabe des Programms aus \autoref{rust:match:large} ist \monospaceinline{Wert ist: text}.
In dem Beispiel ist \rustcinline{value} aus Zeile 2 und 3 \rustcinline{Some("text")}.
Sowohl Zeile 4 als auch Zeile 5 prüfen auf die Variation \rustcinline{Some}, aber nur der Codepfad in Zeile 5 wird ausgeführt.
%Dekonstruktion von Werten mittels Pattern Matching
Dies liegt an der zusätzlichen Prüfung für den beinhalteten Wert, der für den Codepfad in Zeile 4 mit \rustcinline{\"test\"} übereinstimmen müsste.
Da eine Übereinstimmung nicht vorliegt, trifft als nächstes Zeile 5 zu, in der nur die Variation \rustcinline{Some} übereinstimmen muss.
Die Variable \rustcinline{value} bindet bei dieser Übereinstimmung den Wert, um ihn für den Programmcode ansprechbar zu machen.
Falls dies nicht nötig wäre, könnte stattdessen auch die Wildcard \rustcinline{_} verwendet werden.

Das \rustcinline{match} Statement von Rust verlangt, dass eine Musterabgleichung immer zu einem Ergebnis führt.
Dementsprechend müssen entweder alle Varianten einer Aufzählung aufgeführt sein oder ein Standardpfade vorhanden sein \rustcinline{_ => \{ \} }.
Hiermit wird verhindert, dass, nachdem eine Aufzählung um eine Variation erweitert wurde, eine Musterabgleichung nicht um das neue Element ergänzt wurde.

Wenn sogar nur ein konkreter Fall von Bedeutung ist, kann dies in der verkürzten \rustcinline{if let} Schreibweise notiert werden:

\rustcinclude
	{rust:match:iflet}
	{Vereinfachte \rustcinline{if let} Ausdruck}
	{sections/rust.match.iflet.rs}

Ein weiterer Unterschied von \autoref{rust:match:iflet} gegenüber \autoref{rust:match:large} ist in Zeile 3 das Schlüsselwort \rustcinline{ref}, wodurch der Konsum des Wertes verhindert wird.
Das Schlüsselwort \rustcinline{mut} erlaubt zudem eine Änderung des Wertes, weswegen \rustcinline{value} in Zeile 4 vom Typ \rustcinline{&mut u32} ist.
Die Dereferenzierung mit Addition wird somit ermöglicht.

Als Wildcard für sowohl nicht benötigte Werte, als auch alle weiteren Fälle kann \rustcinline{_} verwendet werden: \rustcinline{if let Some(_) = value \{ println!("It's something!"); \} }

Weitere Möglichkeiten, Muster zu erkennen, sind ab Seite 221 in \cite{rust:orly_programming} in detaillierter Ausführung zu finden.
Dazu gehören unter anderem die \enquote{guard expression}, \enquote{bindings} und \enquote{ranges}.
Aufgrund des Umfangs und die Irrelevanz für diese Arbeit wird hier auf eine weitere Vertiefung verzichtet.

\section{Schleifen}

\todo{.}
\url{https://doc.rust-lang.org/book/second-edition/ch03-05-control-flow.html}
\url{https://doc.rust-lang.org/book/first-edition/loops.html}

Rust kennt nur die Schleifen \rustcinline{for}, \rustcinline{while} und \rustcinline{loop}.
Eine \ccinline{do-while} Schleife wie in anderen Programmiersprachen gibt es nicht.


Die einfachste Schleife ist \rustcinline{loop \{ \} }: der Rumpf der Schleife ohne Bedingung wiederholt.
Diesen Schleifentyp gibt es, um auszudrücken was gemeint ist \todo{cite}, also eine Wiederholung ohne Bedingung.
Somit ist eine auf den ersten Blick unverständliche Formulierung wie \ccinline{while (true) \{ \} } oder \ccinline{for(;;) \{ \} } unnötig.
Die \rustcinline{loop} Schleife kann zusätzlich bei einem \rustcinline{break} einen Wert zurückgeben, wie in \autoref{rust:loops:loop} in Zeile 9 zu sehen ist.


\begin{figure}[H]
	\rustcinclude
		{rust:loops:loop}
		{Beispiel Verwendung einer \rustcinline{loop} Schleife}
		{sections/rust.loop.rs}
\end{figure}


Die \rustcinline{for} Schleife erwartet immer etwas iterierbares und entspricht damit einer \ccinline{foreach} aus anderen Programmiersprachen.
Eine inkrementelle Laufvariable, für zum Beispiel die Indexierung eines Arrays, wird durch das Iterieren über einen Zahlenstrahl ermöglicht.
In \autoref{rust:loops:for} ist dies in Zeile 4 zu sehen, während in Zeile 8 direkt über die Werte des Arrays iteriert wird.

\begin{figure}[H]
	\rustcinclude
		{rust:loops:for}
		{Beispiel Verwendung einer \rustcinline{for} Schleife}
		{sections/rust.for.rs}
\end{figure}


Die \rustcinline{while} Schleife ist die langweiligste aller Schleifen, da das Verhalten dem aus anderen Programmiersprachen entspricht.
Der Rumpf wird so lange wiederholt, wie die Bedingung \rustcinline{true} ergibt.
Das Beispiel in \autoref{rust:loops:while} gibt eine Sekunde lang wiederholend \rustcinline{\"Zeit noch nicht um\"} auf der Konsole aus.


\begin{figure}[H]
	\rustcinclude
		{rust:loops:while}
		{Beispiel Verwendung einer \rustcinline{while} Schleife}
		{sections/rust.while.rs}
\end{figure}

Auch in \rustcinline{while} Schleifen können verkürzte Musterabgleichungen durchgeführt werden.
Die Notation ähnelt dem \rustcinline{if let} und ist in \autoref{rust:loops:while:pattern} zu sehen.
Die eingelesene Zeile wird so lange auf der Konsole wieder ausgegeben, bis beim Einlesen ein Fehler auftritt.

\begin{figure}[H]
	\rustcinclude
		{rust:loops:while:pattern}
		{Beispiel Musterabgleichung in einer \rustcinline{while} Schleife}
		{sections/rust.while.pattern.rs}
\end{figure}

\section{Anmerkungen}
\label{rust:annotations}

In Rust können Funktionen, Datentypen und manche Codeblöcke mit Anmerkungen (engl. annotations) versehen werden, um dem Compiler weitere Informationen bereit zu stellen.
Anmerkungen können dabei bestimmte Merkmale automatisiert implementieren (siehe \autoref{rust:traits}), Unit-Tests markieren (siehe \autoref{rust:tests}), Bibliotheken spezifizieren (siehe \autoref{rust:ffi}), \todo{feature gates:} Tore zu Besonderheiten öffnen (siehe \autoref{rust:feature_gates})  oder  Zielplattformen spezifizieren \cite{rust:book:annotation:cfg}.

Eine Anmerkung folgt der Notation \rustcinline{#[<Name>(<optionale Parameter>)]}. So compiliert eine Funktion mit der Anmerkung \rustcinline{#[cfg(unix)]} nur für Unix Systeme, eine Anmerkung \rustcinline{#[cfg(not(unix))]} lässt die Funktion dagegen für alle Systeme compilieren, die nicht ein Unix-System sind.
Dies ermöglicht zum Beispiel mehrere Funktionen mit dem gleichen Namen aber für unterschiedliche Plattformen zu schreiben.
Der Compiler übernimmt dann nur die zur Zielplattform passende Funktion.

\section{Unit- und Integrationstests}
\label{rust:tests}

Unit-Tests und Integrationstests können in Rust ohne eine weitere Bibliothek durchgeführt werden.
Für Unit-Tests müssen Module und Funktionen mit entsprechenden Anmerkung versehen sein, für Integrationstests müssen die Tests im Unterordner \rustcinline{tests/} gespeichert sein \cite{rust:book:tests}.

Unit-Tests sind per Konvention immer in der Datei mit der zu testenden Funktionalität zu finden.
Diese privaten, inneren Module, die konventionell \enquote{tests} benannt sind, werden durch das Attribut \rustcinline{#[cfg(test)]} markiert.
Durch diese Markierung wird der beinhaltete Code nur beim testen compiliert.
\rustcinline{cargo test} führt alle auffindbaren Funktionen mit der Anmerkung \rustcinline{#[test]}, leeren Parameterlisten und keinen Rückgabewerte aus.
Die Makros \rustcinline{assert!(a)}, \rustcinline{assert_eq!(a, b)} und \rustcinline{assert_ne!(a, b)} prüfen Ergebnisse und lösen \rustcinline{panic!}s aus (siehe \autoref{rust:panic}), falls Ergebnisse nicht den erwarteten Werten entsprechen.
Ein Test gilt als bestanden, wenn keine \rustcinline{panic!} ausgelöst wurde.

Integrationstests unterscheiden sich von Unit-Tests, da sie die eigene, zu testende Crate, als externe Crate betrachten.
Dadurch kann nur auf öffentliche Bestandteile zugegriffen und unzureichende Zugriffsrechte aufgespürt werden.
Es gibt keine Test-Module mit der \rustcinline{#[cfg(test)]} Anmerkung innerhalb Integrationstests, da Integrationstests nur beim testen compiliert werden.
Test-Funktionen sind jedoch weiterhin mit \rustcinline{#[test]} markiert.


\section{Namenskonvention und Formatierung}

\todo{.}
Rust bietet einen offiziellen Styleguide, der u.a. eine Namenskonvention für Funktionen, Datentypen, Variationen und Variablen beinhaltet \cite{rust:styleguide:naming}.
Auch über die Formatierung und Einrückungen werden bevorzugte Arten aufgezeigt \cite{rust:styleguide}.


\rustcinclude
	{rust:styleguide:bad}
	{Beispiel für nicht Styleguide konformer Aufzählung}
	{sections/rust.styleguide.bad.rs}
	
\todo{.}
Der Compiler überprüft einige dieser Konventionen und warnt bei Nichteinhaltung.
Das Beispiel in \autoref{rust:styleguide:bad} führt dabei zu den folgenden Warnungen:

\begin{small}
	\textbf{\textcolor{orange}{[warning]}: type `MY\_ENUM` should have a camel case name such as `MyEnum`}
	\textbf{\textcolor{orange}{[warning]}: variant `AN\_ENTRY` should have a camel case name such as `AnEntry`}
	\textbf{\textcolor{orange}{[warning]}: variant `ANOTHER\_ENTRY` should have a camel case name such as `AnotherEntry`}
	warning: unused variable: `a`
\end{small}

\todo{shiat.} Von einer weiteren Vertiefung wird hier abgesehen.
Die Implementierung des Servers versucht weitestgehend konform zur Konvention zu sein und zumindest keine Compilerwarnungen zu erzeugen.

\section{Niemals nichts und niemals unbehandelte Ausnahmen}
\label{rust:no_null}

Rust kennt \ccinline{NULL}(-Pointer) nicht und erlaubt auch keine nicht initialisierte Variablen (siehe \autoref{rust:no_unitialized_usage}), bietet aber einen \rustcinline{Option<_>}-Datentyp als Ersatz an.
Dieser Datentyp erzwingt eine Prüfung vor dem Zugriff auf den optionalen Wert (siehe \autoref{rust:guarantee:no_null}).

Für die Fehlerbehandlung wird nicht auf ein Exception-Handling zurückgegriffen, sondern ein eigener Datentyp angeboten, der entweder den Rückgabewert enthält, oder aber einen Fehler: \rustcinline{Result<_, _>} (siehe \autoref{rust:result}).

Durch den Fragezeichenoperator kann trotzdem ein ähnliches Verhalten wie beim auftreten einer Ausnahme in Java oder C++ erzielt werden (siehe \autoref{rust:result}).

\todo{.}
Ein besonderer Fehler ist eine Panik.
Eine Panik bedeutet in den meisten Fällen einen Logikfehler, weswegen dieser nicht wie ein normaler Fehler behandelt wird.
Eine Panik kann beim Zugriffsversuch außerhalb der Grenzen einer Slice oder eines Arrays, beim Teilen durch 0 oder auch bei einem \rustcinline{.unwrap()} ausgelöst werden.
Eine Panik durchläuft daraufhin, wie eine Exception in C\#, Java oder C++, rückwärts alle Funktionsaufrufe und gibt den Speicher geordnet wieder frei, bis zuletzt der panische Thread endet.
Falls dies im Main-Thread auftritt wird danach der Prozess beendet.
Auch, wenn beim freigeben des Speichers, durch zum Beispiel eine eigene \rustcinline{Drop} Implementierung (siehe \autoref{rust:traits}), eine weitere Panik auftritt, wird der Prozess beendet (genannt \rustcinline{abort}).
\cite[145-147]{rust:orly_programming}


%\section{Besorgter Compiler}
%\label{rust:worried_compiler}
%\todo{many warnings}
%\todo{remove?}


\section{Standardbibliothek}
\label{rust:stdlib}

Das Rust Entwicklerteam ist darum bemüht, die Standardbibliothek sehr leichtgewichtig zu halten.
Nicht eindeutig als fundamental eingestufte Funktionalitäten werden lieber als Crate auf \url{https://crates.io} angeboten, anstatt sie in die Standardbibliothek zu übernehmen \todo{find example again}. 
Mit dieser Entscheidung soll auch eine Entwicklung unabhängig von den Releasezyklen von Rust ermöglicht werden \todo{find source again}.

Die Standardbibliothek ist selbst eine Crate, auf die standardmäßige eine Abhängigkeit erstellt wird.
Für Fälle, in denen diese Abhängigkeit zu schwergewichtig ist, wie zum Beispiel im Embedded-Bereich, kann diese Abhängigkeit durch das Attribut \rustcinline{#![no_std]} unterbunden werden.
Daraufhin sind nur noch die in der \rustcinline{core} Crate zur Verfügung gestellten, fundamentalen Sprachkonstrukte verwendbar.

In dieser Abschlussarbeit wird der volle Funktionsumfang der Standardbibliothek genutzt.
Wichtige, aber auch bekannte Datentypen sind hierbei:

\begin{itemize}
	\item \textbf{std::vec::Vec}: Ein Vektor (wie eine Liste), bei dem die Werte in einem dynamisch groß allokierten Speicherbereich auf dem Heap liegen.
	Ist \textbf{der} Ersatz für dynamische Arrays, da auch der \rustcinline{[]}-Operator überschrieben ist und sich daher ein \textbf{Vec} wie ein Array ansprechen lässt.
	
	In \autoref{rust:memory_layout:vec_slice} ist das Speicherlayout eines \textbf{Vec} und einer \textbf{Slice} auf dem Stack und dem Heap abgebildet.
	Zu sehen ist, dass eine \textbf{Slice} direkt auf die Elemente eines \textbf{Vec} zeigen kann und sich daher von einem Array-Pointer aus C und C++ nur durch die angehängte Längeninformation unterscheidet.
	\begin{figure}[H]
		\centering
		\begin{tikzpicture}
		
			\node[text width=3cm, align=center] at (3,  6.25) {\textbf{Stack}};
			\node[text width=3cm, align=center] at (10, 6.25) {\textbf{Heap}};
			
			\draw[black] (1, 0) -- (1, 6);
			\draw[black] (5, 0) -- (5, 6);
			
			\filldraw[fill=green!20!white, draw=black] (1, 5.5) rectangle(5, 2.5);
			\filldraw[fill=blue!20!white, draw=black] (1, 2.5) rectangle(5, 0.5);
			
			\draw[black, dotted] (1, 5.5) -- (5, 5.5);
			\node[text width=3cm, align=center] at (3, 5) {pointer};
			\draw[black, dotted] (1, 4.5) -- (5, 4.5);
			\node[text width=3cm, align=center] at (3, 4) {capacity (5)};
			\draw[black, dotted] (1, 3.5) -- (5, 3.5);
			\node[text width=3cm, align=center] at (3, 3) {length (4)};
			\draw[black, dotted] (1, 2.5) -- (5, 2.5);
			\node[text width=3cm, align=center] at (3, 2) {pointer};
			\draw[black, dotted] (1, 1.5) -- (5, 1.5);
			\node[text width=3cm, align=center] at (3, 1) {length (2)};
			\draw[black, dotted] (1, 0.5) -- (5, 0.5);
			
			
			% Heap
			\filldraw[fill=green!14!white, draw=black!0] (8, 5.5) rectangle(12, 1.5);
			\filldraw[fill=green!7!white, draw=black!0] (8, 1.5) rectangle(12, 0.5);
			\filldraw[fill=blue!14!white, draw=black!0] (8, 4.5) rectangle(8.5, 2.5);
			\filldraw[fill=blue!14!white, draw=black!0] (11.5, 4.5) rectangle(12, 2.5);
			
			\draw[black] (8, 0) -- (8, 6);
			\draw[black] (12, 0) -- (12, 6);
			
			
			\draw[black, dotted] (8, 5.5) -- (12, 5.5);
			\node[text width=3cm, align=center] at (10, 5) {vec[0]};
			\draw[black, dotted] (8, 4.5) -- (12, 4.5);
			\node[text width=3cm, align=center] at (10, 4) {vec[1]};
			\draw[black, dotted] (8, 3.5) -- (12, 3.5);
			\node[text width=3cm, align=center] at (10, 3) {vec[2]};
			\draw[black, dotted] (8, 2.5) -- (12, 2.5);
			\node[text width=3cm, align=center] at (10, 2) {vec[3]};
			\draw[black, dotted] (8, 1.5) -- (12, 1.5);
			\node[text width=3cm, align=center] at (10, 1) {vec[4]};
			\draw[black, dotted] (8, 0.5) -- (12, 0.5);
			
			
			
			\draw[decoration={brace,mirror,raise=5pt},decorate] (1, 5.5) -- node[left=6pt] {Vec} (1, 2.55);
			\draw[decoration={brace,mirror,raise=5pt},decorate] (1, 2.45) -- node[left=6pt] {Slice} (1, 0.5);
			
			\draw[->,black] (4.5, 5) -- (8, 5.5);
			\draw[->,black] (4.5, 2) -- (8, 4.5);
		
		\end{tikzpicture}
		\caption{Speicherlayout Vec und Slice \cite[63]{rust:orly_programming}}
		\label{rust:memory_layout:vec_slice}
	\end{figure}
	
	\item \textbf{std::boxed::Box}:
	Verweis auf einen Speicherbereich auf dem Heap für einen beliebigen Datentyp.
	Erlaubt es, u.a. Eigentümerschaft über einen unbekannt großen Datentyp zu erlangen, da dies die Größe einer \textbf{Box} nicht beeinflusst (siehe \autoref{rust:generics}).
	Eine \textbf{Box} kann mit einem immer gültigen Heap-Pointer aus C und C++ verglichen werden.
	
	\item \textbf{std::string::String}: Eine UTF-8 codierte, vergrößer- und verkleinerbare Zeichenkette auf dem Heap.
	
	\item \textbf{std::rc::Rc}: Erweitert die \textbf{Box} um einen Referenzzähler und ermöglicht somit augenscheinlich mehrere Eigentümer, mit der Limitierung, nur noch lesend auf den beinhalteten Wert zugreifen zu können.
	Der beinhaltende Wert wird erst bei Lebensende der letzten \textbf{Rc} Instanz freigegeben.
	Verwendet einen mit wenig Mehraufwand verbundenen, nicht-atomaren Referenzzähler, weswegen eine \textbf{Rc} Instanz nicht zwischen Threads übertragen werden kann (\rustcinline{!Sync}, \rustcinline{!Send}).
	
	\item \textbf{std::sync::Arc}: Entspricht weitestgehend dem \textbf{Rc}, verwendet jedoch einen atomaren Referenzzähler.
	Dies ist zwar mit höheren Laufzeitkosten verbunden, erlaubt es aber, dass eine \textbf{Arc} Instanz zwischen Threads übertragen werden kann.
	Mehrere Threads können daher lesend auf den beinhalteten Wert zugreifen.
	
	\item \textbf{std::sync::Mutex}: Versichert einen exklusiven Zugriff auf den beinhalteten Wert. \todo{threads}
	In Rust schützt eine \textbf{Mutex} anstatt einem bestimmten Codeabschnitt, den beinhalteten Wert.
	Ein Zugriff ist erst nach einem erfolgreichen \todo{lock} möglich.
	
	\item \textbf{std::sync::RwLock}: Erlaubt mehreren Threads gleichzeitig lesend oder einem Thread schreibend auf den beinhalteten Wert zuzugreifen. Wie bei einer \textbf{Mutex} kann erst nach einem erfolgreichen \todo{lock} auf den geschützten Wert zugegriffen werden.
	
	%\item \textbf{std::net::TcpStream}: \todo{?} 
	%\item \textbf{Module std::thread}: \todo{?}
	%\item \textbf{std::collections::HashMap}: \todo{?}
	
\end{itemize}


\section{Speicherverwaltung}
\label{rust:scope}
\label{rust:static_analysis}

Rust benutzt ein \enquote{statisches, automatisches Speicher Management -- keinen Garbage Collector} \cite{rust:youtube:goto2017}.
Das bedeutet, die Lebenszeit einer Variable wird statisch während der Compilezeit anhand des Geltungsbereichs ermittelt (siehe \autoref{rust:scope}).
Durch diese statische Analyses findet der Compiler heraus, wann der Speicher einer Variable wieder freigegeben werden muss.
Dies ist genau dann, wenn der Geltungsbereich des Eigentümers zu Ende ist.
Weder ein \gls{gc}, der dies zur Laufzeit nachverfolgt, noch ein manuelles Eingreifen durch den Entwickler (zum Beispiel durch \ccinline{free(*void)}, wie in C/C++ üblich) ist nötig.

Falls der Compiler keine ordnungsgemäße Nutzung feststellen kann, wie zum Beispiel eine Referenz, die länger als die eigentliche Variable lebt, wird die Kompilation verweigert.
Der menschliche Faktor als Fehlerquelle wird wieder unterbunden, ohne Laufzeitkosten zu erzeugen (siehe \autoref{rust:guarantee:no_dangling_pointer}).

Im folgenden \autoref{rust:memory:scope} wird beispielhaft Speicher auf dem Heap allokiert.
Dieser wird ordnungsgemäß freigegeben, ohne manuell eine Freigabe einzuleiten.

\begin{figure}[H]
	\rustcinclude
		{rust:memory:scope}
		{Geltungsbereich von Variablen}
		{sections/rust.memory.rs}
\end{figure}

Eine Variable kann auch vorzeitig durch den Aufruf von \rustcinline{std::mem::drop(_)} freigegeben werden.
Die optionalen Implementation des \rustcinline{std::op::Drop}-Merkmals (siehe \autoref{rust:generics}) kommt der Implementation des Destruktors aus C++ gleich.

\section{Eigentümer- und Verleihprinzip}
\label{rust:ownership}

Bereits 2003 beschreibt Bruce Powel Douglass im Buch \enquote{Real-Time Design Patterns}, dass \enquote{passive} Objekte ihre Arbeit nur in dem Thread-Kontext ihres \enquote{aktiven} Eigentümers tätigen sollen \cite[204]{douglass2003real}.
In dem beschriebenen \enquote{Concurrency Pattern} werden Objekte eindeutig Eigentümern zugeordnet, um so eine sicherere Nebenläufigkeit zu erlauben.

Diese Philosophie setzt Rust direkt in der Sprache um, denn in Rust darf ein Wert immer nur einen Eigentümer haben.
Zusätzlich zu einem immer eindeutig identifizierbaren Eigentümer, kann der Wert auch ausgeliehen werden, um einen kurzzeitigen Zugriff zu erlauben; entweder exklusiv mit sowohl Lese- als auch Schreiberlaubnis, oder mehrfache mit nur Leseerlaubnis.

Eigentümerschaft kann auch übertragen werden, der vorherige Eigentümer kann danach nicht mehr auf den Wert zugreifen.
Ein entsprechender Versuch wird mit einer Fehlermeldung durch den Compiler bemängelt.

Die Garantie, nur einen Eigentümer, eine exklusive Schreiberlaubnis oder mehrere Leseerlaubnisse auf eine Variable zu haben, wird durch die statische Lebenszeitanalyse garantiert (siehe \autoref{rust:scope}).
Da dies zur Compilezeit geschieht, ist eine Überprüfung zur Laufzeit nicht nötig, weshalb diese Philosophie keinen Laufzeitkosten mit sich bringt.

\todo{..}
Durch das Eigentümerprinzip wird ein \enquote{dangling pointer} (siehe \autoref{rust:guarantee:no_dangling_pointer}) verhindert.


\todo{...}
Die Vorzüge bei dem Eigentümerprinzip gehen aber über den reinen Einsatz bei Parallelisierungen hinaus.
Es wird eindeutig klar, ob ein Wert von einer Funktion konsumiert wird oder nicht.
Ob eine Kopie für einen Funktionsaufruf erstellt werden muss, ist anhand dessen Funktionskopfs ablesbar.
Dies vermeidet unnötige Kopien.
Noch viel wichtiger ist aber, dass anhand der statischen Analyse, die Anzahl der \todo{Leihungen} jederzeit klar ist, und somit verhindert wird, dass Speicher freigegeben wird, obwohl dieser noch in Benutzung ist (siehe \autoref{rust:guarantee:no_dangling_pointer}).

\todo{...}
Dies erlaubt gleichzeitig Optimierungen da Speicherbereich übernommen werden kann, anstatt neue anzufordern und zu kopieren.
Dies geht aber nur, da dieses Verhalten durch die Deklaration im Funktionsrumpf, sowohl für den Programmierer als auch für den Compiler, eindeutig nachvollziehbar ist.

\todo{...}
\rustcinline{String::from_utf8(vec: Vec<u8>)} nimmt zum Beispiel einen \rustcinline{Vec<u8>} entgegen und konsumiert diesen.
Für den Aufrufer ist somit klar, dass dieser nach dem Funktionsaufruf nicht mehr verwendet werden kann, da die Eigentümerschaft der Funktion \rustcinline{from_utf8} übertragen wurde.
Dies erlaubt der Funktion, den Speicherbereich des \rustcinline{Vec<u8>} für den \rustcinline{String} zu nutzen ohne neuen Speicher zu allokieren oder zu kopieren \todo{proof: \enquote{This method will take care to not copy the vector, for efficiency's sake}} \url{https://doc.rust-lang.org/std/string/struct.String.html#method.from_utf8}.
In Situationen in denen der \rustcinline{Vec<u8>} weiterhin genutzt werden muss, kann dieser für den Funktionsaufruf mit \rustcinline{clone} geklont werden.

\todo{verhindert falsches verhalten, kein add / remove while iterating for example}

\todo{vorteile klar ob variable konsumiert wird, keine freigeben von verwendeten resourcen, kein unnötiges kopieren, into()}

\section{Rust als funktionale Programmiersprache ??}

\todo{functional programming -> no global state, no exceptions, find literature}

\todo{prove via code}

\todo{Closures Lambdas}

\todo{closures are fast, orly, p.310}


\section{Rust als Objekt-Orientierte Programmiersprache ??}
\label{rust:oop}

Vererbung explizit nicht erwünscht, Composition over Inheritance, inheritance dissallows static sizes, enum allow passing by value

\todo{trait}

\todo{prove via design patterns, a few? from faq::  Is Rust object oriented? It is multi-paradigm. Many things you can do in OO languages you can do in Rust, but not everything, and not always using the same abstraction you’re accustomed to.}


\section{Versprechen von Rust}
\label{rust:guarantees}

\begin{quotation}
	\textit{\enquote{It’s not bad programmers, it’s that C is a hostile language}} 
	\cite[54]{rust:c_is_hostile_mena}
\end{quotation}

\begin{quotation}
	\textit{\enquote{I’m thinking that C is actively hostile to writing and maintaining reliable code}} 
	\cite[129]{rust:c_is_hostile_mena}
\end{quotation}

Rust wirbt mit Versprechen und Garantien, die dafür sorgen sollen, typische Fehler zu vermeiden.
In einer perfekten Welt wären viele dieser Maßnahmen nicht nötig, da perfekte Wesen niemals einen Fehler machen und niemals etwas übersehen würden.
Programmierer sind aber Menschen, Menschen machen Fehler.
Deswegen hat Rust einige interessante Mechaniken eingeführt, bekannte Fehlerquellen zu unterbinden und erzwingt deren Einhaltung, indem andere Vorgehensweisen meist ausgeschlossen werden.

Dieses Kapitel beschäftigt sich mit den wichtigsten und bekanntesten dieser Mechaniken.

\subsection{Kein undefiniertes Verhalten}
\label{rust:no_unitialized_usage}
\label{rust:no_undefined}

Bei der Entwicklung von Rust wird ein sehr großer Fokus darauf gelegt, keine undefinierten Zustände zu erlauben.
Daher ist es normalerweise nicht möglich, ein undefiniertes Verhalten oder einen undefinierten Zustand zu erzeugen.
Die Ausnahme bilden einige Fälle innerhalb von \rustcinline{unsafe} Blöcken, für zum Beispiel FFI (siehe \autoref{rust:ffi}).
Für diese Fälle gibt es eine überschaubare Liste von Szenarien, aus denen ein undefinierter Zustand bzw. undefiniertes Verhalten resultieren kann \cite{rust:book:undefined}.

Als einfaches Beispiel eines undefinierten Zustandes in C ist eine Variable, die deklariert wurde, der aber noch keinen Wert zugewiesen wurde.
In manchen Szenarien hat die Variable dann den Wert der in diesem Moment an der entsprechenden Stelle im Speicher steht, in anderen Szenarien wird der Speicher vom Betriebssystem, Allokator oder von vom Compiler eingefügten Befehlen mit 0en gefüllt -- eine sichere Aussage ist nicht möglich.
Sich darauf zu verlassen, dass neue Werte automatisch mit 0 initialisiert wurden, kann auf neuen Systemen oder mit anderen Compilern ein unvorhersehbares Verhalten provozieren.

Rust lässt deshalb keinen Zugriff auf Variablen zu, die nicht zuvor initialisiert wurden \cite[126]{rust:orly_programming}.
Der Compiler stoppt mit einem Fehler: \enquote{\textbf{\textcolor{red}{error[E0381]}: use of possibly uninitialized variable: `a`}}.


\subsection{Keine vergessene Null-Pointer Prüfung}
\label{rust:guarantee:no_null}

\begin{quotation}
	\textit{\enquote{I call it my billion-dollar mistake. It was the invention of the null reference in 1965}}
	\cite[Tony Hoare, QCon Software Konferenz in London, 2009]{rust:infoq:null}
	\todo{cant find moment in video / presentation of this qutoe!?}
\end{quotation}

Wie in \autoref{rust:no_null} bereits erwähnt, kennt Rust keinen \ccinline{NULL}-Pointer.
Daher ist es auch nicht möglich, durch Nachlässigkeit auf den falschen Speicher zuzugreifen.
Eine Referenz ist immer gültig.
Für Fälle, in denen es situationsbedingt keinen gültigen Wert gibt, bietet Rust stattdessen den \rustcinline{Option<_>} Datentyp an.
\rustcinline{Option<_>} ist eine Aufzählung, die entweder \rustcinline{None} ohne einen Wert, oder \rustcinline{Some(_)} mit einem Wert ist.
Auf den Wert kann nicht zugegriffen werden, ohne zu prüfen, ob wirklich die Variation \rustcinline{Some(_)} vorliegt.
Dies kann durch \rustcinline{match} oder verkürzt durch ein \rustcinline{if let Some(wert) = optional \{ /* tu etwas mit wert */ \}} geschehen (siehe \autoref{rust:match}).

In vielen Fällen kann der \rustcinline{Option<_>} Datentyp in Maschinencode als \ccinline{NULL}-Pointer dargestellt werden, weswegen durch diese Abstraktion keine weiteren Laufzeitkosten eingeführt werden \cite[100]{rust:orly_programming} (siehe \autoref{rust:zero_cost}).

\subsection{Keine vergessene Fehlerprüfung}
\label{rust:result}

\label{rust:panic}
\todo{panic! -> Wenn das boot nicht mehr zu retten ist}

\begin{figure}[H]
	\ccinclude
	{rust:result:c_bad_fopen}
	{Negativbeispiel: Fehlende Fehlerprüfung in C}
	{sections/rust.fopen.c}
\end{figure}

In \autoref{rust:result:c_bad_fopen} sind mindestens zwei Fehler versteckt, die aber keinen Compileabbruch auslösen, sondern sich zur Laufzeit zeigen können.
Der erste Fehler ist eine fehlende Überprüfung des Rückgabewertes von \ccinline{fopen} in Zeile 4.
Der Rückgabewert kann \ccinline{NULL} sein, falls das Öffnen der Datei fehlgeschlagen ist.
Der Versuch in die Datei zu schreiben in Zeile 5 kann daraufhin in einem Speicherzugriffsfehler resultieren und das Programm abstürzen lassen.

In Rust wird weder eine Ausnahme geworfen, noch ein Rückgabewert zurück gegeben, der ohne Prüfung verwendet werden kann:

\begin{figure}[H]
	\rustcinclude
		{rust:result:rust_good_fopen}
		{Positivbeispiel: Keine fehlende Fehlerprüfung in Rust}
		{sections/rust.fopen.rs}
\end{figure}

Der Rückgabewert von \rustcinline{File::open("private.key")} in Zeile 5 von \autoref{rust:result:rust_good_fopen} ist vom Typ \rustcinline{Result<File, Error>}.
Auf den eigentlichen Rückgabewert \rustcinline{File} kann nicht ohne eine Fehlerprüfung zugegriffen werden, da dies \rustcinline{Result} verhindert.
Eine Fehlerprüfung kann wie in Zeile 5 mit einem \rustcinline{match} oder verkürzt durch ein \rustcinline{if let} wie in Zeile 8 geschehen.

Durch die statische Lebenszeitanalyse (siehe \autoref{rust:static_analysis}) in Rust ist der Geltungsbereich der \rustcinline{mut file} Variable bekannt, deshalb wird in dem Beispiel in Rust in \autoref{rust:result:rust_good_fopen} die Datei auch wieder ordnungsgemäß geschlossen.
Dies ist im C Beispiel in \autoref{rust:result:c_bad_fopen} nicht der Fall.
In einem größeren Programm könnte so zu unbekanntem Zeitpunkt das Limit an gleichzeitig geöffneten Dateien erreicht werden.

Da ein \rustcinline{match} oder ein \rustcinline{if let} für jeden Funktionsaufruf, der einen Fehler zurückgeben könnte, sehr umständlich und bereits für kleine Beispiele wie \autoref{rust:result:rust_good_fopen} unübersichtlich wird, kann dies durch den Operator \rustcinline{?} abgekürzt werden.
Dazu muss die Funktion, die den Operator verwendet aber auch ein \rustcinline{Result} in einem kompatiblen Fehlertyp zurückgeben, wie in \autoref{rust:result:shorthand} zu sehen:

\begin{figure}[H]
	\rustcinclude
		{rust:result:shorthand}
		{Verkürzte Fehlerbehandlung in Rust}
		{sections/rust.result.shorthand.rs}
\end{figure}



\rustcinclude
{rust:ownership:scope}
{Eigentümer und Referenzen von Variablen}
{sections/rust.ownership.rs}

\subsection{No dangling pointer}
\label{rust:guarantee:no_dangling_pointer}

\todo{.}
Durch die Einhaltung des Eigentümerprinzips wird die typische Fehlerquelle aus C und C++ verhindert, bei der durch einen Pointer auf bereits deallokierten Speicher zugegriffen wird.
Ein Verhalten ist hierbei nicht vorhersehbar. Es könnte einfach nur auf den als \enquote{frei} markierten Speicherbereich zugegriffen werden, der noch die vorherigen Werte enthält.
Es könnte aber auch auf den nun neu zugewiesenen Speicherbereiche geschrieben und dabei Werte anderer Datenstrukturen überschrieben werden.
Im besten Fall hat das Betriebssystem die Speicherseite dem Programm bereits entzogen und das Programm stürzt einfach nur ab.

Im Beispiel in \autoref{rust:owner:c_bad_free} wird durch eine Fehlerhafte Implementierung der Funktion \ccinline{klone_computer} ein \enquote{dangling pointer} in C provoziert.
Daraufhin wird versucht, mit dem gleichen Beispiel in \autoref{rust:owner:rust_bad_free} ein \enquote{dangling pointer} in Rust zu provozieren.



\begin{figure}[H]
	\ccinclude
	{rust:owner:c_bad_free}
	{Negativbeispiel: Fehlerhafter Klon \todo{.}}
	{sections/rust.owner.free.c}
\end{figure}

\begin{figure}[H]
	\rustcinclude
	{rust:owner:rust_bad_free}
	{Negativbeispiel: Fehlerhafter Klon in Rust\todo{.}}
	{sections/rust.owner.free.rs}
\end{figure}

\todo{.}
Ein äquivalentes Beispiel zu dem C-Beispiel in Rust zu schreiben, ist schwierig.
Das Feld \enquote{model} in der C-Struktur ist im ersten Fall der Eigentümer der Zeichenkette (Datentyp \rustcinline{String} in Rust) und in zweiten Fall beim Klonen der Entleiher (Datentyp \rustcinline{&str} in Rust).
Dieser Unterschied ist gleichzeitig auch die Fehlerquelle im C-Beispiel.

Im Rust-Beispiel ist die Zeichenkette deswegen in Zeile 19 außerhalb der \rustcinline{erstelle_computer} Funktion, da der Geltungsbereich ansonsten beim Verlassen der Funktion bereits zu Ende wäre.
Das Beispiel in \autoref{rust:owner:rust_bad_free} entspricht dennoch weitestgehend dem Beispiel aus \autoref{rust:owner:c_bad_free}, zumindest genügend, um zu zeigen, dass der Rust Compiler den Fehler erkennt und die Kompilation abbricht: \textbf{\textcolor{red}{error[E0505]}: cannot move out of `c1` because it is borrowed}

\subsection{Speichersicherheit}
\label{rust:guarantee:memory_safety}


In Rust werden verschiedene Arten von Speichersicherheit Garantiert. Zum einen, wird niemals auf einen \ccinline{NULL}-Pointer zugegriffen (siehe \autoref{rust:guarantee:no_null}), zum anderen wird niemals auf einen bereits deallokierten Speicherbereich zugegriffen (siehe \autoref{rust:guarantee:no_dangling_pointer}).

Die Speichersicherheit umfasst aber Zugriffe auf Puffer. So ist es nicht möglich einen Pufferüberlauf zu provozieren, da die Größe von einem Array und einer Slice immer bekannt ist.
Der Compiler erzwingt eine Grenzüberprüfung beim Zugriff zur Laufzeit, falls die Einhaltung statisch nicht ersichtlich ist (\autoref{rust:zero_cost}).

Ein Datenwettlauf wird auch, durch Anwendung des Eigentümerprinzips, verhindert (siehe \autoref{rust:guarantee:thread_safety}).

\subsection{Sichere Nebenläufigkeit}
\label{rust:guarantee:thread_safety}

Eine sichere Nebenläufigkeit wird in Rust durch das Eigentümerprinzip (siehe \autoref{rust:ownership}) in Kombination mit den \rustcinline{Send} und \rustcinline{Sync} Merkmalen (siehe \autoref{rust:traits}) erreicht.
Dabei ist diese sichere Nebenläufigkeit meist unsichtbar \cite[41]{rust:orly_programming}, da der Compiler eine unsichere und damit syntaktisch falsche Verwendung nicht übersetzt.
Ein Rust Programm das compiliert, ist daher, in vielerlei Hinsicht, sicher in der Nebenläufigkeit.
Einzig ein \enquote{Deadlock} kann nicht statisch ermittelt und verhindert werden.

Eine Wettlaufsituation (englisch \enquote{race condition}) um einen Wert ist in Rust nicht möglich.
Das Eigentümer- und Leihprinzip verhindert dies, denn es kann nur exklusiv schreibend auf einen Wert zugegriffen werden (siehe \autoref{rust:ownership}).
Für einen Datenwettlauf muss dagegen, gleichzeitig zu einem schreibenden, ein lesender Zugriff erfolgen.

Datentypen, die einen gemeinsamen Zugriff auf veränderliche Werte ermöglichen (\rustcinline{Mutex}, \rustcinline{RwLock} und im erweiterten Sinne \enquote{channels}), liefern immer ein Ergebnis ob der Versuch, einen exklusiven Schreib- oder Lesezugriff zu erhalten, geklappt hat.
Eine mögliche Fehlersituation ist ein Thread, bei dem eine \rustcinline{panic!} (siehe \autoref{rust:panic}) aufgetreten ist, während dieser einen exklusiven Schreibzugriff auf den geschützten Wert hatte.
In diesem Fall wird ein \rustcinline{PoisonError} zurückgegeben, der einen direkten Zugriff auf den Wert verhindert und vermittelt, dass der geschützte Wert vermutlich in keinem konsistenten Zustand mehr ist.

\subsection{Zero Cost Abstraction}
\label{rust:zero_cost}

Trotz der vielen verwendeten Abstraktionen möchte Rust dadurch möglichst keine weitere Laufzeitkosten erzeugen.
Beim Übersetzen werden deshalb viele Abstraktionen durch Optimierungen für den Maschinencode unsichtbar.

Der \rustcinline{Option<_>} Datentyp kann zum Beispiel in vielen Fällen als Pointer dargestellt werden, der bei \ccinline{NULL} \rustcinline{None} und ansonsten \rustcinline{Some(_)} ist \cite[100]{rust:orly_programming}.
Somit wird eine Überprüfung erzwungen, ohne dabei Laufzeitkosten erzeugt zu haben.

\todo{bounds check compiler optmization}

Ein weiteres Beispiel sind die Referenzzählertypen \rustcinline{Rc} und \rustcinline{Arc<_>}.
Der Zähler ist im Heap direkt vor dem beinhalteten Wert und nicht in einem extra Speicherbereich, weshalb ein weiterer, indirekter Speicherzugriff mit Laufzeitkosten verhindert werden kann.


\begin{figure}[H]
	\centering
	\begin{tikzpicture}
	
	\node[text width=3cm, align=center] at (3,  4.25) {\textbf{Stack}};
	\node[text width=3cm, align=center] at (10, 4.25) {\textbf{Heap}};
	
	\draw[black] (1, 0) -- (1, 4);
	\draw[black] (5, 0) -- (5, 4);
	
	\filldraw[fill=red!20!white, draw=black] (1, 3.5) rectangle(5, 2.5);
	\filldraw[fill=red!20!white, draw=black] (1, 1.5) rectangle(5, 0.5);
	%\filldraw[fill=blue!20!white, draw=black] (1, 2.5) rectangle(5, 0.5);
	
	%\draw[black, dotted] (1, 5.5) -- (5, 5.5);
	%\node[text width=3cm, align=center] at (3, 5) {pointer};
	%\draw[black, dotted] (1, 4.5) -- (5, 4.5);
	%\node[text width=3cm, align=center] at (3, 4) {capacity (5)};
	\draw[black, dotted] (1, 3.5) -- (5, 3.5);
	\node[text width=3cm, align=center] at (3, 3) {pointer};
	\draw[black, dotted] (1, 2.5) -- (5, 2.5);
	\node[text width=3cm, align=center] at (3, 2) {some variable};
	\draw[black, dotted] (1, 1.5) -- (5, 1.5);
	\node[text width=3cm, align=center] at (3, 1) {pointer};
	\draw[black, dotted] (1, 0.5) -- (5, 0.5);
	
	
	% Heap
	%\filldraw[fill=green!14!white, draw=black!0] (8, 5.5) rectangle(12, 1.5);
	\filldraw[fill=green!7!white, draw=black!0] (8, 2.5) rectangle(12, 0.5);
	\filldraw[fill=red!14!white, draw=black!0] (8, 3.5) rectangle(12, 2.5);
	%\filldraw[fill=red!14!white, draw=black!0] (11.5, 3.5) rectangle(12, 2.5);
	
	\draw[black] (8, 0) -- (8, 4);
	\draw[black] (12, 0) -- (12, 4);
	
	
	%\draw[black, dotted] (8, 5.5) -- (12, 5.5);
	%\node[text width=3cm, align=center] at (10, 5) {vec[0]};
	%\draw[black, dotted] (8, 4.5) -- (12, 4.5);
	%\node[text width=3cm, align=center] at (10, 4) {vec[1]};
	\draw[black, dotted] (8, 3.5) -- (12, 3.5);
	\node[text width=3cm, align=center] at (10, 3) {counter};
	\draw[black, dotted] (8, 2.5) -- (12, 2.5);
	\node[text width=3cm, align=center] at (10, 2) {actual};
	\draw[black, dotted] (8, 1.5) -- (12, 1.5);
	\node[text width=3cm, align=center] at (10, 1) {value};
	\draw[black, dotted] (8, 0.5) -- (12, 0.5);
	
	
	
	\draw[decoration={brace,mirror,raise=5pt},decorate] (1, 3.5) -- node[left=6pt] {Rc} (1, 2.5);
	\draw[decoration={brace,mirror,raise=5pt},decorate] (1, 1.5) -- node[left=6pt] {Rc} (1, 0.5);
	%\draw[decoration={brace,mirror,raise=5pt},decorate] (1, 2.45) -- node[left=6pt] {Slice} (1, 0.5);
	
	%\draw[->,black] (4.5, 5) -- (8, 5.5);
	\draw[->,black] (4.5, 3) -- (8, 3.5);
	\draw[->,black] (4.5, 1) -- (8, 3.5);
	
	\end{tikzpicture}
	\caption{Speicherlayout Rc \cite[90-91]{rust:orly_programming}}
\end{figure}



\section{Einbinden von externen Bibliotheken}

\subsubsection{Externe Datentypen}
\label{rust:ffi}
\label{rust:ffi:datatypes}

Rust bietet durch das \gls{ffi} \todo{(FFI)} die Möglichkeit, andere (System-)Bibliotheken einzubinden.
Entsprechende Strukturen und Funktionen werden durch einen \rustcinline{extern} Block
oder im Falle von Strukturen stattdessen optional mit einem \rustcinline{#[repr(C)]} gekennzeichnet.

In einem Beispiel, soll die Nutzung von \gls{ffi} demonstriert werden.

\begin{figure}[H]
	\ccinclude
		{rust:ffi:position_offset_c}
		{Ausschnitt von \enquote{PositionOffset} (C-Code) aus der \textit{libmessages-sys} Crate}
		{sections/rust.position_offset.c}
	
\end{figure}

Die Struktur in \autoref{rust:ffi:position_offset_c} muss zur Nutzung in Rust zuerst bekannt gemacht werden.
Dabei gibt es mehrere Möglichkeiten:
\begin{itemize}
	\item Falls der Aufbau der Struktur nicht von Bedeutung ist, kann es ausreichen, den Datentyp lediglich bekannt zu machen: \rustcinline{#[repr(C)] struct PositionOffset;}.
	In diesem Fall können aber nur Referenzen und Raw-Pointer auf die Struktur verwendet werden.
	\label{rust:ffi:example:enumerate:repr}
	
	\item Falls der Aufbau wie in \autoref{rust:ffi:example:enumerate:repr} unbedeutend ist, es soll aber ausdrücklich auf einen externen Datentyp hingewiesen werden soll, kann dieser in einem \rustcinline{extern \{ \} } Block bekannt gemacht werden: \rustcinline{extern \{ type PositionOffset; \}} \cite{rust:github:extern_type}.
	Dies ist zum jetzigen Zeitpunkt aber nur in \enquote{nightly} und hinter dem \enquote{feature gate} \monospaceinline{extern_types} möglich.
	
	\item Der Inhalt der Struktur ist von Bedeutung, da darauf zugegriffen oder in Rust eine Instanz werden soll. In diesem Fall ist eine komplette Wiedergabe die Struktur unumgänglich:
	\begin{figure}[H]
		\rustcinclude
			{rust:ffi:position_offset_rust}
			{Ausschnitt von \enquote{PositionOffset} (Rust-Code) aus der \textit{libmessages-sys} Crate}
			{sections/rust.position_offset.rs}
	\end{figure}
	
	In \autoref{rust:ffi:position_offset_rust} ist die Struktur \enquote{PositionOffset} deklariert,
	die durch das Attribut \rustcinline{#[repr(C)]} wie eine C-Struktur im Speicher organisiert wird.
	Damit die Struktur in Rust kompatibel zu der in C ist, müssen die Variablen von der selben Größe sein, ansonsten würde das Speicherlayout nicht übereinstimmen.
	Hierfür werden spezielle Datentypen (\rustcinline{c_long}, \rustcinline{c_void}, \rustcinline{c_char}, ...) angeboten, um die Kompatibilität mit verschiedenen Systemen und C-Compilern zu wahren.
	% (siehe \autoref{rust:types:simple}).
	
%	\rustcinline{*mut c_long} entspricht dabei dem C-Pointer für \rustcinline{&mut c_long}, also \ccinline{long*}, ein C-Pointer für \rustcinline{&c_long} entspricht \rustcinline{*const c_long}.
	
%	C-Pointer werden in Rust \enquote{Raw-Pointer} genannt und \rustcinline{*mut c_long} für  \rustcinline{&mut c_long} bzw. \rustcinline{*const c_long} für \rustcinline{&c_long} geschrieben.
	
	Ein C-Pointer \ccinline{*long} wird in Rust \enquote{Raw-Pointer} genannt und entweder \rustcinline{*mut c_long} oder \rustcinline{*const c_long} geschrieben. Der Unterschied ist wie zwischen \rustcinline{&mut c_long} und \rustcinline{&c_long} und dient dem Rust Compiler zum Nachvollziehen, ob ein exklusiver Zugriff benötigt wird, oder nicht.
	Dies hilft zwar für die Fehlervermeidung durch eventuelle Compilefehler anstatt Laufzeitfehler, ist aber für die C-Funktion unbedeutend \cite{rust:book:raw_ptr}:
	
	\begin{figure}[H]
		\centering
		\begin{tabular}{c|c|c}
			Referenz in Rust & Raw-Pointer in Rust & C-Pointer \\
			\hline
			\rustcinline{&mut c_long}  &   \rustcinline{*mut   c_long}  &   \ccinline{long*} \\
			\rustcinline{    &c_long}  &   \rustcinline{*const c_long}  &   \ccinline{long*}
		\end{tabular}
		\caption{Vergleich Rust Raw-Pointer und Referenz zu C-Pointer}
	\end{figure}
	
\end{itemize}

\subsubsection{Externer Funktionsaufruf}
\label{rust:ffi:functioncall}

Externe Funktionen müssen im Gegensatz zu externen Strukturen immer in einem \rustcinline{extern \{\}} Block deklariert sein.

\begin{figure}[H]
	\rustcinclude
		{rust:ffi:uper_encode_to_buffer}
		{Externe Funktionsdefinition der ASN.1 Funktion zum Enkodieren}
		{sections/rust.uper_encode_to_buffer.rs}
\end{figure}

Wie in \autoref{rust:ffi:uper_encode_to_buffer} zu sehen ist, können auch \rustcinline{extern \{\}} Blöcke mit Anmerkungen (sieh \autoref{rust:annotations}) versehen werden. Zwingend ist bei der Verwendung einer \rustcinline{#[link(..)]} Anmerkung der Name der Bibliothek, auf die sich der im \rustcinline{extern \{\}} Block stehende Code bezieht. Optional kann auch wie in \autoref{rust:ffi:uper_encode_to_buffer} die Art der Verlinkung (dynamisch oder statisch) angegeben werden.

Die Art der Definition einer externen Funktion unterscheidet sich nicht von einer normalen Funktionsdefinition. Es sollten aber, wie in \autoref{rust:ffi:datatypes} beschrieben, zu C bzw. der externen Sprache kompatiblen Datentypen verwendet werden.
 
\newpage

%\section{Kernfeatures}

%\todo{nothing on heap unless specified (Box, Vec, other container)}
%\todo{closures are fast, orly, p.310}

%https://www.youtube.com/watch?v=d1uraoHM8Gg \\
%\todo{no need for a runtime, all static analytics} \\
%\todo{memory safety} \\
%\todo{data-race freedom} \\
%\todo{active community} \\
%\todo{concurrency: no undefined behavior} \\
%\todo{ffi binding} \gls{ffi} \\
%\todo{zero cost abstraction} \\
%\todo{package manager: cargo} \\

%https://www.youtube.com/watch?v=-Tj8Q12DaEQ \\
%\todo{static type system with local type inference } \\
%\todo{explicit notion of mutability } \\
%\todo{zero-cost abstraction *(do not introduce new cost through implementation of abstraction)} \\
%\todo{errors are values not exceptions}
%\todo{no null} \\
%\todo{"static automatic memory management" - no garbage collection } \\
%\todo{often compared to GO and D (~44min)} \\


%\section{Schwächen}
%https://www.youtube.com/watch?v=-Tj8Q12DaEQ \\
%\todo{compile-times} \\
%\todo{Rust is a vampire language, it does not reflect at all!} \\
%\todo{depending on the field -> majority of libraries?} \\


%\section{Performance Fallstricke}
%\todo{\cite{rust:performance_pitfalls}}

\section{Beispiele der Verwendung von Rust}
\todo{relevant?}

Der womöglich bekannteste Einsatzzweck von Rust ist im Webbrowser Firefox.
Mehrere Versuche die Layoutberechnung in C++ zu parallelisieren sind aufgrund schwer auffindbaren Fehlern abgebrochen worden \cite{rust:example:firefox}.
Eine Parallelisierung im aktuellen Projekt \enquote{Quantum} in Rust is dagegen mit ersten Erfolgen gekrönt \cite{rust:example:firefox_heise}

Dropbox erreicht bereits \enquote{Hunderten Millionen von Geräten} mit Rust und das GNOME Projekt ermöglicht die Integration von Rust Code \cite{rust:example:two_years}.
%https://www.youtube.com/watch?v=-Tj8Q12DaEQ \\
%\todo{GTK binding heavily to rust} \\
