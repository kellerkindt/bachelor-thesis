
			
\chapter{Auswertung}

In diesem Kapitel wird die Implementation des MEC-View-Servers in Rust mit der Referenzimplementation in C++ verglichen.
Hierzu wird die Textumgebung aus dem C++ Projekt auch auf die Rust Implementation angewandt: Fahrzeuge und Sensoren werden simuliert.

test für durchsatz nur bedingt aussagekräftig

gleicher dummy alg

\todo{Während den tests zeigte sich ein Fehler im C++ Server. Race-conditional missing cleanup for closed sockets in certain error cases?}

\section{Testumgebung}

Alle Tests wurden auf dem selben Ubuntu 16.04.4 LTS Server mit zwei Intel Xeon CPUs (E5-2620 v4 @ 2.10GHz) ausgeführt.
Der CPU Gvernor wurde für alle Tests auf \enquote{performance} gestellt, um Schwankungen in der CPU Taktung durch Energiesparmaßnahmen und damit Verfälschungen der Testergebnisse zu unterbinden.

Für jede Kombination aus Sensoren, Fahrzeugen und Serverimplementierung wurde 10 Tests durchgeführt.
Während jedem Test ist für jede Empfangene Nachricht am Fahrzeug, die Latenz seit Versand am Sensor in eine Datei geschrieben worden.
Nach einem Testdurchlauf wurden die Anzahl an Nachrichten gezählt und der Durchschnitt und Boxplots für die Latenzen gebildet.

Zu jedem Zeitpunkt ist maximal ein Test gleichzeitig auf dem System ausgeführt worden.

Um Latenzen durch das Netzwerk auszuschließen, wurden auch die virtuellen Sensoren und Fahrzeuge auf dem gleichen Server wie die Serverimplementation ausgeführt und durch die Loopback-Netzwerkschnittstelle mit der Serverimplementation verbunden.
Ein kurzer Test ergab hierbei einen Durchsatz von ca 40Gbit/s (mittels \textit{iperf}) und eine Latenz von ca 24us (mittels \textit{ping}) auf der Loopback-Netzwerkschnittstelle.
Auswirkungen auf die Testergebnisse sind damit vernachlässigbar klein.

Beide Implementationen sind im Release-Modus und ohne \enquote{RoadClearanceModule} compiliert worden.

\todo{no RCM}

\todo{release mode}

\section{Vorgehen}

Das Vorgehen war für alle Tests gleich und wurde bis auf den Start des Servers durch ein Skript ausgeführt.
Variiert wurden lediglich die Anzahl an Fahrzeugen und Sensoren, die als Übergabeparameter an das Skript übergeben werden.
Das Vorgehen eines Testdurchlaufs sieht folgendermaßen aus:

\begin{itemize}
	\item Server mit Log-Level \enquote{info} starten, falls noch nicht gestartet
	\item Sensoren starten
	\item Eine kurze Pause (2 Sekunden) machen, um genügend Zeit für den Verbindungsaufbau der Sensoren zu geben
	\item Fahrzeugen starten. 5 Sekunden nach dem Verbindungsaufbau abonnieren diese das Umgebungsmodell für 60 Sekunden.
	\item Auf ende aller Fahrzeuge warten.
	\item Alle Sensoren beenden
	\item Kurze Pause (2 Sekunden) vor erneutem Test-Durchlauf einräumen
\end{itemize}

Für jedes Umgebungsmodell, das von einem Fahrzeug empfangen wird, wird auf der Konsole die Latenz in ganzen Millisekunden ausgegeben.

Die Latenz errechnet der C++ Clientsimulator, indem beim Versenden eines \textit{SensorFrame}s durch den simulierten Sensor die aktuelle Zeit in der Nachricht hinterlegt wird.
Der Dummy-Algorithmus überträgt diesen \todo{Timestamp} in das \textit{EnvironmentFrame} und versendet dieses an die Fahrzeuge.
Die simulierten Fahrzeuge errechnen die Differenz zwischen der aktuellen Zeit und dem \todo{timestamp}
 und geben diesen auf der Konsole aus.
 
Alle ausgegebenen Latenzen werden mittels \textit{bash}-Pipe in eine Datei übertragen.
Bei der Auswertung wird der Durchschnitt errechnet.

\section{Ergebnisse}

\newcommand{\makeDias}[3]{
	\begin{figure}[H]
		\centering
		\begin{subfigure}{.75\textwidth}
			\centering
			\begin{tikzpicture}
			\begin{axis}[
				ymin=0, ymax=#2,
				xmin=0, xmax=#3,
				width=\textwidth, height=20em,
				xlabel={Anzahl der Nachrichten},
				ylabel={Durchschnittliche Latenz in ms},
				boxplot/draw direction=y,
			]
			
			\addplot gnuplot [raw gnuplot,id=rust#1,mark=none,very thick,color=brown!30]{
				set xrange [0:#3];
				f(x)=a*x+b;
				fit f(x) "data/rust_times_for_#1.dat" via a,b;
				plot f(x)};
			\addplot plot
			[only marks,mark=o,thick,color=brown] 
			file {data/rust_times_for_#1.dat};
			
			\addplot gnuplot [raw gnuplot,id=cpp#1,mark=none,very thick,color=blue!30]{
				set xrange [0:#3];
				f(x)=a*x+b;
				fit f(x) "data/cpp_times_for_#1.dat" via a,b;
				plot f(x)};
			\addplot plot
			[only marks,mark=x,thick,color=blue] 
			file {data/cpp_times_for_#1.dat};
			
			
			\end{axis}
			\end{tikzpicture}
			\caption{Latenz-Nachrichtenanzahl Diagramm}
			\label{#1} 
		\end{subfigure}%
		\begin{subfigure}{.25\textwidth}
			\centering
			\begin{tikzpicture}
			\begin{axis}[
			ymin=0, ymax=#2,
			boxplot/draw direction=y,
			xtick={1,2},
			xticklabels={Rust,C++},
			width=\textwidth,
			height=20em
			]
			\addplot+[
			boxplot={average=auto},color=brown!80
			] table {data/rust_times_for_#1.dat}
			\printboxplotdata;
			
			\addplot+[
			boxplot={average=auto},color=blue!80
			] table {data/cpp_times_for_#1.dat}
			\printboxplotdata;
			
			\end{axis}
			\end{tikzpicture}
			\caption{Boxplot für\\die Latenz}
			\label{#1_boxplot}
		\end{subfigure}
	\end{figure}
}

\makeDias{60s}{10.5}{90000}
%\makeDias{2x25_60s}{4.1}{120000}
%\makeDias{3x25_60s}{6.5}{300000}
%\makeDias{4x25_60s}{7.0}{400000}
%\makeDias{5x25_60s}{12.0}{900000}

	
\todo{rust graphs}
