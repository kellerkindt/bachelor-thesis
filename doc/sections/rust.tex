
\chapter{Die Programmiersprache Rust}

%Rust ist eine Programmiersprache, die versucht performante -- und daher durch Abstraktionen mit keinem zusätzlichen \enquote{Kosten} \todo{ref zero cost abstractions} -- und sichere Programmierung zu ermöglichen.
Rust hat als Ziel, eine sichere (siehe \autoref{rust:guarantees}) und performante Systemprogrammiersprache zu sein, die ohne eine Laufzeit ausgeführt werden kann.
Abstraktionen sollen die Sicherheit, Lesbarkeit und Nutzbarkeit verbessern aber keine unnötigen Performanceeinbußen verursachen (siehe \autoref{rust:zero_cost}).

\todo{rust performance very wow, much parallel, great safety}

\todo{wo anders? make more text, make better text}
Bei Rust geht es in vielerlei Hinsicht darum, bekannte Fehlerquellen aus anderen Programmiersprachen zu unterbinden, aber gleichzeitig eine mindestens genau so gute Performance zu erreichen.

Aus anderen Programmiersprachen bekannte Fehlerquellen -- wie \enquote{dangling pointers}, \enquote{double free} oder \enquote{memory leaks} --  werden durch strikte Regeln und mit Hilfe des Compilers verhindert (\autoref{rust:guarantees}).
Im Gegensatz zu Programmiersprachen, die dies mit Hilfe ihrer Laufzeitumgebung\footnote{u.a. Java Virtual Maschine (JVM), Common Language Runtime (CLR)} sicherstellen, werden diese Regeln in Rust durch eine statische Lebenszeitanalyse (\autoref{rust:static_analysis}) und mit dem Eigentümerprinzip (\autoref{rust:ownership}) bei der Compilation überprüft und erzwungen.

Rust hat in den letzten Jahren viel an Beliebtheit gewonnen und scheint dem Anspruch eine sichere und performante Programmiersprache zu sein, gerecht zu werden:

\begin{quotation}
	\textit{\enquote{[..]Leute, die [..] sichere Programmierung haben wollen, [..] können das bei Rust haben, ohne [..] undeterministischen Laufzeiten oder Abstraktionskosten schlucken zu müssen. }}
	\cite[Felix von Leitner in einem Blogeintrag]{rust:fefe}
\end{quotation}

\begin{quotation}
	\textit{\enquote{[..] Rust makes it safe, and  provides nice tools}} 
	\cite[Folie 130, Federico Mena-Quintero in \enquote{Ersetzen von C Bibliotheken durch Rust}]{rust:c_is_hostile_mena}
\end{quotation}

\begin{quotation}
	\textit{\enquote{Rust hilft beim Fehlervermeiden}} 
	\cite[Federico Mena-Quintero in einem Interview]{rust:c_is_hostile_golem}
\end{quotation}

\begin{quotation}
	\textit{\enquote{Rust is [..] a language that cares about very tight control}}
	\cite[Diskussion zwischen Programmierern auf Reddit]{rust:tight_control}
\end{quotation}


\clearpage
\section{Geschichte}
\label{rust:history}

In 2006 begann Graydon Hoare die Programmiersprache Rust in seiner Freizeit als Hobbyprojekt zu entwickeln \cite{rust:faq}.
Als Grund nannte er seine Unzufriedenheit mit der Programmiersprache C++, in der es sehr schwierig sei, fehlerfreien, speichersicheren und nebenläufigen Programmcode zu entwickeln.
Zudem beschrieb er C++ als \enquote{ziemlich fehlerträchtig} \cite{rust:heise_interview_graydon}.

Auch Federico Mena-Quintero -- Mitbegründer des GNOME-Projekts \cite{rust:gnome:federico}  --
äußerte in einem Interview mit Golem im Juli 2017 seine Bedenken an der Verwendung der \enquote{feindseligen} Sprache C \cite{rust:c_is_hostile_golem}.
In Vorträgen \todo{nix mehrzahl?} vermittelt er seither, wie Bibliotheken durch Implementationen in Rust ersetzt werden können \cite{rust:c_is_hostile_mena}.

Ab 2009 begann Mozilla die Weiterentwicklung finanziell zu fördern, als einfache Tests und die Kernprinzipien demonstriert werden konnten.
Die Entwicklung der Programmiersprache, des Compilers, Buchs, von Cargo, crates.io und weitere Bestandteile findet öffentlich einsehbar auf \gls{github}  unter \url{https://github.com/rust-lang} statt und wird nicht ausschließlich von Mozilla Angestellten koordiniert.
Dadurch kann sich jeder an Diskussionen oder Implementation beteiligen, seine Bedenken äußern oder Verbesserungen vorschlagen.

Durch automatisierte Tests \todo{ref} in Kombination mit drei Veröffentlichungskanälen (\enquote{relese}, \enquote{stable} und \enquote{nightly}) und \todo{feature gates} wird die Stabilität des Compilers und die der Standardbibliothek (\autoref{rust:stdlib}) gewährleistet.

Rust ist wahlweise unter MIT oder der Apache Lizenz in Version 2 lizenziert.

\section{Anwendungsgebiet}

Das Ziel von Rust ist es, das Designen und Implementieren von sicheren, nebenläufig und auch praktisch tauglichen Systemen möglich zu machen \cite{rust:faq}.
\todo{intro paragraph}

Da Rust den \gls{llvm}-Compiler nutzt, erbt Rust auch eine große Anzahl der Zielplattformen die \gls{llvm} unterstützt.
Die Zielplattformen sind in drei Stufen unterteilt, bei denen verschieden stark ausgeprägte Garantien vergeben sind. Es wird zwischen
\begin{itemize}
	\item \enquote{Stufe 1: Funktioniert garantiert} (u.a. X86, X86-64),
	\item \enquote{Stufe 2: Compiliert garantiert} (u.a. ARM, PowerPC, PowerPC-64) und
	\item \enquote{Stufe 3} (u. a. Thumb (Cortex-Microcontroller))
\end{itemize}
unterschieden \cite{rust:platform_support}.
Diese Unterscheidung wirkt sich auch auf die Stabilisierungsphase und Implementation neuer Funktionen aus (Beispiel \enquote{128-bit Integer Support} \cite{rust:github:128bit_integer}).

\section{Aufbau eines Projektverzeichnisses}

Der Aufbau eines Rust Projektverzeichnis kann zwischen zwei verschiedenen Arten differenziert werden.
Zum einen gibt es den klassische Aufbau, in dem lediglich der Programmcode liegt und der Compiler direkt aufgerufen wird.
Zum anderen wird der Aufbau als Crate empfohlen \todo{cite}, bei dem automatisch Abhängigkeiten aufgelöst aber auch Metainformationen bezüglich des Autors und der Version hinterlegt sind.
Ein klassischer Aufbau ist nur selten anzutreffen.

\subsection{Klassisch}
\label{rust:structure:classic}
\begin{wrapfigure}{l}[-1em]{.5\textwidth}
	\rustcinclude
		{rust:structure:classi}
		{Verzeichnisstruktur des Quelltext-Verzeichnisses}
		{sections/rust.classic.txt}
\end{wrapfigure}

Das Quelldatei-Verzeichnis sollte entweder eine \textit{main.rs} für Ausführbare Programme oder eine \textit{lib.rs} für Bibliotheken enthalten.
Während der Paketmanager Cargo (\autoref{rust:structure:cargo}) eine solche Benennung als Standardkonvention erwartet, kann bei manueller Nutzung des Compilers auch ein anderer Name für die Quelldatei vergeben werden.

Der Compiler startet in der Wurzeldatei und lädt weitere Module, die durch \rustcinline{mod module;} gekennzeichnet sind (ähnlich \ccinline{# include "module.h"} in C/C++).
Ein Modul kann dabei eine weitere Quelldatei oder ein ganzes Verzeichnis sein.
Ein Verzeichnis wird aber nur als gültiges Modul interpretiert, wenn sich eine \textit{mod.rs} Datei darin befindet.

Wie bereits angedeutet, wird in Rust nicht eine \enquote{Klasse}, Datenstruktur oder Aufzählung pro Datei erwartet (\todo{wie das bei Java der Fall ist}), sondern eine Quelldatei entspricht einem Modul.
Diese Umfasst in vielen fällen wenige aber mehrere Datenstrukturen, zugehörige Aufzählung und Fehlertypen.
%Module (Verzeichnisse oder Quelldateien) gesucht wird. , in der Module durch \rustcinline{mod module;} und Quelldateien durch \rustcinline{mod functionality;} \enquote{inkludiert} werden können.
%Eine Datei \textit{mod.rs} ist die Wurzeldatei eines Moduls.

\subsection{Als Crate}
\label{rust:structure:cargo}

\begin{wrapfigure}{r}{.4\textwidth}
	\rustcincludeml
		{rust:structure:cargo}
		{Vereinfachte Verzeichnisstruktur einer \enquote{crate}}
		{sections/rust.cargo.txt}
\end{wrapfigure}



Eine \enquote{Crate} (dt. Kiste/Kasten\todo{.}) erweitert den klassischen Aufbau um eine \textit{Cargo.toml} Datei, in der Metainformationen zum Projekt hinterlegt werden.
Durch die Benutzung des Werkzeugs \enquote{Cargo} (dt. Fracht/Ladung\todo{.}, entwickelt und angeboten von der Rust \todo{Gemeinschaft}) können Abhängigkeiten automatisch aufgelöst, heruntergeladen und compiliert werden.

\todo{text is shit}
Eine offizielles Verzeichnis mit über 14.000 Crates (Stand \today) ist unter \url{https://crates.io/} erreichbar.
Cargo lädt standardmäßig Abhängigkeiten von dort nach.
Jeder kann neue Bibliotheken veröffentlichen.
Für den Namen gilt dabei \enquote{first come, first serve}.

Eine Crate kann entweder ein ausführbares Programm oder eine Bibliothek sein.
Davon abhängig is die Wurzeldatei \textit{src/main.rs} (für ein ausführbares Programm) oder \textit{src/lib.rs} (für eine Bibliothek).
Mit dem erzeuge einer Crate (\rustcinline{cargo --bin meineCrate} bzw. \rustcinline{cargo --lib meineBib}) wird auch gleichzeitig \gls{git} für das Verzeichnis initialisiert.

Es wird allgemein empfohlen, ein Projekt als Crate zu betreiben \todo{cite}.

\todo{Cargo.toml example?}

\section{Hello World}


\begin{wrapfigure}{l}{.5\textwidth}
	\rustcinclude
		{rust:hello_world}
		{\enquote{Hello World} in Rust}
		{sections/rust.hello_world.rs}
\end{wrapfigure}

Der Programmcode in \autoref{rust:hello_world} gibt auf der Konsole \monospaceinline{Hello World} aus.
Das \rustcinline{fn} die Funktion \rustcinline{main} definiert und diese der Startpunkt des Programms ist, wird wenige überraschen.
Den meisten wird vermutlich eher das Ausrufezeichen in Zeile 2 auffallen, da es auf den ersten Blick dort nicht hingehören sollte.
In Rust haben Ausrufezeichen und Fragezeichen besondere Bedeutungen, weswegen die Verwendung in Zeile 2 trotzdem richtig ist.

Die Bedeutung des Fragezeichens dient zum schnelleren Auswerten von \rustcinline{Rusult<_, _>} Werten und wird in \todo{ref} genauer erklärt.
Das Ausrufezeichen kennzeichnet, dass der ansonsten augenscheinliche Funktionsaufruf tatsächlich ein Aufruf einer Makrofunktion ist.

Eine Funktion \rustcinline{println} gibt es nicht, auch keine aus C erwarteten Funktionen wie \ccinline{printf}, \ccinline{fputs}, \ccinline{sprintf}.
Eine Ausgabe erfolgt durch das \rustcinline{println!} Makro, welches die Makros \rustcinline{format!} \todo{ref} und \rustcinline{writeln!} Kombiniert und das \rustcinline{Write}-Traits \todo{ref}, welches von der Standardausgabe implementiert wird, nutzt \todo{verify, cite?}.

\todo{hmmmm}
Ein kleines Beispiel, viele versteckte Mechaniken zur Laufzeitoptimierung aber trotzdem handlich und leserlich -- Rust.

\subsection{Einfache Datentypen}

Die in der \rustcinline{core} Crate (\autoref{rust:core}) zur Verfügung gestellten Datentypen sind im wesentlichen die üblichen  Verdächtigen: \rustcinline{bool} für boolische Ausdrücke; \rustcinline{char} für ein einzelnes Unicode Zeichen; \rustcinline{str} für eine Zeichenkette; \rustcinline{u8}, \rustcinline{i8}, \rustcinline{u16}, \rustcinline{i16}, \rustcinline{u32}, \rustcinline{i32}, \rustcinline{u64}, \rustcinline{i64}, (bald \rustcinline{u128}, \rustcinline{i128} \cite{rust:github:128bit_integer:rfc}) und \rustcinline{usize}, \rustcinline{isize}  für ganzzahlige Werte; \rustcinline{f32}, \rustcinline{f64} für Fließkommazahlen in einfacher und zweifacher Präzision; Arrays und Slices \cite{rust:book:primitives}.

Ganzzahlige primitive Datentypen mit \rustcinline{u} beginnend sind vorzeichenlos (\enquote{unsigned}) und mit \rustcinline{i} beginnend sind vorzeichenbehaftet (\enquote{signed}), gefolgt mit der Anzahl der Bits  die der Datentyp groß ist.
\todo{shit sentence} Die einzige Ausnahme bildet der Datentyp \rustcinline{usize} bzw \rustcinline{isize}, da dieser immer so groß ist, wie die Architektur der Zielplattform (X86 -> 32 Bit, X86\_64 -> 64 Bit).
Ein Anwendungsfall von \rustcinline{usize} ist dabei die Indexierung eines Arrays oder einer Slice (\todo{siehe nächster paragraph?}), da der Index hierfür niemals negativ und niemals größer sein kann, wie die Architektur der Zielplattform darstellen kann \todo{erwähnen?: größer könnte man garnicht addressieren}.

Durch dieses Schema bei der Bezeichnung der Datentypen wird eine Verwirrung wie zum Beispiel in C unterbunden, wo die primitiven Datentypen (\ccinline{short}, \ccinline{int}, \ccinline{long}, ..) keine definierte Größe haben, sondern dies abhängig vom eingesetzten Compiler und der Zielplattform ist \cite[187]{deitel2013c}. Erst ab C99 wurden zusätzliche, aber optionale, ganzzahlige Datentypen mit bestimmter Größe definiert \cite[141]{goll2014c}.

Konstanten können eindeutig einem Datentyp zugewiesen werden, indem dieser angehängt wird.
\rustcinline{4711u16} ist somit vom Datentyp \rustcinline{u16}.
Des weiteren dürfen Ziffern durch beliebiges setzen von \rustcinline{_} getrennt werden, um die Lesbarkeit zu erhöhen: \rustcinline{1_000_000_f32}.
Eine Schreibweise in Binär (\rustcinline{0b0000_1000_u8}), in Hexadezimal (\rustcinline{0xFF_08_u16}) oder Oktal (\rustcinline{0o64_u8}) ist auch möglich. 
Konstante Zeichen und Zeichenketten können auch als Bytes (\rustcinline{b'b'} entspricht \rustcinline{u8} und \rustcinline{b"abc"} entsricht \rustcinline{&[u8]}) \todo{hinterlegt} werden.

Arrays haben immer eine zur Compilezeit bekannte Größe und Initialisierungswert (siehe \autoref{rust:no_unitialized_usage}).
Dynamische Arrays gibt es nicht, da diese zu oft Fehlerquellen seien \todo{cite!} (Abhilfe: \rustcinline{Vec<_>}, siehe \autoref{rust:std}).
Die Notation ist \rustcinline{[<Füllwert>; <Größe>]}.
\rustcinline{[0_u8; 128]} steht also für ein 128 Byte langes Byte Array, das mit 0-en vom Datentyp \rustcinline{u8} gefüllt ist.

\enquote{Slices} (dt. Scheibe/Stück) bezeichnet Rust Referenzen auf Arrays, die auch nur Teilbereiche umfassen können.
Die Größe einer Slice wird dabei mit der Referenz auf den Startwert gespeichert \todo{explain Fat-Pointer?} und bei Funktionsaufrufen übergeben.
Ein zusätzlicher Parameter für die Größe eines Buffers, wie in C üblich, ist somit unnötig.
Die Notation ähnelt die eines Arrays, aber ohne Größenspezifikation: \rustcinline{[<Datentyp>]}.
Eine Slice kann von einem Array oder einer anderen Slice erzeugt werden, dabei wird der Start- und Endindex des Teilbereiches angegeben.
Falls kein Start- oder Endindex angegeben wurde, wird das jeweilige Limit übernommen (0, max) \todo{shit text}: \rustcinline{let slice : &[u8] = &array[..8];}

\subsection{Zusammengesetzen Datentypen}

Die Programmiersprache Rust kennt neben den primitiven \todo{skalaren} Datentypen (\autoref{rust:core}) weitere Möglichkeiten Daten zu organisieren:
\begin{itemize}
	\item ein Tupel, das mehrere Werte namenlos zusammenfasst: \rustcinline{(f32, u8)},
	\item eine Datenstruktur, die wie in C Datentypen namenbehaftet zusammenfasst: \linebreak\rustcinline{struct Punkt \{ x: f32, y: f32 \} }
	\item eine Aufzählung: \rustcinline{enum Bildschirm \{ Tv, Monitor \}}. \todo{think better!}
\end{itemize}

Im Vergleich zu C kann ein Eintrag in einem \rustcinline{enum} gleichzeitig Daten wie eine Datenstruktur oder ein Tupel halten, oder lediglich einen Ganzzahlwert repräsentieren.
Mit dem \rustcinline{type} Schlüsselwort können Aliase erstellt oder im Falle von FFI (siehe \autoref{rust:ffi}) aufgelöst werden: \rustcinline{type Vektor = (f32, f32);}
 
Neue Datentypen einer Struktur oder Aufzählung können mit \rustcinline{pub} oder \rustcinline{pub(crate)} gekennzeichnet werden (siehe \autoref{rust:access_modifier}).

\todo{pub pub(crate)}

\todo{seit neuestem union, mention?}

\subsection{Funktionen, Ausdrücke und Statements}

Funktionen werden durch \rustcinline{fn} gekennzeichnet, gefolgt mit dem Funktionsnamen, der Parameterliste und zuletzt der Datentyp für den Rückgabewert.
Die Parameterliste unterscheidet sich von bekannten Programmiersprachen wie C und Java, indem zuerst der Variablenname und darauf folgend der Datentyp notiert wird.

\rustcinclude
	{rust:fn:add}
	{Beispiel einer Funktion}
	{sections/rust.fn.add.rs}
	
Obwohl in Zeile 2 von \autoref{rust:fn:add} kein \rustcinline{return} zu sehen ist, wird trotzdem das Ergebnis der Addition zurückgegeben.
Dies liegt daran, da in Rust vieles ein Ausdruck ist und somit einen Rückgabewerte liefert \cite{rust:book:statements}.
Auch ein if-else ist ein Ausdruck und kann einen Rückgabewert haben.
Ein bedingter Operator (?:) is somit unnötig, da stattdessen ein if-else verwendet werden kann: \rustcinline{let a = if b \{ c \} else \{ d \};}. 
Auch eine Zeile mit einen Semikolon hat einen Rückgabewert: \rustcinline{()}. \todo{explain () void}

\subsection{Implementierung einer Datenstruktur}

Zu einer Datenstruktur oder Aufzählung kann ein individuelles Verhalten implementiert werden.
In dieser Kombination ähneln diese Konstrukte sehr einer Klasse aus bekannten objektorientierten Programmiersprachen, wie zum Beispiel Java oder C++. \todo{ref rust OOP}

Einen Konstruktor gibt es jedoch nicht, lediglich die Konvention, eine statische Funktion \rustcinline{new} stattdessen zu verwenden \cite{rust:book:constructors}:

\rustcinclude
	{rust:struct:impl}
	{Punkt Datenstruktur mit einem \enquote{Konstruktor}}
	{sections/rust.struct.impl.rs}
	
In seltenen Fällen wird auch \rustcinline{Default} implementiert (siehe \autoref{rust:trait:default}), wodurch eine statische Funktion \rustcinline{default()} als Konstruktor ohne Parameter bereitgestellt wird.

Da eine Funktionsüberladung nicht möglich ist, soll bei weiteren Konstruktoren ein sprechender Name verwendet werden.
Der \rustcinline{Vec<_>} der Standardbibliothek (siehe \autoref{rust:std}) bietet zum Beispiel zusätzlich \rustcinline{Vec::with_capacity(capacity: usize)} an, um einen Vektor mit einer bestimmten Größe zu initialisieren.

Für Funktionen können auch die Zugriffsmodifikatoren festgelegt werden (siehe \autoref{rust:access_modifier}). 
\todo{pub pub(crate)}

\subsection{Generalisierung durch Traits}
\label{rust:trait:default}

Ähnlich wie Java oder C\# bietet Rust durch einen eigenen Typ die Möglichkeit, ein gewünschtes Erscheinungsbild zu generalisieren, ohne gleichzeitig eine Implementation vorzugeben.
Im Gegensatz zu Java wird dieser Typ in Rust \enquote{Trait} (dt. Merkmal) genannt.

Für Merkmale werden Funktionen in einem entsprechenden \rustcinline{trait <Name> \{ \}}-Block ohne Rumpf deklariert.
Optional kann auch ein Standardrumpf implementiert werden, der bei einer Spezialisierung überschrieben werden darf.

Merkmale unterscheiden sich in ihrer Handhabung gegenüber anderen Datentypen, da sie oft keine bekannte Größe zur Compilezeit haben.
Während dies in Programmiersprachen wie Java und C\# automatisch abstrahiert wird (\todo{virtuelle methoden, vergleich c++}), wird dies in Rust aus Performancegründen nicht getan.
Stattdessen muss der Programmierer entscheiden, welche Handhabung am besten ist.
\todo{dabei dabei dabei dabei dabei dabei} Dabei gibt es mehrere Möglichkeiten:
\begin{itemize}
	\item Leihen mittels Referenz: \rustcinline{fn foo(bar: \&Bar)} oder \rustcinline{fn foo(bar: \&mut Bar)} -- ein Unterschied zu anderen Datentypen ist nicht zu erkennen.
	\item Eigentümerschaft eines unbekannten aber Merkmal implementierenden Datentyps auf dem Heap übertragen: \rustcinline{fn foo(bar: Box<Bar>)} (auch \enquote{Trait-Object} genannt)
	\item Als \todo{spezialisierte} Funktion: \rustcinline{fn foo<T: Bar>(bar: T)} (auch für Felder in Aufzählungen oder Datenstrukturen möglich)
\end{itemize}

Eine Deklaration \rustcinline{fn foo(bar: Bar)} für das Merkmal \monospaceinline{Bar} ist nicht möglich, da zur Compilezeit eine eindeutige Größe nicht bekannt ist, weshalb der zu reservierende Speicher für die Variable nicht bestimmt werden kann.
Verschiedene Implementationen sind zudem meist unterschiedlich groß.

Eine spezialisierte Funktion verhält sich ähnlich wie eine \todo{Templateklasse} in C++: der Compiler erzeugt für jeden Spezialisierung eine Kopie der Funktion und setzt den Typ ein.
Dies ermöglicht zudem Optimierungen für der Funktion für den eingesetzten Typ \todo{cite?}, vergrößert aber das Compilat.

Im folgenden werden oft anzutreffende und wichtige Merkmale aus der Standardbibliothek kurz erläutert:
\begin{itemize}
	\item \monospaceinline{Send}: Markiert einen Datentyp als zwischen Threads übertragbar. Automatisch für alle Datentypen bei denen auch alle beinhalteten Datentypen von Typ Send sind \todo{rly? cite?}. Manuelle Implementation ist \todo{unsafe}.
	\item \monospaceinline{Sync}: Markiert einen Datentype als Thread sicher, d.h. mehrere Threads dürfen gleichzeitig darauf zugreifen. \todo{automatisch? manuell?} Verlangt, dass alle beinhalteten Datentypen auch \monospaceinline{Sync} sind.
	\item \monospaceinline{Copy}: Markiert einen Datentyp, der durch einfaches Speicherkopieren \todo{memcpy} vervielfacht werden kann (\todo{bsp skalare datentypen}). Verlangt, dass alle beinhalteten Datentypen auch \monospaceinline{Copy} sind
	\item \monospaceinline{Clone}: Markiert einen Datentyp der vervielfacht werden kann, dabei jedoch Laufzeitkosten verursacht. Stelle eine Funktion zum clonen bereit, die explizit aufgerufen werden muss (zbsp Zähler inkrementieren). Verlangt, dass alle beinhalteten Datentypen auch \monospaceinline{Clone} sind.
	\item \monospaceinline{Sized}: Verlangt eine zu Compilezeit bekannte Größe. \monospaceinline{!Sized} erlaubt dagegen eine unbekannte Größe zur Compilezeit.
	\item \monospaceinline{Debug} und \monospaceinline{Display}: Verlangt die Implementation von Funktionen um als Text dargestellt zu werden, entweder mit mehr Zusatzinformationen (\monospaceinline{Debug}) oder \todo{schön} (\monospaceinline{Display}). Verlangt, \todo{..}
	\item \monospaceinline{Deafult}: Verlangt die Implementation einer statische Methode \monospaceinline{default()}, die wie ein leerer Standardkonstruktor von Java oder C\# wirkt.
	\item \monospaceinline{PartialEq} und \monospaceinline{PartialOrd}: Verlangt die Implementation einer Funktion um mit Objekten gleichen Typs verglichen demwerden zu können. Im Vergleich zu \monospaceinline{Eq} und \monospaceinline{Ord} erlauben \monospaceinline{PartialEq} und \monospaceinline{PartialOrd} den Rückgabewert \enquote{nicht vergleichbar} -- der bei  vergleichen zwischen zwei \rustcinline{Nan}-Werten wichtig ist \todo{cite ISO hierfür}. Verlangt, dass alle beinhalteten Datentypen auch \monospaceinline{PartialEq} bzw. \monospaceinline{PartialOrd} sind.
	\item \monospaceinline{Drop}: Stellt eine Funktion bereit, die kurz vor der Speicherfreigabe einers Objekts aufgerufen wird (ähnlich Destruktor aus C++).
\end{itemize}

Mit dem Attribute \rustcinline{#[derive(..)]} ist eine automatisierte Implementation genannter Merkmale oft möglich, insofern die jeweiligen Bedingungen erfüllt sind.
So kann im allgemeinen \rustcinline{#[derive(Clone)]} genutzt werden um eine Datenstruktur oder eine Aufzählung klonbar zu machen oder \rustcinline{#[derive(Debug)]} um automatisch alle Felder in Text wandeln zu können, ohne manuell Code schreiben zu müssen.
Dadurch wird der menschliche Faktor als Fehlerquelle für oft genutzte aber im Prinzip einfache Mechanismen ausgeschlossen.

Ähnlich wie in C++ <T: Blubber>

\todo{Drop, Sized, Sync, Send, Copy, Clone, Debug, Display, Default, PartialEq, PartialOrd}

\todo{Derive}: \enquote{Default}-Implementation

\todo{<T: Blubber> vs Box<T> (Speicherorganisation, performance)}

\todo{you idiot forgot an subsub-idea}

\subsection{Zugriffsmodifikatoren}
\label{rust:access_modifier}

Zugriffsmodifikatoren erlauben es in Rust, Module, \todo{Re-exporte / use}, Datenstrukturen, Aufzählungen, Merkmale und Funktionen gegenüber Nutzern einer Crate und anderen Modulen sichtbar zu machen.
Der Standardmodifikator limitiert die Sichtbarkeit auf das Modul, in dem die Deklaration stattgefunden hat und wird durch keine Nennung eines Zugriffsmodifikators erreicht.
Um die Sichtbarkeit auf die gesamte Crate zu erhöhen, wird ein \rustcinline{pub(crate)} vorangestellt.
Mit \rustcinline{pub} ist die Deklaration für alle sichtbar.


\subsection{Ausdruck/Expression vs Statement}



\subsection{Musterabgleich}
\label{rust:match}

Der \rustcinline{match} Ausdruck ist ein sehr mächtiges Werkzeug in Rust und entspricht einem stark erweiterten \ccinline{switch} aus Programmiersprachen wie C, Java oder C\#.
Mit ihm ist es möglich einen Wert eine Aufzählung aufzulösen und auf eventuell beinhaltete Werte zuzugreifen oder zu konsumieren.

\rustcinclude
	{rust:match:large}
	{Kompletter \rustcinline{match} Ausdruck}
	{sections/rust.match.large.rs}

In Zeile 3 von \autoref{rust:match:large} wird \rustcinline{value} aufgelöst.
In dem Beispiel ist \rustcinline{value} aus Zeile 2 und 3 \rustcinline{Some("text")}, weswegen Zeile 4 ausgeführt wird, \rustcinline{value} konsumiert wird und \monospaceinline{Wert ist: text} auf der Konsole erscheint.

Wenn nur ein konkreter Fall von Bedeutung ist, kann dies in der verkürzten Schreibweise \rustcinline{if let} notiert werden:

\rustcinclude
	{rust:match:iflet}
	{Vereinfachte \rustcinline{if let} Ausdruck}
	{sections/rust.match.iflet.rs}

Ein weiterer Unterschied von \autoref{rust:match:iflet} gegenüber \autoref{rust:match:large} ist in Zeile 3 das Schlüsselwort \rustcinline{ref}, wodurch der Konsum des Wertes verhindert wird.
Das Schlüsselwort \rustcinline{mut} erlaubt zudem eine Änderung des Wertes, weswegen \rustcinline{value} in Zeile 4 vom Typ \rustcinline{&mut u32} ist und die Dereferenzierung mit Addition ermöglicht.

Als Wildcard für sowohl nicht benötigte Werte, als auch alle weiteren Fälle kann \rustcinline{_} verwendet werden: \rustcinline{if let Some(_) = value \{ println!("It's something!"); \} }

Weitere Möglichkeiten Muster zu erkennen sind ab Seite 221 in \cite{rust:orly_programming} in detaillierter Ausführung zu finden.
Dazu gehören unter anderem die \enquote{guard expression}, \enquote{bindings} und \enquote{ranges}.

\subsection{Namens- und Formatierkonvention / Styleguide}

\cite{rust:styleguide}

\subsection{Formatierung}
\rustcinline{format!} all se things

\todo{formatierung}

\todo{let, optionaler datentyp, macros, generics, () statt void}

\todo{official format/naming convetion, use, function, macro}

\todo{Variables, Structs, Enums, Traits}

\todo{type safety langauge}

\todo{Rust -> MIR -> assembler} \\

\todo{MIR/assemblerbeispiele?} \\
\cite{rust:orly_programming}

\todo{pattern matching}

\subsection{Niemals nichts und niemals unbehandelte Ausnahmen}
\label{rust:no_null}

Rust kennt \ccinline{null}(-Pointer) nicht, bietet aber in \rustcinline{core} (\autoref{rust:core}) \rustcinline{Option<_>} als Ersatz an.
Dieser Datentyp erzwingt eine Prüfung vor dem Zugriff auf den optionalen Wert.

\todo{IMMER INITIALISIERT, sonst kein zugriff erlaubt}

Für die Fehlerbehandlung wird nicht auf ein Exception-Handling zurückgegriffen, sondern ein eigener Datentyp angeboten, der entweder den Rückgabewert enthält, oder aber einen Fehler: \rustcinline{Result<_, _>} (siehe \autoref{rust:result}).

Durch den \todo{Fragenzeichenoperator} kann trotzdem ein ähnliches Verhalten wie beim auftreten einer Ausnahme in Java oder C++ erzielt werden. \todo{example?}

\todo{ref if let Ok(\_)} 

\subsection{Besorgter Compiler}
\todo{many warnings}


\section{Standardbibliothek}
\label{rust:stdlib}

Die Rust Community ist darum bemüht, die Standardbibliothek sehr leichtgewichtig zu halten.
Nicht eindeutig als fundamental eingestufte Funktionalität wird lieber als Crate auf \textins{crates.io} angeboten anstatt die Standardbibliothek übernommen zu werden \todo{prove via ref}. 
Sie wird selbst als eine Crate (siehe \autoref{rust:structure:cargo}) zur Verfügung gestellt, auf die standardmäßige eine Abhängigkeit besteht.
Für die Verwendung von Rust im Embedded Bereich, kann diese Abhängigkeit, die für Microcontroller sehr umfangreich ist, durch \rustcinline{#![no_std]} unterbunden werden.
Daraufhin sind nur noch die in der \rustcinline{core} Crate zur Verfügung gestellten Sprachkonstrukte verwendbar.

\subsection{core}
\label{rust:core}


\subsection{std}
\label{rust:std}

Die Crate \rustcinline{std} erweitert \rustcinline{core} um viele \todo{containers, collections, rc, arc, mutex, rwlock, platform abstractions: threads, tcp, udp}. \rustcinline{Vec<_>} \rustcinline{HashMap<_, _>} \rustcinline{String}  \rustcinline{Box} \todo{heap dinge}

\todo{core, datatypes, arrays slices, no null  \enquote{billion dollar mistake} }

\todo{std, Vec, str, String, no\_std für embedded}

\todo{println!, writeln! formatting}

https://www.youtube.com/watch?v=-Tj8Q12DaEQ \\
\todo{static type system with local type inference } \\



\section{Alles hat einen Rückgabewert}
\todo{() ??, Statement vs }

\section{use mod pub}


\section{Geltungsbereich / Memory Management, Lebenszeit}
\label{rust:scope}
\label{rust:static_analysis}

Rust benutzt ein \enquote{statisches, automatisches Speicher Management -- keinen Garbage Collector} \cite{rust:youtube:goto2017}.
Das bedeutet, die Lebenszeit einer Variable wird statisch während der Compilezeit anhand des Geltungsbereichs ermittelt.
Durch diese statische Analyses wird eine Variable durch eine automatisierte Anweisung, die der Compiler einfügt, freigegeben.
Dies gilt auch für Variablen auf dem Heap.
Ein Manuelles \ccinline{free(*void)} wie in C/C++ üblich entfällt.


\begin{figure}[H]
	\rustcinclude
		{rust:memory:scope}
		{Geltungsbereich von Variablen}
		{sections/rust.memory.rs}
\end{figure}

Als Alternative kann eine Variable oder Datenstruktur auch vorzeitig durch Aufruf von \rustcinline{std::mem::drop(_)} freigegeben werden.
Die optionalen Implementation von \rustcinline{std::op::Drop} \todo{trait? ref?} kommt der Implementation des Destruktors aus C++ gleich.

\enquote{static automatic memory management} - no garbage collection \cite{rust:youtube:goto2017}
\todo{"static automatic memory management" - no garbage collection } \\

\todo{while compiling, does not compile on error / unprovable code, trait Drop}

\todo{autodrop, auto file close}

\section{Eigentümer- und Verleihprinzip}
\label{rust:ownership}

Bereits 2003 beschreibt Bruce Powel Douglass im Buch \enquote{Real-Time Design Patterns}, dass \enquote{passive} Objekte ihre Arbeit nur in dem \todo{Thread-Kontext} ihres \enquote{aktiven} Eigentümers tätigen sollen \cite[204]{douglass2003real}.
In dem beschriebenen \enquote{Concurrency Pattern} wird eine klare Zuordnung getätigt, welche Objekte welchem anderen Objekt als Eigentümern zugeordnet sind, um eine sicherere Nebenläufigkeit zu schaffen \todo{shit}.

Diese Philosophie setzt Rust direkt in der Sprache um, so darf eine Variable immer nur einen Eigentümer haben. Zusätzlich zu einem immer eindeutig identifizierbaren Eigentümer für eine Variable, kann diese auch ausgeliehen werden; entweder exklusiv mit sowohl Lese- als auch Schreiberlaubnis, oder mehrfache mit nur Leseerlaubnis.

Eigentümerschaft kann auch übertragen werden, der alte Eigentümer kann danach nicht mehr auf den Wert zugreifen.

Die Garantie nur einen Eigentümer, eine exklusive Schreiberlaubnis oder mehrere Leseerlaubnisse auf eine Variable zu haben, wird durch die statische Lebenszeitanalyse garantiert (siehe \autoref{rust:scope}).

\todo{Split example, explain more}
\rustcinclude
	{rust:ownership:scope}
	{Eigentümer und Referenzen von Variablen}
	{sections/rust.ownership.rs}


\todo{missing move? orly}


\section{Rust als funktionale Programmiersprache}
\todo{functional programming -> no global state, no exceptions, find literature}
\todo{prove via code}

\section{Rust als Objekt-Orientierte Programmiersprache}
\todo{trait}
\todo{prove via design patterns, a few? from faq::  Is Rust object oriented? It is multi-paradigm. Many things you can do in OO languages you can do in Rust, but not everything, and not always using the same abstraction you’re accustomed to.}


\section{Versprechen von Rust}
\label{rust:guarantees}

\todo{(re)move? / quotation besser verpacken? in text einbinden? möglich? unnötig?}

\begin{quotation}
	\textit{\enquote{It’s not bad programmers, it’s that C is a hostile language}} 
	\cite[54]{rust:c_is_hostile_mena}
\end{quotation}

\begin{quotation}
	\textit{\enquote{I’m thinking that C is actively hostile to writing and maintaining reliable code}} 
	\cite[129]{rust:c_is_hostile_mena}
\end{quotation}



\subsection{Sichere Nebenläufigkeit}
\todo{Send, Sync, No dataraces weil Ownership \autoref{rust:ownership}, Channel, Mutex, RwLock}

\todo{Datarace benötigt immer einen schreibenden + min einen lesenden gleichzeitig}

\subsection{Keine vergessene Null-Pointer Prüfung}
\label{rust:no_null_detail}

Wie in \autoref{rust:no_null} beschrieben, kennt Rust keinen \ccinline{NULL} Pointer.
Daher ist es auch nicht möglich, durch Nachlässigkeit auf den falschen Speicher zuzugreifen.
Eine Prüfung kann entweder durch ein \rustcinline{match} (siehe \autoref{rust:match}) oder verkürzt durch ein \rustcinline{if let Some(wert) = optional \{ /* tu etwas mit wert */ \}} geschehen.

\subsection{Zero Cost Abstraction}
\label{rust:zero_cost}

Trotz der vielen verwendeten Abstraktionen möchte Rust dadurch möglichst keine weitere Laufzeitkosten erzeugen.

Der \rustcinline{Option<_>} Datentyp wir zum Beispiel tatsächlich als Pointer dargestellt, der bei \ccinline{NULL} \rustcinline{None} ist und ansonsten \rustcinline{Some(_)} \cite[100]{rust:orly_programming}.
Somit wird eine Überprüfung erzwungen, ohne dabei Laufzeitkosten erzeugt zu haben.

Bei dem atomaren Referenzzähler \rustcinline{Arc<_>} ist der Zähler im Heapspeicher direkt vor dem eigentlichen Wert und nicht in einem extra Speicherbereich \todo{cite}.
Ein weiteren indirekten Speicherzugriff mit Laufzeitkosten wird somit verhindert.


\subsection{Kein undefiniertes Verhalten}
\label{rust:no_unitialized_usage}
\todo{auch: no unitialized usage}
\todo{ref oreilly}
\todo{explain option}

\subsection{Keine vergessene Fehlerprüfung}
\label{rust:result}

\begin{figure}[H]
	\ccinclude
	{rust:result:c_bad_fopen}
	{Negativbeispiel: Fehlende Fehlerprüfung in C}
	{sections/rust.fopen.c}
\end{figure}

In \autoref{rust:result:c_bad_fopen} sind mindestens zwei Fehler versteckt, die aber keinen Compileabbruch auslösen, sondern sich zur Laufzeit zeigen können.
Der erste Fehler ist eine fehlende Überprüfung des Rückgabewertes von \ccinline{fopen} in Zeile 4, da dieser \ccinline{null} ist, falls das Öffnen der Datei fehlgeschlagen ist.
Der Versuch in die Datei zu schreiben in Zeile 5 kann daraufhin in einen Speicherzugriffsfehler resultieren und das Programm abstürzen lassen.
\todo{vergleich Java/C++(++) exceptions (vergessen von fehlerbehandlung in c++(++) trotzdem möglich)}

In Rust wird weder eine Ausnahme geworfen, noch ein Rückgabewert zurück gegeben, der ohne Prüfung verwendet werden kann:

\begin{figure}[H]
	\rustcinclude
		{rust:result:rust_good_fopen}
		{Positivbeispiel: Keine fehlende Fehlerprüfung in Rust}
		{sections/rust.fopen.rs}
\end{figure}

Der Rückgabewert von \rustcinline{File::open("private.key")} in Zeile 5 von \autoref{rust:result:rust_good_fopen} ist vom Typ \rustcinline{Result<File, Error>}.
Auf den eigentlichen Rückgabewert \rustcinline{File} kann nicht ohne eine Fehlerprüfung zugegriffen werden, da dies \rustcinline{Result} verhindert.
Eine Fehlerprüfung kann wie in Zeile 5 mit einem \rustcinline{match} passieren, oder auch mit anderen Funktionen wie \rustcinline{.unwrap()}, \rustcinline{.unwrap_or()} ... https://doc.rust-lang.org/std/result/enum.Result.html die dann aber eine \rustcinline{panic!} \todo{ref} auslösen, falls ein Fehler vorliegt -- somit wird ein undefiniertes Verhalten unterbunden \todo{ref}.

\todo{Der zweite Fehler...?}
Durch die Lebenszeitanalyse \todo{ref} in Rust ist der Geltungsbereich der \rustcinline{File} Variable bekannt, deshalb wird in dem Beispiel in Rust in \autoref{rust:result:rust_good_fopen} die Datei auch wieder ordnungsgemäß geschlossen, während dies im C Beispiel in \autoref{rust:result:c_bad_fopen} nicht der Fall ist.

\todo{explain result}

\subsection{No dangling pointer}
\todo{src https://www.youtube.com/watch?v=d1uraoHM8Gg}


\section{Einbinden von Bibliotheken}

\subsubsection{Externe Datentypen}
\label{rust:ffi}
\label{rust:ffi:datatypes}

Rust bietet durch das \gls{ffi} die Möglichkeit, andere (System-)Bibliotheken einzubinden.
Entsprechende Strukturen und Funktionen werden durch einen \rustcinline{extern}-Block
oder im Falle von Strukturen stattdessen optional mit einem \rustcinline{#[repr(C)]} gekennzeichnet.

In einem Beispiel, soll die Nutzung von \gls{ffi} demonstriert werden.

\begin{figure}[H]
	\ccinclude
		{rust:ffi:position_offset_c}
		{Ausschnitt von \enquote{PositionOffset} \todo{ref mecview lib} in C, autgen ASN}
		{sections/rust.position_offset.c}
	
\end{figure}

Die Struktur in \autoref{rust:ffi:position_offset_c} muss zur Nutzung in Rust zuerst bekannt gemacht werden.
Dabei gibt es mehrere Möglichkeiten:
\begin{enumerate}
	\item Falls der Aufbau der Struktur nicht von Bedeutung ist, kann es ausreichen, den Datentyp lediglich bekannt zu machen: \rustcinline{#[repr(C)] struct PositionOffset;} \label{rust:ffi:example:enumerate:repr}
	
	\item Der Aufbau ist wie bei \autoref{rust:ffi:example:enumerate:repr} unbedeutend, es soll aber ausdrücklich auf einen externen Datentyp hingewiesen werden: \rustcinline{extern \{ type PositionOffset; \}} \cite{rust:github:extern_type} (\todo{nightly})
	
	\item Der Inhalt der Struktur ist von Bedeutung, da darauf zugegriffen werden soll oder in Rust eine Instanz erzeugbar sein soll. In diesem Fall muss die Struktur komplett wiedergegeben werden:
	\begin{figure}[H]
		\rustcinclude
			{rust:ffi:position_offset_rust}
			{Ausschnitt von \enquote{PositionOffset} \todo{ref mecview lib} in Rust}
			{sections/rust.position_offset.rs}
	\end{figure}
	
	In \autoref{rust:ffi:position_offset_rust} ist die Struktur \enquote{PositionOffset} definiert,
	die durch das Attribut \rustcinline{#repr(C)} wie eine C-Struktur im Speicher organisiert wird.
	Somit ist sie kompatibel zu der C-Struktur aus \autoref{rust:ffi:position_offset_c}.
	
	Wenn auf eine C-Struktur zugegriffen wird, sollten auch, wie in \autoref{rust:ffi:position_offset_rust} zu sehen, spezielle Datentypen (\rustcinline{c_long}, \rustcinline{c_void}, \rustcinline{c_char}, ...) verwendet werden, um die Kompatibilität mit verschiedenen Systemen und C-Compilern zu wahren. \todo{u32 immer 32bit, aber int nicht immer gleich (Beispiel!?) --> Probleme}
	
%	\rustcinline{*mut c_long} entspricht dabei dem C-Pointer für \rustcinline{&mut c_long}, also \ccinline{long*}, ein C-Pointer für \rustcinline{&c_long} entspricht \rustcinline{*const c_long}.
	
%	C-Pointer werden in Rust \enquote{Raw-Pointer} genannt und \rustcinline{*mut c_long} für  \rustcinline{&mut c_long} bzw. \rustcinline{*const c_long} für \rustcinline{&c_long} geschrieben.
	
	Ein C-Pointer \ccinline{*long} wird in Rust \enquote{Raw-Pointer} genannt und entweder \rustcinline{*mut c_long} oder \rustcinline{*const c_long} geschrieben. Der Unterschied ist wie zwischen \rustcinline{&mut c_long} und \rustcinline{&c_long} und dient dem \todo{Rusttypsystem!? ref!?} zur Unterscheidung \todo{Erzwinungt im Besitz von entsprechender Mutability zu sein}, während es für die C-Seite keinen Unterschied macht \cite{rust:book:raw_ptr}:
	
	\begin{figure}[H]
		\centering
		\begin{tabular}{c|c|c}
			Referenz in Rust & Raw-Pointer in Rust & C-Pointer \\
			\hline
			\rustcinline{&mut c_long}  &   \rustcinline{*mut   c_long}  &   \ccinline{long*} \\
			\rustcinline{    &c_long}  &   \rustcinline{*const c_long}  &   \ccinline{long*}
		\end{tabular}
		\caption{Vergleich Rust Raw-Pointer und Referenz zu C-Pointer}
	\end{figure}
	
\end{enumerate}

\subsubsection{Externer Funktionsaufruf}
\label{rust:ffi:functioncall}

Während eine Struktur, die eine externe Struktur wiedergibt, sich optional in einem \rustcinline{extern \{\}} Block befinden kann, ist es zwingend, eine externe Funktionen darin bekannt zu machen:

\begin{figure}[H]
	\rustcinclude
		{rust:ffi:uper_encode_to_buffer}
		{Externe Funktionsdefinition der ASN.1 Funktion zum Enkodieren}
		{sections/rust.uper_encode_to_buffer.rs}
\end{figure}

Wie in \autoref{rust:ffi:uper_encode_to_buffer} zu sehen ist, können auch \rustcinline{extern \{\}} Blöcke mit Attributen versehen werden. Zwingend ist bei der Verwendung eines \rustcinline{#[link(..)]} Attributes der Name der Bibliothek, auf die sich der im \rustcinline{extern \{\}} Block stehende Code bezieht. Optional kann auch wie in \autoref{rust:ffi:uper_encode_to_buffer} die Art der \todo{Linkung} (dylib, static) angegeben werden.

Die Art der Definition einer externen Funktion unterscheidet sich nicht von einer normalen Funktionsdefinition. Es sollten aber, wie in \autoref{rust:ffi:datatypes} beschrieben, zu C bzw. der externen Sprache kompatiblen Datentypen verwendet werden.
 


\section{Kernfeatures}

https://www.youtube.com/watch?v=d1uraoHM8Gg \\
\todo{no need for a runtime, all static analytics} \\
\todo{memory safety} \\
\todo{data-race freedom} \\
\todo{active community} \\
\todo{concurrency: no undefined behavior} \\
\todo{ffi binding} \gls{ffi} \\
\todo{zero cost abstraction} \\
\todo{package manager: cargo} \\

https://www.youtube.com/watch?v=-Tj8Q12DaEQ \\
\todo{static type system with local type inference } \\
\todo{explicit notion of mutability } \\
\todo{zero-cost abstraction *(do not introduce new cost through implementation of abstraction)} \\
\todo{errors are values not exceptions}
\todo{no null} \\
\todo{"static automatic memory management" - no garbage collection } \\
\todo{often compared to GO and D (~44min)} \\


\section{Schwächen}

https://www.youtube.com/watch?v=-Tj8Q12DaEQ \\
\todo{compile-times} \\
\todo{Rust is a vampire language, it does not reflect at all!} \\
\todo{depending on the field -> majority of libraries?} \\


\section{Performance Fallstricke}

\todo{\cite{rust:performance_pitfalls}}

\section{Beispiele von Verwendung von Rust}

\todo{firefox} \\

https://www.youtube.com/watch?v=-Tj8Q12DaEQ \\
\todo{GTK binding heavily to rust} \\

\todo{unstable}
\todo{ffi}
