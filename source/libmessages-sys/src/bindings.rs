/* automatically generated by rust-bindgen */

#[repr(C)]
#[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct __BindgenBitfieldUnit<Storage, Align>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    storage: Storage,
    align: [Align; 0],
}

impl<Storage, Align> __BindgenBitfieldUnit<Storage, Align>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    #[inline]
    pub fn new(storage: Storage) -> Self {
        Self {
            storage,
            align: [],
        }
    }

    #[inline]
    pub fn get_bit(&self, index: usize) -> bool {
        debug_assert!(index / 8 < self.storage.as_ref().len());

        let byte_index = index / 8;
        let byte = self.storage.as_ref()[byte_index];

        let bit_index = index % 8;
        let mask = 1 << bit_index;

        byte & mask == mask
    }

    #[inline]
    pub fn set_bit(&mut self, index: usize, val: bool) {
        debug_assert!(index / 8 < self.storage.as_ref().len());

        let byte_index = index / 8;
        let byte = &mut self.storage.as_mut()[byte_index];

        let bit_index = index % 8;
        let mask = 1 << bit_index;

        if val {
            *byte |= mask;
        } else {
            *byte &= !mask;
        }
    }

    #[inline]
    pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());

        let mut val = 0;

        for i in 0..(bit_width as usize) {
            if self.get_bit(i + bit_offset) {
                val |= 1 << i;
            }
        }

        val
    }

    #[inline]
    pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());

        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            self.set_bit(i + bit_offset, val_bit_is_set);
        }
    }
}
 # [ repr ( C ) ] # [ derive ( Default ) ] pub struct __IncompleteArrayField < T > ( :: std :: marker :: PhantomData < T > ) ; impl < T > __IncompleteArrayField < T > { # [ inline ] pub fn new ( ) -> Self { __IncompleteArrayField ( :: std :: marker :: PhantomData ) } # [ inline ] pub unsafe fn as_ptr ( & self ) -> * const T { :: std :: mem :: transmute ( self ) } # [ inline ] pub unsafe fn as_mut_ptr ( & mut self ) -> * mut T { :: std :: mem :: transmute ( self ) } # [ inline ] pub unsafe fn as_slice ( & self , len : usize ) -> & [ T ] { :: std :: slice :: from_raw_parts ( self . as_ptr ( ) , len ) } # [ inline ] pub unsafe fn as_mut_slice ( & mut self , len : usize ) -> & mut [ T ] { :: std :: slice :: from_raw_parts_mut ( self . as_mut_ptr ( ) , len ) } } impl < T > :: std :: fmt :: Debug for __IncompleteArrayField < T > { fn fmt ( & self , fmt : & mut :: std :: fmt :: Formatter ) -> :: std :: fmt :: Result { fmt . write_str ( "__IncompleteArrayField" ) } } impl < T > :: std :: clone :: Clone for __IncompleteArrayField < T > { # [ inline ] fn clone ( & self ) -> Self { Self :: new ( ) } } impl < T > :: std :: marker :: Copy for __IncompleteArrayField < T > { } pub const _STDIO_H : u32 = 1 ; pub const _FEATURES_H : u32 = 1 ; pub const _DEFAULT_SOURCE : u32 = 1 ; pub const __USE_ISOC11 : u32 = 1 ; pub const __USE_ISOC99 : u32 = 1 ; pub const __USE_ISOC95 : u32 = 1 ; pub const __USE_POSIX_IMPLICITLY : u32 = 1 ; pub const _POSIX_SOURCE : u32 = 1 ; pub const _POSIX_C_SOURCE : u32 = 200809 ; pub const __USE_POSIX : u32 = 1 ; pub const __USE_POSIX2 : u32 = 1 ; pub const __USE_POSIX199309 : u32 = 1 ; pub const __USE_POSIX199506 : u32 = 1 ; pub const __USE_XOPEN2K : u32 = 1 ; pub const __USE_XOPEN2K8 : u32 = 1 ; pub const _ATFILE_SOURCE : u32 = 1 ; pub const __USE_MISC : u32 = 1 ; pub const __USE_ATFILE : u32 = 1 ; pub const __USE_FORTIFY_LEVEL : u32 = 0 ; pub const _STDC_PREDEF_H : u32 = 1 ; pub const __STDC_IEC_559__ : u32 = 1 ; pub const __STDC_IEC_559_COMPLEX__ : u32 = 1 ; pub const __STDC_ISO_10646__ : u32 = 201505 ; pub const __STDC_NO_THREADS__ : u32 = 1 ; pub const __GNU_LIBRARY__ : u32 = 6 ; pub const __GLIBC__ : u32 = 2 ; pub const __GLIBC_MINOR__ : u32 = 23 ; pub const _SYS_CDEFS_H : u32 = 1 ; pub const __WORDSIZE : u32 = 64 ; pub const __WORDSIZE_TIME64_COMPAT32 : u32 = 1 ; pub const __SYSCALL_WORDSIZE : u32 = 64 ; pub const _BITS_TYPES_H : u32 = 1 ; pub const _BITS_TYPESIZES_H : u32 = 1 ; pub const __OFF_T_MATCHES_OFF64_T : u32 = 1 ; pub const __INO_T_MATCHES_INO64_T : u32 = 1 ; pub const __FD_SETSIZE : u32 = 1024 ; pub const __FILE_defined : u32 = 1 ; pub const ____FILE_defined : u32 = 1 ; pub const _G_config_h : u32 = 1 ; pub const ____mbstate_t_defined : u32 = 1 ; pub const _G_HAVE_MMAP : u32 = 1 ; pub const _G_HAVE_MREMAP : u32 = 1 ; pub const _G_IO_IO_FILE_VERSION : u32 = 131073 ; pub const _G_BUFSIZ : u32 = 8192 ; pub const _IO_BUFSIZ : u32 = 8192 ; pub const __GNUC_VA_LIST : u32 = 1 ; pub const _IO_UNIFIED_JUMPTABLES : u32 = 1 ; pub const EOF : i32 = -1 ; pub const _IOS_INPUT : u32 = 1 ; pub const _IOS_OUTPUT : u32 = 2 ; pub const _IOS_ATEND : u32 = 4 ; pub const _IOS_APPEND : u32 = 8 ; pub const _IOS_TRUNC : u32 = 16 ; pub const _IOS_NOCREATE : u32 = 32 ; pub const _IOS_NOREPLACE : u32 = 64 ; pub const _IOS_BIN : u32 = 128 ; pub const _IO_MAGIC : u32 = 4222418944 ; pub const _OLD_STDIO_MAGIC : u32 = 4206624768 ; pub const _IO_MAGIC_MASK : u32 = 4294901760 ; pub const _IO_USER_BUF : u32 = 1 ; pub const _IO_UNBUFFERED : u32 = 2 ; pub const _IO_NO_READS : u32 = 4 ; pub const _IO_NO_WRITES : u32 = 8 ; pub const _IO_EOF_SEEN : u32 = 16 ; pub const _IO_ERR_SEEN : u32 = 32 ; pub const _IO_DELETE_DONT_CLOSE : u32 = 64 ; pub const _IO_LINKED : u32 = 128 ; pub const _IO_IN_BACKUP : u32 = 256 ; pub const _IO_LINE_BUF : u32 = 512 ; pub const _IO_TIED_PUT_GET : u32 = 1024 ; pub const _IO_CURRENTLY_PUTTING : u32 = 2048 ; pub const _IO_IS_APPENDING : u32 = 4096 ; pub const _IO_IS_FILEBUF : u32 = 8192 ; pub const _IO_BAD_SEEN : u32 = 16384 ; pub const _IO_USER_LOCK : u32 = 32768 ; pub const _IO_FLAGS2_MMAP : u32 = 1 ; pub const _IO_FLAGS2_NOTCANCEL : u32 = 2 ; pub const _IO_FLAGS2_USER_WBUF : u32 = 8 ; pub const _IO_SKIPWS : u32 = 1 ; pub const _IO_LEFT : u32 = 2 ; pub const _IO_RIGHT : u32 = 4 ; pub const _IO_INTERNAL : u32 = 8 ; pub const _IO_DEC : u32 = 16 ; pub const _IO_OCT : u32 = 32 ; pub const _IO_HEX : u32 = 64 ; pub const _IO_SHOWBASE : u32 = 128 ; pub const _IO_SHOWPOINT : u32 = 256 ; pub const _IO_UPPERCASE : u32 = 512 ; pub const _IO_SHOWPOS : u32 = 1024 ; pub const _IO_SCIENTIFIC : u32 = 2048 ; pub const _IO_FIXED : u32 = 4096 ; pub const _IO_UNITBUF : u32 = 8192 ; pub const _IO_STDIO : u32 = 16384 ; pub const _IO_DONT_CLOSE : u32 = 32768 ; pub const _IO_BOOLALPHA : u32 = 65536 ; pub const _IOFBF : u32 = 0 ; pub const _IOLBF : u32 = 1 ; pub const _IONBF : u32 = 2 ; pub const BUFSIZ : u32 = 8192 ; pub const SEEK_SET : u32 = 0 ; pub const SEEK_CUR : u32 = 1 ; pub const SEEK_END : u32 = 2 ; pub const P_tmpdir : & 'static [ u8 ; 5usize ] = b"/tmp\0" ; pub const L_tmpnam : u32 = 20 ; pub const TMP_MAX : u32 = 238328 ; pub const FILENAME_MAX : u32 = 4096 ; pub const L_ctermid : u32 = 9 ; pub const FOPEN_MAX : u32 = 16 ; pub const _STDLIB_H : u32 = 1 ; pub const WNOHANG : u32 = 1 ; pub const WUNTRACED : u32 = 2 ; pub const WSTOPPED : u32 = 2 ; pub const WEXITED : u32 = 4 ; pub const WCONTINUED : u32 = 8 ; pub const WNOWAIT : u32 = 16777216 ; pub const __WNOTHREAD : u32 = 536870912 ; pub const __WALL : u32 = 1073741824 ; pub const __WCLONE : u32 = 2147483648 ; pub const __ENUM_IDTYPE_T : u32 = 1 ; pub const __W_CONTINUED : u32 = 65535 ; pub const __WCOREFLAG : u32 = 128 ; pub const _ENDIAN_H : u32 = 1 ; pub const __LITTLE_ENDIAN : u32 = 1234 ; pub const __BIG_ENDIAN : u32 = 4321 ; pub const __PDP_ENDIAN : u32 = 3412 ; pub const __BYTE_ORDER : u32 = 1234 ; pub const __FLOAT_WORD_ORDER : u32 = 1234 ; pub const LITTLE_ENDIAN : u32 = 1234 ; pub const BIG_ENDIAN : u32 = 4321 ; pub const PDP_ENDIAN : u32 = 3412 ; pub const BYTE_ORDER : u32 = 1234 ; pub const _BITS_BYTESWAP_H : u32 = 1 ; pub const __ldiv_t_defined : u32 = 1 ; pub const __lldiv_t_defined : u32 = 1 ; pub const RAND_MAX : u32 = 2147483647 ; pub const EXIT_FAILURE : u32 = 1 ; pub const EXIT_SUCCESS : u32 = 0 ; pub const _SYS_TYPES_H : u32 = 1 ; pub const __clock_t_defined : u32 = 1 ; pub const __time_t_defined : u32 = 1 ; pub const __clockid_t_defined : u32 = 1 ; pub const __timer_t_defined : u32 = 1 ; pub const __BIT_TYPES_DEFINED__ : u32 = 1 ; pub const _SYS_SELECT_H : u32 = 1 ; pub const __FD_ZERO_STOS : & 'static [ u8 ; 6usize ] = b"stosq\0" ; pub const _SIGSET_H_types : u32 = 1 ; pub const __timespec_defined : u32 = 1 ; pub const _STRUCT_TIMEVAL : u32 = 1 ; pub const FD_SETSIZE : u32 = 1024 ; pub const _SYS_SYSMACROS_H : u32 = 1 ; pub const _BITS_PTHREADTYPES_H : u32 = 1 ; pub const __SIZEOF_PTHREAD_ATTR_T : u32 = 56 ; pub const __SIZEOF_PTHREAD_MUTEX_T : u32 = 40 ; pub const __SIZEOF_PTHREAD_MUTEXATTR_T : u32 = 4 ; pub const __SIZEOF_PTHREAD_COND_T : u32 = 48 ; pub const __SIZEOF_PTHREAD_CONDATTR_T : u32 = 4 ; pub const __SIZEOF_PTHREAD_RWLOCK_T : u32 = 56 ; pub const __SIZEOF_PTHREAD_RWLOCKATTR_T : u32 = 8 ; pub const __SIZEOF_PTHREAD_BARRIER_T : u32 = 32 ; pub const __SIZEOF_PTHREAD_BARRIERATTR_T : u32 = 4 ; pub const __have_pthread_attr_t : u32 = 1 ; pub const __PTHREAD_MUTEX_HAVE_PREV : u32 = 1 ; pub const __PTHREAD_RWLOCK_INT_FLAGS_SHARED : u32 = 1 ; pub const _ALLOCA_H : u32 = 1 ; pub const _STRING_H : u32 = 1 ; pub const _XLOCALE_H : u32 = 1 ; pub const _LIBC_LIMITS_H_ : u32 = 1 ; pub const MB_LEN_MAX : u32 = 16 ; pub const _BITS_POSIX1_LIM_H : u32 = 1 ; pub const _POSIX_AIO_LISTIO_MAX : u32 = 2 ; pub const _POSIX_AIO_MAX : u32 = 1 ; pub const _POSIX_ARG_MAX : u32 = 4096 ; pub const _POSIX_CHILD_MAX : u32 = 25 ; pub const _POSIX_DELAYTIMER_MAX : u32 = 32 ; pub const _POSIX_HOST_NAME_MAX : u32 = 255 ; pub const _POSIX_LINK_MAX : u32 = 8 ; pub const _POSIX_LOGIN_NAME_MAX : u32 = 9 ; pub const _POSIX_MAX_CANON : u32 = 255 ; pub const _POSIX_MAX_INPUT : u32 = 255 ; pub const _POSIX_MQ_OPEN_MAX : u32 = 8 ; pub const _POSIX_MQ_PRIO_MAX : u32 = 32 ; pub const _POSIX_NAME_MAX : u32 = 14 ; pub const _POSIX_NGROUPS_MAX : u32 = 8 ; pub const _POSIX_OPEN_MAX : u32 = 20 ; pub const _POSIX_PATH_MAX : u32 = 256 ; pub const _POSIX_PIPE_BUF : u32 = 512 ; pub const _POSIX_RE_DUP_MAX : u32 = 255 ; pub const _POSIX_RTSIG_MAX : u32 = 8 ; pub const _POSIX_SEM_NSEMS_MAX : u32 = 256 ; pub const _POSIX_SEM_VALUE_MAX : u32 = 32767 ; pub const _POSIX_SIGQUEUE_MAX : u32 = 32 ; pub const _POSIX_SSIZE_MAX : u32 = 32767 ; pub const _POSIX_STREAM_MAX : u32 = 8 ; pub const _POSIX_SYMLINK_MAX : u32 = 255 ; pub const _POSIX_SYMLOOP_MAX : u32 = 8 ; pub const _POSIX_TIMER_MAX : u32 = 32 ; pub const _POSIX_TTY_NAME_MAX : u32 = 9 ; pub const _POSIX_TZNAME_MAX : u32 = 6 ; pub const _POSIX_CLOCKRES_MIN : u32 = 20000000 ; pub const NR_OPEN : u32 = 1024 ; pub const NGROUPS_MAX : u32 = 65536 ; pub const ARG_MAX : u32 = 131072 ; pub const LINK_MAX : u32 = 127 ; pub const MAX_CANON : u32 = 255 ; pub const MAX_INPUT : u32 = 255 ; pub const NAME_MAX : u32 = 255 ; pub const PATH_MAX : u32 = 4096 ; pub const PIPE_BUF : u32 = 4096 ; pub const XATTR_NAME_MAX : u32 = 255 ; pub const XATTR_SIZE_MAX : u32 = 65536 ; pub const XATTR_LIST_MAX : u32 = 65536 ; pub const RTSIG_MAX : u32 = 32 ; pub const _POSIX_THREAD_KEYS_MAX : u32 = 128 ; pub const PTHREAD_KEYS_MAX : u32 = 1024 ; pub const _POSIX_THREAD_DESTRUCTOR_ITERATIONS : u32 = 4 ; pub const PTHREAD_DESTRUCTOR_ITERATIONS : u32 = 4 ; pub const _POSIX_THREAD_THREADS_MAX : u32 = 64 ; pub const AIO_PRIO_DELTA_MAX : u32 = 20 ; pub const PTHREAD_STACK_MIN : u32 = 16384 ; pub const DELAYTIMER_MAX : u32 = 2147483647 ; pub const TTY_NAME_MAX : u32 = 32 ; pub const LOGIN_NAME_MAX : u32 = 256 ; pub const HOST_NAME_MAX : u32 = 64 ; pub const MQ_PRIO_MAX : u32 = 32768 ; pub const SEM_VALUE_MAX : u32 = 2147483647 ; pub const _BITS_POSIX2_LIM_H : u32 = 1 ; pub const _POSIX2_BC_BASE_MAX : u32 = 99 ; pub const _POSIX2_BC_DIM_MAX : u32 = 2048 ; pub const _POSIX2_BC_SCALE_MAX : u32 = 99 ; pub const _POSIX2_BC_STRING_MAX : u32 = 1000 ; pub const _POSIX2_COLL_WEIGHTS_MAX : u32 = 2 ; pub const _POSIX2_EXPR_NEST_MAX : u32 = 32 ; pub const _POSIX2_LINE_MAX : u32 = 2048 ; pub const _POSIX2_RE_DUP_MAX : u32 = 255 ; pub const _POSIX2_CHARCLASS_NAME_MAX : u32 = 14 ; pub const BC_BASE_MAX : u32 = 99 ; pub const BC_DIM_MAX : u32 = 2048 ; pub const BC_SCALE_MAX : u32 = 99 ; pub const BC_STRING_MAX : u32 = 1000 ; pub const COLL_WEIGHTS_MAX : u32 = 255 ; pub const EXPR_NEST_MAX : u32 = 32 ; pub const LINE_MAX : u32 = 2048 ; pub const CHARCLASS_NAME_MAX : u32 = 2048 ; pub const RE_DUP_MAX : u32 = 32767 ; pub const _INTTYPES_H : u32 = 1 ; pub const _STDINT_H : u32 = 1 ; pub const _BITS_WCHAR_H : u32 = 1 ; pub const INT8_MIN : i32 = -128 ; pub const INT16_MIN : i32 = -32768 ; pub const INT32_MIN : i32 = -2147483648 ; pub const INT8_MAX : u32 = 127 ; pub const INT16_MAX : u32 = 32767 ; pub const INT32_MAX : u32 = 2147483647 ; pub const UINT8_MAX : u32 = 255 ; pub const UINT16_MAX : u32 = 65535 ; pub const UINT32_MAX : u32 = 4294967295 ; pub const INT_LEAST8_MIN : i32 = -128 ; pub const INT_LEAST16_MIN : i32 = -32768 ; pub const INT_LEAST32_MIN : i32 = -2147483648 ; pub const INT_LEAST8_MAX : u32 = 127 ; pub const INT_LEAST16_MAX : u32 = 32767 ; pub const INT_LEAST32_MAX : u32 = 2147483647 ; pub const UINT_LEAST8_MAX : u32 = 255 ; pub const UINT_LEAST16_MAX : u32 = 65535 ; pub const UINT_LEAST32_MAX : u32 = 4294967295 ; pub const INT_FAST8_MIN : i32 = -128 ; pub const INT_FAST16_MIN : i64 = -9223372036854775808 ; pub const INT_FAST32_MIN : i64 = -9223372036854775808 ; pub const INT_FAST8_MAX : u32 = 127 ; pub const INT_FAST16_MAX : u64 = 9223372036854775807 ; pub const INT_FAST32_MAX : u64 = 9223372036854775807 ; pub const UINT_FAST8_MAX : u32 = 255 ; pub const UINT_FAST16_MAX : i32 = -1 ; pub const UINT_FAST32_MAX : i32 = -1 ; pub const INTPTR_MIN : i64 = -9223372036854775808 ; pub const INTPTR_MAX : u64 = 9223372036854775807 ; pub const UINTPTR_MAX : i32 = -1 ; pub const PTRDIFF_MIN : i64 = -9223372036854775808 ; pub const PTRDIFF_MAX : u64 = 9223372036854775807 ; pub const SIG_ATOMIC_MIN : i32 = -2147483648 ; pub const SIG_ATOMIC_MAX : u32 = 2147483647 ; pub const SIZE_MAX : i32 = -1 ; pub const WINT_MIN : u32 = 0 ; pub const WINT_MAX : u32 = 4294967295 ; pub const ____gwchar_t_defined : u32 = 1 ; pub const __PRI64_PREFIX : & 'static [ u8 ; 2usize ] = b"l\0" ; pub const __PRIPTR_PREFIX : & 'static [ u8 ; 2usize ] = b"l\0" ; pub const PRId8 : & 'static [ u8 ; 2usize ] = b"d\0" ; pub const PRId16 : & 'static [ u8 ; 2usize ] = b"d\0" ; pub const PRId32 : & 'static [ u8 ; 2usize ] = b"d\0" ; pub const PRId64 : & 'static [ u8 ; 3usize ] = b"ld\0" ; pub const PRIdLEAST8 : & 'static [ u8 ; 2usize ] = b"d\0" ; pub const PRIdLEAST16 : & 'static [ u8 ; 2usize ] = b"d\0" ; pub const PRIdLEAST32 : & 'static [ u8 ; 2usize ] = b"d\0" ; pub const PRIdLEAST64 : & 'static [ u8 ; 3usize ] = b"ld\0" ; pub const PRIdFAST8 : & 'static [ u8 ; 2usize ] = b"d\0" ; pub const PRIdFAST16 : & 'static [ u8 ; 3usize ] = b"ld\0" ; pub const PRIdFAST32 : & 'static [ u8 ; 3usize ] = b"ld\0" ; pub const PRIdFAST64 : & 'static [ u8 ; 3usize ] = b"ld\0" ; pub const PRIi8 : & 'static [ u8 ; 2usize ] = b"i\0" ; pub const PRIi16 : & 'static [ u8 ; 2usize ] = b"i\0" ; pub const PRIi32 : & 'static [ u8 ; 2usize ] = b"i\0" ; pub const PRIi64 : & 'static [ u8 ; 3usize ] = b"li\0" ; pub const PRIiLEAST8 : & 'static [ u8 ; 2usize ] = b"i\0" ; pub const PRIiLEAST16 : & 'static [ u8 ; 2usize ] = b"i\0" ; pub const PRIiLEAST32 : & 'static [ u8 ; 2usize ] = b"i\0" ; pub const PRIiLEAST64 : & 'static [ u8 ; 3usize ] = b"li\0" ; pub const PRIiFAST8 : & 'static [ u8 ; 2usize ] = b"i\0" ; pub const PRIiFAST16 : & 'static [ u8 ; 3usize ] = b"li\0" ; pub const PRIiFAST32 : & 'static [ u8 ; 3usize ] = b"li\0" ; pub const PRIiFAST64 : & 'static [ u8 ; 3usize ] = b"li\0" ; pub const PRIo8 : & 'static [ u8 ; 2usize ] = b"o\0" ; pub const PRIo16 : & 'static [ u8 ; 2usize ] = b"o\0" ; pub const PRIo32 : & 'static [ u8 ; 2usize ] = b"o\0" ; pub const PRIo64 : & 'static [ u8 ; 3usize ] = b"lo\0" ; pub const PRIoLEAST8 : & 'static [ u8 ; 2usize ] = b"o\0" ; pub const PRIoLEAST16 : & 'static [ u8 ; 2usize ] = b"o\0" ; pub const PRIoLEAST32 : & 'static [ u8 ; 2usize ] = b"o\0" ; pub const PRIoLEAST64 : & 'static [ u8 ; 3usize ] = b"lo\0" ; pub const PRIoFAST8 : & 'static [ u8 ; 2usize ] = b"o\0" ; pub const PRIoFAST16 : & 'static [ u8 ; 3usize ] = b"lo\0" ; pub const PRIoFAST32 : & 'static [ u8 ; 3usize ] = b"lo\0" ; pub const PRIoFAST64 : & 'static [ u8 ; 3usize ] = b"lo\0" ; pub const PRIu8 : & 'static [ u8 ; 2usize ] = b"u\0" ; pub const PRIu16 : & 'static [ u8 ; 2usize ] = b"u\0" ; pub const PRIu32 : & 'static [ u8 ; 2usize ] = b"u\0" ; pub const PRIu64 : & 'static [ u8 ; 3usize ] = b"lu\0" ; pub const PRIuLEAST8 : & 'static [ u8 ; 2usize ] = b"u\0" ; pub const PRIuLEAST16 : & 'static [ u8 ; 2usize ] = b"u\0" ; pub const PRIuLEAST32 : & 'static [ u8 ; 2usize ] = b"u\0" ; pub const PRIuLEAST64 : & 'static [ u8 ; 3usize ] = b"lu\0" ; pub const PRIuFAST8 : & 'static [ u8 ; 2usize ] = b"u\0" ; pub const PRIuFAST16 : & 'static [ u8 ; 3usize ] = b"lu\0" ; pub const PRIuFAST32 : & 'static [ u8 ; 3usize ] = b"lu\0" ; pub const PRIuFAST64 : & 'static [ u8 ; 3usize ] = b"lu\0" ; pub const PRIx8 : & 'static [ u8 ; 2usize ] = b"x\0" ; pub const PRIx16 : & 'static [ u8 ; 2usize ] = b"x\0" ; pub const PRIx32 : & 'static [ u8 ; 2usize ] = b"x\0" ; pub const PRIx64 : & 'static [ u8 ; 3usize ] = b"lx\0" ; pub const PRIxLEAST8 : & 'static [ u8 ; 2usize ] = b"x\0" ; pub const PRIxLEAST16 : & 'static [ u8 ; 2usize ] = b"x\0" ; pub const PRIxLEAST32 : & 'static [ u8 ; 2usize ] = b"x\0" ; pub const PRIxLEAST64 : & 'static [ u8 ; 3usize ] = b"lx\0" ; pub const PRIxFAST8 : & 'static [ u8 ; 2usize ] = b"x\0" ; pub const PRIxFAST16 : & 'static [ u8 ; 3usize ] = b"lx\0" ; pub const PRIxFAST32 : & 'static [ u8 ; 3usize ] = b"lx\0" ; pub const PRIxFAST64 : & 'static [ u8 ; 3usize ] = b"lx\0" ; pub const PRIX8 : & 'static [ u8 ; 2usize ] = b"X\0" ; pub const PRIX16 : & 'static [ u8 ; 2usize ] = b"X\0" ; pub const PRIX32 : & 'static [ u8 ; 2usize ] = b"X\0" ; pub const PRIX64 : & 'static [ u8 ; 3usize ] = b"lX\0" ; pub const PRIXLEAST8 : & 'static [ u8 ; 2usize ] = b"X\0" ; pub const PRIXLEAST16 : & 'static [ u8 ; 2usize ] = b"X\0" ; pub const PRIXLEAST32 : & 'static [ u8 ; 2usize ] = b"X\0" ; pub const PRIXLEAST64 : & 'static [ u8 ; 3usize ] = b"lX\0" ; pub const PRIXFAST8 : & 'static [ u8 ; 2usize ] = b"X\0" ; pub const PRIXFAST16 : & 'static [ u8 ; 3usize ] = b"lX\0" ; pub const PRIXFAST32 : & 'static [ u8 ; 3usize ] = b"lX\0" ; pub const PRIXFAST64 : & 'static [ u8 ; 3usize ] = b"lX\0" ; pub const PRIdMAX : & 'static [ u8 ; 3usize ] = b"ld\0" ; pub const PRIiMAX : & 'static [ u8 ; 3usize ] = b"li\0" ; pub const PRIoMAX : & 'static [ u8 ; 3usize ] = b"lo\0" ; pub const PRIuMAX : & 'static [ u8 ; 3usize ] = b"lu\0" ; pub const PRIxMAX : & 'static [ u8 ; 3usize ] = b"lx\0" ; pub const PRIXMAX : & 'static [ u8 ; 3usize ] = b"lX\0" ; pub const PRIdPTR : & 'static [ u8 ; 3usize ] = b"ld\0" ; pub const PRIiPTR : & 'static [ u8 ; 3usize ] = b"li\0" ; pub const PRIoPTR : & 'static [ u8 ; 3usize ] = b"lo\0" ; pub const PRIuPTR : & 'static [ u8 ; 3usize ] = b"lu\0" ; pub const PRIxPTR : & 'static [ u8 ; 3usize ] = b"lx\0" ; pub const PRIXPTR : & 'static [ u8 ; 3usize ] = b"lX\0" ; pub const SCNd8 : & 'static [ u8 ; 4usize ] = b"hhd\0" ; pub const SCNd16 : & 'static [ u8 ; 3usize ] = b"hd\0" ; pub const SCNd32 : & 'static [ u8 ; 2usize ] = b"d\0" ; pub const SCNd64 : & 'static [ u8 ; 3usize ] = b"ld\0" ; pub const SCNdLEAST8 : & 'static [ u8 ; 4usize ] = b"hhd\0" ; pub const SCNdLEAST16 : & 'static [ u8 ; 3usize ] = b"hd\0" ; pub const SCNdLEAST32 : & 'static [ u8 ; 2usize ] = b"d\0" ; pub const SCNdLEAST64 : & 'static [ u8 ; 3usize ] = b"ld\0" ; pub const SCNdFAST8 : & 'static [ u8 ; 4usize ] = b"hhd\0" ; pub const SCNdFAST16 : & 'static [ u8 ; 3usize ] = b"ld\0" ; pub const SCNdFAST32 : & 'static [ u8 ; 3usize ] = b"ld\0" ; pub const SCNdFAST64 : & 'static [ u8 ; 3usize ] = b"ld\0" ; pub const SCNi8 : & 'static [ u8 ; 4usize ] = b"hhi\0" ; pub const SCNi16 : & 'static [ u8 ; 3usize ] = b"hi\0" ; pub const SCNi32 : & 'static [ u8 ; 2usize ] = b"i\0" ; pub const SCNi64 : & 'static [ u8 ; 3usize ] = b"li\0" ; pub const SCNiLEAST8 : & 'static [ u8 ; 4usize ] = b"hhi\0" ; pub const SCNiLEAST16 : & 'static [ u8 ; 3usize ] = b"hi\0" ; pub const SCNiLEAST32 : & 'static [ u8 ; 2usize ] = b"i\0" ; pub const SCNiLEAST64 : & 'static [ u8 ; 3usize ] = b"li\0" ; pub const SCNiFAST8 : & 'static [ u8 ; 4usize ] = b"hhi\0" ; pub const SCNiFAST16 : & 'static [ u8 ; 3usize ] = b"li\0" ; pub const SCNiFAST32 : & 'static [ u8 ; 3usize ] = b"li\0" ; pub const SCNiFAST64 : & 'static [ u8 ; 3usize ] = b"li\0" ; pub const SCNu8 : & 'static [ u8 ; 4usize ] = b"hhu\0" ; pub const SCNu16 : & 'static [ u8 ; 3usize ] = b"hu\0" ; pub const SCNu32 : & 'static [ u8 ; 2usize ] = b"u\0" ; pub const SCNu64 : & 'static [ u8 ; 3usize ] = b"lu\0" ; pub const SCNuLEAST8 : & 'static [ u8 ; 4usize ] = b"hhu\0" ; pub const SCNuLEAST16 : & 'static [ u8 ; 3usize ] = b"hu\0" ; pub const SCNuLEAST32 : & 'static [ u8 ; 2usize ] = b"u\0" ; pub const SCNuLEAST64 : & 'static [ u8 ; 3usize ] = b"lu\0" ; pub const SCNuFAST8 : & 'static [ u8 ; 4usize ] = b"hhu\0" ; pub const SCNuFAST16 : & 'static [ u8 ; 3usize ] = b"lu\0" ; pub const SCNuFAST32 : & 'static [ u8 ; 3usize ] = b"lu\0" ; pub const SCNuFAST64 : & 'static [ u8 ; 3usize ] = b"lu\0" ; pub const SCNo8 : & 'static [ u8 ; 4usize ] = b"hho\0" ; pub const SCNo16 : & 'static [ u8 ; 3usize ] = b"ho\0" ; pub const SCNo32 : & 'static [ u8 ; 2usize ] = b"o\0" ; pub const SCNo64 : & 'static [ u8 ; 3usize ] = b"lo\0" ; pub const SCNoLEAST8 : & 'static [ u8 ; 4usize ] = b"hho\0" ; pub const SCNoLEAST16 : & 'static [ u8 ; 3usize ] = b"ho\0" ; pub const SCNoLEAST32 : & 'static [ u8 ; 2usize ] = b"o\0" ; pub const SCNoLEAST64 : & 'static [ u8 ; 3usize ] = b"lo\0" ; pub const SCNoFAST8 : & 'static [ u8 ; 4usize ] = b"hho\0" ; pub const SCNoFAST16 : & 'static [ u8 ; 3usize ] = b"lo\0" ; pub const SCNoFAST32 : & 'static [ u8 ; 3usize ] = b"lo\0" ; pub const SCNoFAST64 : & 'static [ u8 ; 3usize ] = b"lo\0" ; pub const SCNx8 : & 'static [ u8 ; 4usize ] = b"hhx\0" ; pub const SCNx16 : & 'static [ u8 ; 3usize ] = b"hx\0" ; pub const SCNx32 : & 'static [ u8 ; 2usize ] = b"x\0" ; pub const SCNx64 : & 'static [ u8 ; 3usize ] = b"lx\0" ; pub const SCNxLEAST8 : & 'static [ u8 ; 4usize ] = b"hhx\0" ; pub const SCNxLEAST16 : & 'static [ u8 ; 3usize ] = b"hx\0" ; pub const SCNxLEAST32 : & 'static [ u8 ; 2usize ] = b"x\0" ; pub const SCNxLEAST64 : & 'static [ u8 ; 3usize ] = b"lx\0" ; pub const SCNxFAST8 : & 'static [ u8 ; 4usize ] = b"hhx\0" ; pub const SCNxFAST16 : & 'static [ u8 ; 3usize ] = b"lx\0" ; pub const SCNxFAST32 : & 'static [ u8 ; 3usize ] = b"lx\0" ; pub const SCNxFAST64 : & 'static [ u8 ; 3usize ] = b"lx\0" ; pub const SCNdMAX : & 'static [ u8 ; 3usize ] = b"ld\0" ; pub const SCNiMAX : & 'static [ u8 ; 3usize ] = b"li\0" ; pub const SCNoMAX : & 'static [ u8 ; 3usize ] = b"lo\0" ; pub const SCNuMAX : & 'static [ u8 ; 3usize ] = b"lu\0" ; pub const SCNxMAX : & 'static [ u8 ; 3usize ] = b"lx\0" ; pub const SCNdPTR : & 'static [ u8 ; 3usize ] = b"ld\0" ; pub const SCNiPTR : & 'static [ u8 ; 3usize ] = b"li\0" ; pub const SCNoPTR : & 'static [ u8 ; 3usize ] = b"lo\0" ; pub const SCNuPTR : & 'static [ u8 ; 3usize ] = b"lu\0" ; pub const SCNxPTR : & 'static [ u8 ; 3usize ] = b"lx\0" ; pub const _NETINET_IN_H : u32 = 1 ; pub const _SYS_SOCKET_H : u32 = 1 ; pub const _SYS_UIO_H : u32 = 1 ; pub const _BITS_UIO_H : u32 = 1 ; pub const UIO_MAXIOV : u32 = 1024 ; pub const PF_UNSPEC : u32 = 0 ; pub const PF_LOCAL : u32 = 1 ; pub const PF_UNIX : u32 = 1 ; pub const PF_FILE : u32 = 1 ; pub const PF_INET : u32 = 2 ; pub const PF_AX25 : u32 = 3 ; pub const PF_IPX : u32 = 4 ; pub const PF_APPLETALK : u32 = 5 ; pub const PF_NETROM : u32 = 6 ; pub const PF_BRIDGE : u32 = 7 ; pub const PF_ATMPVC : u32 = 8 ; pub const PF_X25 : u32 = 9 ; pub const PF_INET6 : u32 = 10 ; pub const PF_ROSE : u32 = 11 ; pub const PF_DECnet : u32 = 12 ; pub const PF_NETBEUI : u32 = 13 ; pub const PF_SECURITY : u32 = 14 ; pub const PF_KEY : u32 = 15 ; pub const PF_NETLINK : u32 = 16 ; pub const PF_ROUTE : u32 = 16 ; pub const PF_PACKET : u32 = 17 ; pub const PF_ASH : u32 = 18 ; pub const PF_ECONET : u32 = 19 ; pub const PF_ATMSVC : u32 = 20 ; pub const PF_RDS : u32 = 21 ; pub const PF_SNA : u32 = 22 ; pub const PF_IRDA : u32 = 23 ; pub const PF_PPPOX : u32 = 24 ; pub const PF_WANPIPE : u32 = 25 ; pub const PF_LLC : u32 = 26 ; pub const PF_IB : u32 = 27 ; pub const PF_MPLS : u32 = 28 ; pub const PF_CAN : u32 = 29 ; pub const PF_TIPC : u32 = 30 ; pub const PF_BLUETOOTH : u32 = 31 ; pub const PF_IUCV : u32 = 32 ; pub const PF_RXRPC : u32 = 33 ; pub const PF_ISDN : u32 = 34 ; pub const PF_PHONET : u32 = 35 ; pub const PF_IEEE802154 : u32 = 36 ; pub const PF_CAIF : u32 = 37 ; pub const PF_ALG : u32 = 38 ; pub const PF_NFC : u32 = 39 ; pub const PF_VSOCK : u32 = 40 ; pub const PF_MAX : u32 = 41 ; pub const AF_UNSPEC : u32 = 0 ; pub const AF_LOCAL : u32 = 1 ; pub const AF_UNIX : u32 = 1 ; pub const AF_FILE : u32 = 1 ; pub const AF_INET : u32 = 2 ; pub const AF_AX25 : u32 = 3 ; pub const AF_IPX : u32 = 4 ; pub const AF_APPLETALK : u32 = 5 ; pub const AF_NETROM : u32 = 6 ; pub const AF_BRIDGE : u32 = 7 ; pub const AF_ATMPVC : u32 = 8 ; pub const AF_X25 : u32 = 9 ; pub const AF_INET6 : u32 = 10 ; pub const AF_ROSE : u32 = 11 ; pub const AF_DECnet : u32 = 12 ; pub const AF_NETBEUI : u32 = 13 ; pub const AF_SECURITY : u32 = 14 ; pub const AF_KEY : u32 = 15 ; pub const AF_NETLINK : u32 = 16 ; pub const AF_ROUTE : u32 = 16 ; pub const AF_PACKET : u32 = 17 ; pub const AF_ASH : u32 = 18 ; pub const AF_ECONET : u32 = 19 ; pub const AF_ATMSVC : u32 = 20 ; pub const AF_RDS : u32 = 21 ; pub const AF_SNA : u32 = 22 ; pub const AF_IRDA : u32 = 23 ; pub const AF_PPPOX : u32 = 24 ; pub const AF_WANPIPE : u32 = 25 ; pub const AF_LLC : u32 = 26 ; pub const AF_IB : u32 = 27 ; pub const AF_MPLS : u32 = 28 ; pub const AF_CAN : u32 = 29 ; pub const AF_TIPC : u32 = 30 ; pub const AF_BLUETOOTH : u32 = 31 ; pub const AF_IUCV : u32 = 32 ; pub const AF_RXRPC : u32 = 33 ; pub const AF_ISDN : u32 = 34 ; pub const AF_PHONET : u32 = 35 ; pub const AF_IEEE802154 : u32 = 36 ; pub const AF_CAIF : u32 = 37 ; pub const AF_ALG : u32 = 38 ; pub const AF_NFC : u32 = 39 ; pub const AF_VSOCK : u32 = 40 ; pub const AF_MAX : u32 = 41 ; pub const SOL_RAW : u32 = 255 ; pub const SOL_DECNET : u32 = 261 ; pub const SOL_X25 : u32 = 262 ; pub const SOL_PACKET : u32 = 263 ; pub const SOL_ATM : u32 = 264 ; pub const SOL_AAL : u32 = 265 ; pub const SOL_IRDA : u32 = 266 ; pub const SOMAXCONN : u32 = 128 ; pub const _BITS_SOCKADDR_H : u32 = 1 ; pub const _SS_SIZE : u32 = 128 ; pub const FIOSETOWN : u32 = 35073 ; pub const SIOCSPGRP : u32 = 35074 ; pub const FIOGETOWN : u32 = 35075 ; pub const SIOCGPGRP : u32 = 35076 ; pub const SIOCATMARK : u32 = 35077 ; pub const SIOCGSTAMP : u32 = 35078 ; pub const SIOCGSTAMPNS : u32 = 35079 ; pub const SOL_SOCKET : u32 = 1 ; pub const SO_DEBUG : u32 = 1 ; pub const SO_REUSEADDR : u32 = 2 ; pub const SO_TYPE : u32 = 3 ; pub const SO_ERROR : u32 = 4 ; pub const SO_DONTROUTE : u32 = 5 ; pub const SO_BROADCAST : u32 = 6 ; pub const SO_SNDBUF : u32 = 7 ; pub const SO_RCVBUF : u32 = 8 ; pub const SO_SNDBUFFORCE : u32 = 32 ; pub const SO_RCVBUFFORCE : u32 = 33 ; pub const SO_KEEPALIVE : u32 = 9 ; pub const SO_OOBINLINE : u32 = 10 ; pub const SO_NO_CHECK : u32 = 11 ; pub const SO_PRIORITY : u32 = 12 ; pub const SO_LINGER : u32 = 13 ; pub const SO_BSDCOMPAT : u32 = 14 ; pub const SO_REUSEPORT : u32 = 15 ; pub const SO_PASSCRED : u32 = 16 ; pub const SO_PEERCRED : u32 = 17 ; pub const SO_RCVLOWAT : u32 = 18 ; pub const SO_SNDLOWAT : u32 = 19 ; pub const SO_RCVTIMEO : u32 = 20 ; pub const SO_SNDTIMEO : u32 = 21 ; pub const SO_SECURITY_AUTHENTICATION : u32 = 22 ; pub const SO_SECURITY_ENCRYPTION_TRANSPORT : u32 = 23 ; pub const SO_SECURITY_ENCRYPTION_NETWORK : u32 = 24 ; pub const SO_BINDTODEVICE : u32 = 25 ; pub const SO_ATTACH_FILTER : u32 = 26 ; pub const SO_DETACH_FILTER : u32 = 27 ; pub const SO_GET_FILTER : u32 = 26 ; pub const SO_PEERNAME : u32 = 28 ; pub const SO_TIMESTAMP : u32 = 29 ; pub const SCM_TIMESTAMP : u32 = 29 ; pub const SO_ACCEPTCONN : u32 = 30 ; pub const SO_PEERSEC : u32 = 31 ; pub const SO_PASSSEC : u32 = 34 ; pub const SO_TIMESTAMPNS : u32 = 35 ; pub const SCM_TIMESTAMPNS : u32 = 35 ; pub const SO_MARK : u32 = 36 ; pub const SO_TIMESTAMPING : u32 = 37 ; pub const SCM_TIMESTAMPING : u32 = 37 ; pub const SO_PROTOCOL : u32 = 38 ; pub const SO_DOMAIN : u32 = 39 ; pub const SO_RXQ_OVFL : u32 = 40 ; pub const SO_WIFI_STATUS : u32 = 41 ; pub const SCM_WIFI_STATUS : u32 = 41 ; pub const SO_PEEK_OFF : u32 = 42 ; pub const SO_NOFCS : u32 = 43 ; pub const SO_LOCK_FILTER : u32 = 44 ; pub const SO_SELECT_ERR_QUEUE : u32 = 45 ; pub const SO_BUSY_POLL : u32 = 46 ; pub const SO_MAX_PACING_RATE : u32 = 47 ; pub const SO_BPF_EXTENSIONS : u32 = 48 ; pub const SO_INCOMING_CPU : u32 = 49 ; pub const SO_ATTACH_BPF : u32 = 50 ; pub const SO_DETACH_BPF : u32 = 27 ; pub const IP_OPTIONS : u32 = 4 ; pub const IP_HDRINCL : u32 = 3 ; pub const IP_TOS : u32 = 1 ; pub const IP_TTL : u32 = 2 ; pub const IP_RECVOPTS : u32 = 6 ; pub const IP_RETOPTS : u32 = 7 ; pub const IP_MULTICAST_IF : u32 = 32 ; pub const IP_MULTICAST_TTL : u32 = 33 ; pub const IP_MULTICAST_LOOP : u32 = 34 ; pub const IP_ADD_MEMBERSHIP : u32 = 35 ; pub const IP_DROP_MEMBERSHIP : u32 = 36 ; pub const IP_UNBLOCK_SOURCE : u32 = 37 ; pub const IP_BLOCK_SOURCE : u32 = 38 ; pub const IP_ADD_SOURCE_MEMBERSHIP : u32 = 39 ; pub const IP_DROP_SOURCE_MEMBERSHIP : u32 = 40 ; pub const IP_MSFILTER : u32 = 41 ; pub const MCAST_JOIN_GROUP : u32 = 42 ; pub const MCAST_BLOCK_SOURCE : u32 = 43 ; pub const MCAST_UNBLOCK_SOURCE : u32 = 44 ; pub const MCAST_LEAVE_GROUP : u32 = 45 ; pub const MCAST_JOIN_SOURCE_GROUP : u32 = 46 ; pub const MCAST_LEAVE_SOURCE_GROUP : u32 = 47 ; pub const MCAST_MSFILTER : u32 = 48 ; pub const IP_MULTICAST_ALL : u32 = 49 ; pub const IP_UNICAST_IF : u32 = 50 ; pub const MCAST_EXCLUDE : u32 = 0 ; pub const MCAST_INCLUDE : u32 = 1 ; pub const IP_ROUTER_ALERT : u32 = 5 ; pub const IP_PKTINFO : u32 = 8 ; pub const IP_PKTOPTIONS : u32 = 9 ; pub const IP_PMTUDISC : u32 = 10 ; pub const IP_MTU_DISCOVER : u32 = 10 ; pub const IP_RECVERR : u32 = 11 ; pub const IP_RECVTTL : u32 = 12 ; pub const IP_RECVTOS : u32 = 13 ; pub const IP_MTU : u32 = 14 ; pub const IP_FREEBIND : u32 = 15 ; pub const IP_IPSEC_POLICY : u32 = 16 ; pub const IP_XFRM_POLICY : u32 = 17 ; pub const IP_PASSSEC : u32 = 18 ; pub const IP_TRANSPARENT : u32 = 19 ; pub const IP_ORIGDSTADDR : u32 = 20 ; pub const IP_RECVORIGDSTADDR : u32 = 20 ; pub const IP_MINTTL : u32 = 21 ; pub const IP_NODEFRAG : u32 = 22 ; pub const IP_CHECKSUM : u32 = 23 ; pub const IP_BIND_ADDRESS_NO_PORT : u32 = 24 ; pub const IP_PMTUDISC_DONT : u32 = 0 ; pub const IP_PMTUDISC_WANT : u32 = 1 ; pub const IP_PMTUDISC_DO : u32 = 2 ; pub const IP_PMTUDISC_PROBE : u32 = 3 ; pub const IP_PMTUDISC_INTERFACE : u32 = 4 ; pub const IP_PMTUDISC_OMIT : u32 = 5 ; pub const SOL_IP : u32 = 0 ; pub const IP_DEFAULT_MULTICAST_TTL : u32 = 1 ; pub const IP_DEFAULT_MULTICAST_LOOP : u32 = 1 ; pub const IP_MAX_MEMBERSHIPS : u32 = 20 ; pub const IPV6_ADDRFORM : u32 = 1 ; pub const IPV6_2292PKTINFO : u32 = 2 ; pub const IPV6_2292HOPOPTS : u32 = 3 ; pub const IPV6_2292DSTOPTS : u32 = 4 ; pub const IPV6_2292RTHDR : u32 = 5 ; pub const IPV6_2292PKTOPTIONS : u32 = 6 ; pub const IPV6_CHECKSUM : u32 = 7 ; pub const IPV6_2292HOPLIMIT : u32 = 8 ; pub const IPV6_NEXTHOP : u32 = 9 ; pub const IPV6_AUTHHDR : u32 = 10 ; pub const IPV6_UNICAST_HOPS : u32 = 16 ; pub const IPV6_MULTICAST_IF : u32 = 17 ; pub const IPV6_MULTICAST_HOPS : u32 = 18 ; pub const IPV6_MULTICAST_LOOP : u32 = 19 ; pub const IPV6_JOIN_GROUP : u32 = 20 ; pub const IPV6_LEAVE_GROUP : u32 = 21 ; pub const IPV6_ROUTER_ALERT : u32 = 22 ; pub const IPV6_MTU_DISCOVER : u32 = 23 ; pub const IPV6_MTU : u32 = 24 ; pub const IPV6_RECVERR : u32 = 25 ; pub const IPV6_V6ONLY : u32 = 26 ; pub const IPV6_JOIN_ANYCAST : u32 = 27 ; pub const IPV6_LEAVE_ANYCAST : u32 = 28 ; pub const IPV6_IPSEC_POLICY : u32 = 34 ; pub const IPV6_XFRM_POLICY : u32 = 35 ; pub const IPV6_RECVPKTINFO : u32 = 49 ; pub const IPV6_PKTINFO : u32 = 50 ; pub const IPV6_RECVHOPLIMIT : u32 = 51 ; pub const IPV6_HOPLIMIT : u32 = 52 ; pub const IPV6_RECVHOPOPTS : u32 = 53 ; pub const IPV6_HOPOPTS : u32 = 54 ; pub const IPV6_RTHDRDSTOPTS : u32 = 55 ; pub const IPV6_RECVRTHDR : u32 = 56 ; pub const IPV6_RTHDR : u32 = 57 ; pub const IPV6_RECVDSTOPTS : u32 = 58 ; pub const IPV6_DSTOPTS : u32 = 59 ; pub const IPV6_RECVPATHMTU : u32 = 60 ; pub const IPV6_PATHMTU : u32 = 61 ; pub const IPV6_DONTFRAG : u32 = 62 ; pub const IPV6_RECVTCLASS : u32 = 66 ; pub const IPV6_TCLASS : u32 = 67 ; pub const IPV6_ADD_MEMBERSHIP : u32 = 20 ; pub const IPV6_DROP_MEMBERSHIP : u32 = 21 ; pub const IPV6_RXHOPOPTS : u32 = 54 ; pub const IPV6_RXDSTOPTS : u32 = 59 ; pub const IPV6_PMTUDISC_DONT : u32 = 0 ; pub const IPV6_PMTUDISC_WANT : u32 = 1 ; pub const IPV6_PMTUDISC_DO : u32 = 2 ; pub const IPV6_PMTUDISC_PROBE : u32 = 3 ; pub const IPV6_PMTUDISC_INTERFACE : u32 = 4 ; pub const IPV6_PMTUDISC_OMIT : u32 = 5 ; pub const SOL_IPV6 : u32 = 41 ; pub const SOL_ICMPV6 : u32 = 58 ; pub const IPV6_RTHDR_LOOSE : u32 = 0 ; pub const IPV6_RTHDR_STRICT : u32 = 1 ; pub const IPV6_RTHDR_TYPE_0 : u32 = 0 ; pub const IN_CLASSA_NET : u32 = 4278190080 ; pub const IN_CLASSA_NSHIFT : u32 = 24 ; pub const IN_CLASSA_HOST : u32 = 16777215 ; pub const IN_CLASSA_MAX : u32 = 128 ; pub const IN_CLASSB_NET : u32 = 4294901760 ; pub const IN_CLASSB_NSHIFT : u32 = 16 ; pub const IN_CLASSB_HOST : u32 = 65535 ; pub const IN_CLASSB_MAX : u32 = 65536 ; pub const IN_CLASSC_NET : u32 = 4294967040 ; pub const IN_CLASSC_NSHIFT : u32 = 8 ; pub const IN_CLASSC_HOST : u32 = 255 ; pub const IN_LOOPBACKNET : u32 = 127 ; pub const INET_ADDRSTRLEN : u32 = 16 ; pub const INET6_ADDRSTRLEN : u32 = 46 ; pub const _ASSERT_H : u32 = 1 ; pub const ASN1C_ENVIRONMENT_VERSION : u32 = 923 ; pub const asn_debug_indent : u32 = 0 ; pub const _ASN_DEFAULT_STACK_MAX : u32 = 30000 ; pub type __u_char = :: std :: os :: raw :: c_uchar ; pub type __u_short = :: std :: os :: raw :: c_ushort ; pub type __u_int = :: std :: os :: raw :: c_uint ; pub type __u_long = :: std :: os :: raw :: c_ulong ; pub type __int8_t = :: std :: os :: raw :: c_schar ; pub type __uint8_t = :: std :: os :: raw :: c_uchar ; pub type __int16_t = :: std :: os :: raw :: c_short ; pub type __uint16_t = :: std :: os :: raw :: c_ushort ; pub type __int32_t = :: std :: os :: raw :: c_int ; pub type __uint32_t = :: std :: os :: raw :: c_uint ; pub type __int64_t = :: std :: os :: raw :: c_long ; pub type __uint64_t = :: std :: os :: raw :: c_ulong ; pub type __quad_t = :: std :: os :: raw :: c_long ; pub type __u_quad_t = :: std :: os :: raw :: c_ulong ; pub type __dev_t = :: std :: os :: raw :: c_ulong ; pub type __uid_t = :: std :: os :: raw :: c_uint ; pub type __gid_t = :: std :: os :: raw :: c_uint ; pub type __ino_t = :: std :: os :: raw :: c_ulong ; pub type __ino64_t = :: std :: os :: raw :: c_ulong ; pub type __mode_t = :: std :: os :: raw :: c_uint ; pub type __nlink_t = :: std :: os :: raw :: c_ulong ; pub type __off_t = :: std :: os :: raw :: c_long ; pub type __off64_t = :: std :: os :: raw :: c_long ; pub type __pid_t = :: std :: os :: raw :: c_int ; # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct __fsid_t { pub __val : [ :: std :: os :: raw :: c_int ; 2usize ] , } # [ test ] fn bindgen_test_layout___fsid_t ( ) { assert_eq ! ( :: std :: mem :: size_of :: < __fsid_t > ( ) , 8usize , concat ! ( "Size of: " , stringify ! ( __fsid_t ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < __fsid_t > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( __fsid_t ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < __fsid_t > ( ) ) ) . __val as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( __fsid_t ) , "::" , stringify ! ( __val ) ) ) ; } pub type __clock_t = :: std :: os :: raw :: c_long ; pub type __rlim_t = :: std :: os :: raw :: c_ulong ; pub type __rlim64_t = :: std :: os :: raw :: c_ulong ; pub type __id_t = :: std :: os :: raw :: c_uint ; pub type __time_t = :: std :: os :: raw :: c_long ; pub type __useconds_t = :: std :: os :: raw :: c_uint ; pub type __suseconds_t = :: std :: os :: raw :: c_long ; pub type __daddr_t = :: std :: os :: raw :: c_int ; pub type __key_t = :: std :: os :: raw :: c_int ; pub type __clockid_t = :: std :: os :: raw :: c_int ; pub type __timer_t = * mut :: std :: os :: raw :: c_void ; pub type __blksize_t = :: std :: os :: raw :: c_long ; pub type __blkcnt_t = :: std :: os :: raw :: c_long ; pub type __blkcnt64_t = :: std :: os :: raw :: c_long ; pub type __fsblkcnt_t = :: std :: os :: raw :: c_ulong ; pub type __fsblkcnt64_t = :: std :: os :: raw :: c_ulong ; pub type __fsfilcnt_t = :: std :: os :: raw :: c_ulong ; pub type __fsfilcnt64_t = :: std :: os :: raw :: c_ulong ; pub type __fsword_t = :: std :: os :: raw :: c_long ; pub type __ssize_t = :: std :: os :: raw :: c_long ; pub type __syscall_slong_t = :: std :: os :: raw :: c_long ; pub type __syscall_ulong_t = :: std :: os :: raw :: c_ulong ; pub type __loff_t = __off64_t ; pub type __qaddr_t = * mut __quad_t ; pub type __caddr_t = * mut :: std :: os :: raw :: c_char ; pub type __intptr_t = :: std :: os :: raw :: c_long ; pub type __socklen_t = :: std :: os :: raw :: c_uint ; pub type FILE = _IO_FILE ; pub type __FILE = _IO_FILE ; # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub struct __mbstate_t { pub __count : :: std :: os :: raw :: c_int , pub __value : __mbstate_t__bindgen_ty_1 , } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union __mbstate_t__bindgen_ty_1 { pub __wch : :: std :: os :: raw :: c_uint , pub __wchb : [ :: std :: os :: raw :: c_char ; 4usize ] , _bindgen_union_align : u32 , } # [ test ] fn bindgen_test_layout___mbstate_t__bindgen_ty_1 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < __mbstate_t__bindgen_ty_1 > ( ) , 4usize , concat ! ( "Size of: " , stringify ! ( __mbstate_t__bindgen_ty_1 ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < __mbstate_t__bindgen_ty_1 > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( __mbstate_t__bindgen_ty_1 ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < __mbstate_t__bindgen_ty_1 > ( ) ) ) . __wch as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( __mbstate_t__bindgen_ty_1 ) , "::" , stringify ! ( __wch ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < __mbstate_t__bindgen_ty_1 > ( ) ) ) . __wchb as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( __mbstate_t__bindgen_ty_1 ) , "::" , stringify ! ( __wchb ) ) ) ; } # [ test ] fn bindgen_test_layout___mbstate_t ( ) { assert_eq ! ( :: std :: mem :: size_of :: < __mbstate_t > ( ) , 8usize , concat ! ( "Size of: " , stringify ! ( __mbstate_t ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < __mbstate_t > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( __mbstate_t ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < __mbstate_t > ( ) ) ) . __count as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( __mbstate_t ) , "::" , stringify ! ( __count ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < __mbstate_t > ( ) ) ) . __value as * const _ as usize } , 4usize , concat ! ( "Offset of field: " , stringify ! ( __mbstate_t ) , "::" , stringify ! ( __value ) ) ) ; } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub struct _G_fpos_t { pub __pos : __off_t , pub __state : __mbstate_t , } # [ test ] fn bindgen_test_layout__G_fpos_t ( ) { assert_eq ! ( :: std :: mem :: size_of :: < _G_fpos_t > ( ) , 16usize , concat ! ( "Size of: " , stringify ! ( _G_fpos_t ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < _G_fpos_t > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( _G_fpos_t ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < _G_fpos_t > ( ) ) ) . __pos as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( _G_fpos_t ) , "::" , stringify ! ( __pos ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < _G_fpos_t > ( ) ) ) . __state as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( _G_fpos_t ) , "::" , stringify ! ( __state ) ) ) ; } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub struct _G_fpos64_t { pub __pos : __off64_t , pub __state : __mbstate_t , } # [ test ] fn bindgen_test_layout__G_fpos64_t ( ) { assert_eq ! ( :: std :: mem :: size_of :: < _G_fpos64_t > ( ) , 16usize , concat ! ( "Size of: " , stringify ! ( _G_fpos64_t ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < _G_fpos64_t > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( _G_fpos64_t ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < _G_fpos64_t > ( ) ) ) . __pos as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( _G_fpos64_t ) , "::" , stringify ! ( __pos ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < _G_fpos64_t > ( ) ) ) . __state as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( _G_fpos64_t ) , "::" , stringify ! ( __state ) ) ) ; } pub type va_list = __builtin_va_list ; pub type __gnuc_va_list = __builtin_va_list ; # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct _IO_jump_t { _unused : [ u8 ; 0 ] , } pub type _IO_lock_t = :: std :: os :: raw :: c_void ; # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct _IO_marker { pub _next : * mut _IO_marker , pub _sbuf : * mut _IO_FILE , pub _pos : :: std :: os :: raw :: c_int , } # [ test ] fn bindgen_test_layout__IO_marker ( ) { assert_eq ! ( :: std :: mem :: size_of :: < _IO_marker > ( ) , 24usize , concat ! ( "Size of: " , stringify ! ( _IO_marker ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < _IO_marker > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( _IO_marker ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < _IO_marker > ( ) ) ) . _next as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( _IO_marker ) , "::" , stringify ! ( _next ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < _IO_marker > ( ) ) ) . _sbuf as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( _IO_marker ) , "::" , stringify ! ( _sbuf ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < _IO_marker > ( ) ) ) . _pos as * const _ as usize } , 16usize , concat ! ( "Offset of field: " , stringify ! ( _IO_marker ) , "::" , stringify ! ( _pos ) ) ) ; } pub const __codecvt_result___codecvt_ok : __codecvt_result = 0 ; pub const __codecvt_result___codecvt_partial : __codecvt_result = 1 ; pub const __codecvt_result___codecvt_error : __codecvt_result = 2 ; pub const __codecvt_result___codecvt_noconv : __codecvt_result = 3 ; pub type __codecvt_result = u32 ; # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct _IO_FILE { pub _flags : :: std :: os :: raw :: c_int , pub _IO_read_ptr : * mut :: std :: os :: raw :: c_char , pub _IO_read_end : * mut :: std :: os :: raw :: c_char , pub _IO_read_base : * mut :: std :: os :: raw :: c_char , pub _IO_write_base : * mut :: std :: os :: raw :: c_char , pub _IO_write_ptr : * mut :: std :: os :: raw :: c_char , pub _IO_write_end : * mut :: std :: os :: raw :: c_char , pub _IO_buf_base : * mut :: std :: os :: raw :: c_char , pub _IO_buf_end : * mut :: std :: os :: raw :: c_char , pub _IO_save_base : * mut :: std :: os :: raw :: c_char , pub _IO_backup_base : * mut :: std :: os :: raw :: c_char , pub _IO_save_end : * mut :: std :: os :: raw :: c_char , pub _markers : * mut _IO_marker , pub _chain : * mut _IO_FILE , pub _fileno : :: std :: os :: raw :: c_int , pub _flags2 : :: std :: os :: raw :: c_int , pub _old_offset : __off_t , pub _cur_column : :: std :: os :: raw :: c_ushort , pub _vtable_offset : :: std :: os :: raw :: c_schar , pub _shortbuf : [ :: std :: os :: raw :: c_char ; 1usize ] , pub _lock : * mut _IO_lock_t , pub _offset : __off64_t , pub __pad1 : * mut :: std :: os :: raw :: c_void , pub __pad2 : * mut :: std :: os :: raw :: c_void , pub __pad3 : * mut :: std :: os :: raw :: c_void , pub __pad4 : * mut :: std :: os :: raw :: c_void , pub __pad5 : usize , pub _mode : :: std :: os :: raw :: c_int , pub _unused2 : [ :: std :: os :: raw :: c_char ; 20usize ] , } # [ test ] fn bindgen_test_layout__IO_FILE ( ) { assert_eq ! ( :: std :: mem :: size_of :: < _IO_FILE > ( ) , 216usize , concat ! ( "Size of: " , stringify ! ( _IO_FILE ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < _IO_FILE > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( _IO_FILE ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < _IO_FILE > ( ) ) ) . _flags as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( _IO_FILE ) , "::" , stringify ! ( _flags ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < _IO_FILE > ( ) ) ) . _IO_read_ptr as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( _IO_FILE ) , "::" , stringify ! ( _IO_read_ptr ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < _IO_FILE > ( ) ) ) . _IO_read_end as * const _ as usize } , 16usize , concat ! ( "Offset of field: " , stringify ! ( _IO_FILE ) , "::" , stringify ! ( _IO_read_end ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < _IO_FILE > ( ) ) ) . _IO_read_base as * const _ as usize } , 24usize , concat ! ( "Offset of field: " , stringify ! ( _IO_FILE ) , "::" , stringify ! ( _IO_read_base ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < _IO_FILE > ( ) ) ) . _IO_write_base as * const _ as usize } , 32usize , concat ! ( "Offset of field: " , stringify ! ( _IO_FILE ) , "::" , stringify ! ( _IO_write_base ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < _IO_FILE > ( ) ) ) . _IO_write_ptr as * const _ as usize } , 40usize , concat ! ( "Offset of field: " , stringify ! ( _IO_FILE ) , "::" , stringify ! ( _IO_write_ptr ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < _IO_FILE > ( ) ) ) . _IO_write_end as * const _ as usize } , 48usize , concat ! ( "Offset of field: " , stringify ! ( _IO_FILE ) , "::" , stringify ! ( _IO_write_end ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < _IO_FILE > ( ) ) ) . _IO_buf_base as * const _ as usize } , 56usize , concat ! ( "Offset of field: " , stringify ! ( _IO_FILE ) , "::" , stringify ! ( _IO_buf_base ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < _IO_FILE > ( ) ) ) . _IO_buf_end as * const _ as usize } , 64usize , concat ! ( "Offset of field: " , stringify ! ( _IO_FILE ) , "::" , stringify ! ( _IO_buf_end ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < _IO_FILE > ( ) ) ) . _IO_save_base as * const _ as usize } , 72usize , concat ! ( "Offset of field: " , stringify ! ( _IO_FILE ) , "::" , stringify ! ( _IO_save_base ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < _IO_FILE > ( ) ) ) . _IO_backup_base as * const _ as usize } , 80usize , concat ! ( "Offset of field: " , stringify ! ( _IO_FILE ) , "::" , stringify ! ( _IO_backup_base ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < _IO_FILE > ( ) ) ) . _IO_save_end as * const _ as usize } , 88usize , concat ! ( "Offset of field: " , stringify ! ( _IO_FILE ) , "::" , stringify ! ( _IO_save_end ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < _IO_FILE > ( ) ) ) . _markers as * const _ as usize } , 96usize , concat ! ( "Offset of field: " , stringify ! ( _IO_FILE ) , "::" , stringify ! ( _markers ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < _IO_FILE > ( ) ) ) . _chain as * const _ as usize } , 104usize , concat ! ( "Offset of field: " , stringify ! ( _IO_FILE ) , "::" , stringify ! ( _chain ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < _IO_FILE > ( ) ) ) . _fileno as * const _ as usize } , 112usize , concat ! ( "Offset of field: " , stringify ! ( _IO_FILE ) , "::" , stringify ! ( _fileno ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < _IO_FILE > ( ) ) ) . _flags2 as * const _ as usize } , 116usize , concat ! ( "Offset of field: " , stringify ! ( _IO_FILE ) , "::" , stringify ! ( _flags2 ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < _IO_FILE > ( ) ) ) . _old_offset as * const _ as usize } , 120usize , concat ! ( "Offset of field: " , stringify ! ( _IO_FILE ) , "::" , stringify ! ( _old_offset ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < _IO_FILE > ( ) ) ) . _cur_column as * const _ as usize } , 128usize , concat ! ( "Offset of field: " , stringify ! ( _IO_FILE ) , "::" , stringify ! ( _cur_column ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < _IO_FILE > ( ) ) ) . _vtable_offset as * const _ as usize } , 130usize , concat ! ( "Offset of field: " , stringify ! ( _IO_FILE ) , "::" , stringify ! ( _vtable_offset ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < _IO_FILE > ( ) ) ) . _shortbuf as * const _ as usize } , 131usize , concat ! ( "Offset of field: " , stringify ! ( _IO_FILE ) , "::" , stringify ! ( _shortbuf ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < _IO_FILE > ( ) ) ) . _lock as * const _ as usize } , 136usize , concat ! ( "Offset of field: " , stringify ! ( _IO_FILE ) , "::" , stringify ! ( _lock ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < _IO_FILE > ( ) ) ) . _offset as * const _ as usize } , 144usize , concat ! ( "Offset of field: " , stringify ! ( _IO_FILE ) , "::" , stringify ! ( _offset ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < _IO_FILE > ( ) ) ) . __pad1 as * const _ as usize } , 152usize , concat ! ( "Offset of field: " , stringify ! ( _IO_FILE ) , "::" , stringify ! ( __pad1 ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < _IO_FILE > ( ) ) ) . __pad2 as * const _ as usize } , 160usize , concat ! ( "Offset of field: " , stringify ! ( _IO_FILE ) , "::" , stringify ! ( __pad2 ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < _IO_FILE > ( ) ) ) . __pad3 as * const _ as usize } , 168usize , concat ! ( "Offset of field: " , stringify ! ( _IO_FILE ) , "::" , stringify ! ( __pad3 ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < _IO_FILE > ( ) ) ) . __pad4 as * const _ as usize } , 176usize , concat ! ( "Offset of field: " , stringify ! ( _IO_FILE ) , "::" , stringify ! ( __pad4 ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < _IO_FILE > ( ) ) ) . __pad5 as * const _ as usize } , 184usize , concat ! ( "Offset of field: " , stringify ! ( _IO_FILE ) , "::" , stringify ! ( __pad5 ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < _IO_FILE > ( ) ) ) . _mode as * const _ as usize } , 192usize , concat ! ( "Offset of field: " , stringify ! ( _IO_FILE ) , "::" , stringify ! ( _mode ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < _IO_FILE > ( ) ) ) . _unused2 as * const _ as usize } , 196usize , concat ! ( "Offset of field: " , stringify ! ( _IO_FILE ) , "::" , stringify ! ( _unused2 ) ) ) ; } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct _IO_FILE_plus { _unused : [ u8 ; 0 ] , } extern "C" { # [ link_name = "\u{1}_IO_2_1_stdin_" ] pub static mut _IO_2_1_stdin_ : _IO_FILE_plus ; } extern "C" { # [ link_name = "\u{1}_IO_2_1_stdout_" ] pub static mut _IO_2_1_stdout_ : _IO_FILE_plus ; } extern "C" { # [ link_name = "\u{1}_IO_2_1_stderr_" ] pub static mut _IO_2_1_stderr_ : _IO_FILE_plus ; } pub type __io_read_fn = :: std :: option :: Option < unsafe extern "C" fn ( __cookie : * mut :: std :: os :: raw :: c_void , __buf : * mut :: std :: os :: raw :: c_char , __nbytes : usize ) -> __ssize_t > ; pub type __io_write_fn = :: std :: option :: Option < unsafe extern "C" fn ( __cookie : * mut :: std :: os :: raw :: c_void , __buf : * const :: std :: os :: raw :: c_char , __n : usize ) -> __ssize_t > ; pub type __io_seek_fn = :: std :: option :: Option < unsafe extern "C" fn ( __cookie : * mut :: std :: os :: raw :: c_void , __pos : * mut __off64_t , __w : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int > ; pub type __io_close_fn = :: std :: option :: Option < unsafe extern "C" fn ( __cookie : * mut :: std :: os :: raw :: c_void ) -> :: std :: os :: raw :: c_int > ; extern "C" { pub fn __underflow ( arg1 : * mut _IO_FILE ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn __uflow ( arg1 : * mut _IO_FILE ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn __overflow ( arg1 : * mut _IO_FILE , arg2 : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn _IO_getc ( __fp : * mut _IO_FILE ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn _IO_putc ( __c : :: std :: os :: raw :: c_int , __fp : * mut _IO_FILE ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn _IO_feof ( __fp : * mut _IO_FILE ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn _IO_ferror ( __fp : * mut _IO_FILE ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn _IO_peekc_locked ( __fp : * mut _IO_FILE ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn _IO_flockfile ( arg1 : * mut _IO_FILE ) ; } extern "C" { pub fn _IO_funlockfile ( arg1 : * mut _IO_FILE ) ; } extern "C" { pub fn _IO_ftrylockfile ( arg1 : * mut _IO_FILE ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn _IO_vfscanf ( arg1 : * mut _IO_FILE , arg2 : * const :: std :: os :: raw :: c_char , arg3 : * mut __va_list_tag , arg4 : * mut :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn _IO_vfprintf ( arg1 : * mut _IO_FILE , arg2 : * const :: std :: os :: raw :: c_char , arg3 : * mut __va_list_tag ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn _IO_padn ( arg1 : * mut _IO_FILE , arg2 : :: std :: os :: raw :: c_int , arg3 : __ssize_t ) -> __ssize_t ; } extern "C" { pub fn _IO_sgetn ( arg1 : * mut _IO_FILE , arg2 : * mut :: std :: os :: raw :: c_void , arg3 : usize ) -> usize ; } extern "C" { pub fn _IO_seekoff ( arg1 : * mut _IO_FILE , arg2 : __off64_t , arg3 : :: std :: os :: raw :: c_int , arg4 : :: std :: os :: raw :: c_int ) -> __off64_t ; } extern "C" { pub fn _IO_seekpos ( arg1 : * mut _IO_FILE , arg2 : __off64_t , arg3 : :: std :: os :: raw :: c_int ) -> __off64_t ; } extern "C" { pub fn _IO_free_backup_area ( arg1 : * mut _IO_FILE ) ; } pub type off_t = __off_t ; pub type fpos_t = _G_fpos_t ; extern "C" { # [ link_name = "\u{1}stdin" ] pub static mut stdin : * mut _IO_FILE ; } extern "C" { # [ link_name = "\u{1}stdout" ] pub static mut stdout : * mut _IO_FILE ; } extern "C" { # [ link_name = "\u{1}stderr" ] pub static mut stderr : * mut _IO_FILE ; } extern "C" { pub fn remove ( __filename : * const :: std :: os :: raw :: c_char ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn rename ( __old : * const :: std :: os :: raw :: c_char , __new : * const :: std :: os :: raw :: c_char ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn renameat ( __oldfd : :: std :: os :: raw :: c_int , __old : * const :: std :: os :: raw :: c_char , __newfd : :: std :: os :: raw :: c_int , __new : * const :: std :: os :: raw :: c_char ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn tmpfile ( ) -> * mut FILE ; } extern "C" { pub fn tmpnam ( __s : * mut :: std :: os :: raw :: c_char ) -> * mut :: std :: os :: raw :: c_char ; } extern "C" { pub fn tmpnam_r ( __s : * mut :: std :: os :: raw :: c_char ) -> * mut :: std :: os :: raw :: c_char ; } extern "C" { pub fn tempnam ( __dir : * const :: std :: os :: raw :: c_char , __pfx : * const :: std :: os :: raw :: c_char ) -> * mut :: std :: os :: raw :: c_char ; } extern "C" { pub fn fclose ( __stream : * mut FILE ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn fflush ( __stream : * mut FILE ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn fflush_unlocked ( __stream : * mut FILE ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn fopen ( __filename : * const :: std :: os :: raw :: c_char , __modes : * const :: std :: os :: raw :: c_char ) -> * mut FILE ; } extern "C" { pub fn freopen ( __filename : * const :: std :: os :: raw :: c_char , __modes : * const :: std :: os :: raw :: c_char , __stream : * mut FILE ) -> * mut FILE ; } extern "C" { pub fn fdopen ( __fd : :: std :: os :: raw :: c_int , __modes : * const :: std :: os :: raw :: c_char ) -> * mut FILE ; } extern "C" { pub fn fmemopen ( __s : * mut :: std :: os :: raw :: c_void , __len : usize , __modes : * const :: std :: os :: raw :: c_char ) -> * mut FILE ; } extern "C" { pub fn open_memstream ( __bufloc : * mut * mut :: std :: os :: raw :: c_char , __sizeloc : * mut usize ) -> * mut FILE ; } extern "C" { pub fn setbuf ( __stream : * mut FILE , __buf : * mut :: std :: os :: raw :: c_char ) ; } extern "C" { pub fn setvbuf ( __stream : * mut FILE , __buf : * mut :: std :: os :: raw :: c_char , __modes : :: std :: os :: raw :: c_int , __n : usize ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn setbuffer ( __stream : * mut FILE , __buf : * mut :: std :: os :: raw :: c_char , __size : usize ) ; } extern "C" { pub fn setlinebuf ( __stream : * mut FILE ) ; } extern "C" { pub fn fprintf ( __stream : * mut FILE , __format : * const :: std :: os :: raw :: c_char , ... ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn printf ( __format : * const :: std :: os :: raw :: c_char , ... ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn sprintf ( __s : * mut :: std :: os :: raw :: c_char , __format : * const :: std :: os :: raw :: c_char , ... ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn vfprintf ( __s : * mut FILE , __format : * const :: std :: os :: raw :: c_char , __arg : * mut __va_list_tag ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn vprintf ( __format : * const :: std :: os :: raw :: c_char , __arg : * mut __va_list_tag ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn vsprintf ( __s : * mut :: std :: os :: raw :: c_char , __format : * const :: std :: os :: raw :: c_char , __arg : * mut __va_list_tag ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn snprintf ( __s : * mut :: std :: os :: raw :: c_char , __maxlen : usize , __format : * const :: std :: os :: raw :: c_char , ... ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn vsnprintf ( __s : * mut :: std :: os :: raw :: c_char , __maxlen : usize , __format : * const :: std :: os :: raw :: c_char , __arg : * mut __va_list_tag ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn vdprintf ( __fd : :: std :: os :: raw :: c_int , __fmt : * const :: std :: os :: raw :: c_char , __arg : * mut __va_list_tag ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn dprintf ( __fd : :: std :: os :: raw :: c_int , __fmt : * const :: std :: os :: raw :: c_char , ... ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn fscanf ( __stream : * mut FILE , __format : * const :: std :: os :: raw :: c_char , ... ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn scanf ( __format : * const :: std :: os :: raw :: c_char , ... ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn sscanf ( __s : * const :: std :: os :: raw :: c_char , __format : * const :: std :: os :: raw :: c_char , ... ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}__isoc99_fscanf" ] pub fn fscanf1 ( __stream : * mut FILE , __format : * const :: std :: os :: raw :: c_char , ... ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}__isoc99_scanf" ] pub fn scanf1 ( __format : * const :: std :: os :: raw :: c_char , ... ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}__isoc99_sscanf" ] pub fn sscanf1 ( __s : * const :: std :: os :: raw :: c_char , __format : * const :: std :: os :: raw :: c_char , ... ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn vfscanf ( __s : * mut FILE , __format : * const :: std :: os :: raw :: c_char , __arg : * mut __va_list_tag ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn vscanf ( __format : * const :: std :: os :: raw :: c_char , __arg : * mut __va_list_tag ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn vsscanf ( __s : * const :: std :: os :: raw :: c_char , __format : * const :: std :: os :: raw :: c_char , __arg : * mut __va_list_tag ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}__isoc99_vfscanf" ] pub fn vfscanf1 ( __s : * mut FILE , __format : * const :: std :: os :: raw :: c_char , __arg : * mut __va_list_tag ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}__isoc99_vscanf" ] pub fn vscanf1 ( __format : * const :: std :: os :: raw :: c_char , __arg : * mut __va_list_tag ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}__isoc99_vsscanf" ] pub fn vsscanf1 ( __s : * const :: std :: os :: raw :: c_char , __format : * const :: std :: os :: raw :: c_char , __arg : * mut __va_list_tag ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn fgetc ( __stream : * mut FILE ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn getc ( __stream : * mut FILE ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn getchar ( ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn getc_unlocked ( __stream : * mut FILE ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn getchar_unlocked ( ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn fgetc_unlocked ( __stream : * mut FILE ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn fputc ( __c : :: std :: os :: raw :: c_int , __stream : * mut FILE ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn putc ( __c : :: std :: os :: raw :: c_int , __stream : * mut FILE ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn putchar ( __c : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn fputc_unlocked ( __c : :: std :: os :: raw :: c_int , __stream : * mut FILE ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn putc_unlocked ( __c : :: std :: os :: raw :: c_int , __stream : * mut FILE ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn putchar_unlocked ( __c : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn getw ( __stream : * mut FILE ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn putw ( __w : :: std :: os :: raw :: c_int , __stream : * mut FILE ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn fgets ( __s : * mut :: std :: os :: raw :: c_char , __n : :: std :: os :: raw :: c_int , __stream : * mut FILE ) -> * mut :: std :: os :: raw :: c_char ; } extern "C" { pub fn __getdelim ( __lineptr : * mut * mut :: std :: os :: raw :: c_char , __n : * mut usize , __delimiter : :: std :: os :: raw :: c_int , __stream : * mut FILE ) -> __ssize_t ; } extern "C" { pub fn getdelim ( __lineptr : * mut * mut :: std :: os :: raw :: c_char , __n : * mut usize , __delimiter : :: std :: os :: raw :: c_int , __stream : * mut FILE ) -> __ssize_t ; } extern "C" { pub fn getline ( __lineptr : * mut * mut :: std :: os :: raw :: c_char , __n : * mut usize , __stream : * mut FILE ) -> __ssize_t ; } extern "C" { pub fn fputs ( __s : * const :: std :: os :: raw :: c_char , __stream : * mut FILE ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn puts ( __s : * const :: std :: os :: raw :: c_char ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn ungetc ( __c : :: std :: os :: raw :: c_int , __stream : * mut FILE ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn fread ( __ptr : * mut :: std :: os :: raw :: c_void , __size : usize , __n : usize , __stream : * mut FILE ) -> usize ; } extern "C" { pub fn fwrite ( __ptr : * const :: std :: os :: raw :: c_void , __size : usize , __n : usize , __s : * mut FILE ) -> usize ; } extern "C" { pub fn fread_unlocked ( __ptr : * mut :: std :: os :: raw :: c_void , __size : usize , __n : usize , __stream : * mut FILE ) -> usize ; } extern "C" { pub fn fwrite_unlocked ( __ptr : * const :: std :: os :: raw :: c_void , __size : usize , __n : usize , __stream : * mut FILE ) -> usize ; } extern "C" { pub fn fseek ( __stream : * mut FILE , __off : :: std :: os :: raw :: c_long , __whence : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn ftell ( __stream : * mut FILE ) -> :: std :: os :: raw :: c_long ; } extern "C" { pub fn rewind ( __stream : * mut FILE ) ; } extern "C" { pub fn fseeko ( __stream : * mut FILE , __off : __off_t , __whence : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn ftello ( __stream : * mut FILE ) -> __off_t ; } extern "C" { pub fn fgetpos ( __stream : * mut FILE , __pos : * mut fpos_t ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn fsetpos ( __stream : * mut FILE , __pos : * const fpos_t ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn clearerr ( __stream : * mut FILE ) ; } extern "C" { pub fn feof ( __stream : * mut FILE ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn ferror ( __stream : * mut FILE ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn clearerr_unlocked ( __stream : * mut FILE ) ; } extern "C" { pub fn feof_unlocked ( __stream : * mut FILE ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn ferror_unlocked ( __stream : * mut FILE ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn perror ( __s : * const :: std :: os :: raw :: c_char ) ; } extern "C" { # [ link_name = "\u{1}sys_nerr" ] pub static mut sys_nerr : :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}sys_errlist" ] pub static mut sys_errlist : [ * const :: std :: os :: raw :: c_char ; 0usize ] ; } extern "C" { pub fn fileno ( __stream : * mut FILE ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn fileno_unlocked ( __stream : * mut FILE ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn popen ( __command : * const :: std :: os :: raw :: c_char , __modes : * const :: std :: os :: raw :: c_char ) -> * mut FILE ; } extern "C" { pub fn pclose ( __stream : * mut FILE ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn ctermid ( __s : * mut :: std :: os :: raw :: c_char ) -> * mut :: std :: os :: raw :: c_char ; } extern "C" { pub fn flockfile ( __stream : * mut FILE ) ; } extern "C" { pub fn ftrylockfile ( __stream : * mut FILE ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn funlockfile ( __stream : * mut FILE ) ; } pub type wchar_t = :: std :: os :: raw :: c_int ; pub const idtype_t_P_ALL : idtype_t = 0 ; pub const idtype_t_P_PID : idtype_t = 1 ; pub const idtype_t_P_PGID : idtype_t = 2 ; pub type idtype_t = u32 ; # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union wait { pub w_status : :: std :: os :: raw :: c_int , pub __wait_terminated : wait__bindgen_ty_1 , pub __wait_stopped : wait__bindgen_ty_2 , _bindgen_union_align : u32 , } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct wait__bindgen_ty_1 { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u8 > , pub __bindgen_align : [ u32 ; 0usize ] , } # [ test ] fn bindgen_test_layout_wait__bindgen_ty_1 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < wait__bindgen_ty_1 > ( ) , 4usize , concat ! ( "Size of: " , stringify ! ( wait__bindgen_ty_1 ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < wait__bindgen_ty_1 > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( wait__bindgen_ty_1 ) ) ) ; } impl wait__bindgen_ty_1 { # [ inline ] pub fn __w_termsig ( & self ) -> :: std :: os :: raw :: c_uint { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 7u8 ) as u32 ) } } # [ inline ] pub fn set___w_termsig ( & mut self , val : :: std :: os :: raw :: c_uint ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 7u8 , val as u64 ) } } # [ inline ] pub fn __w_coredump ( & self ) -> :: std :: os :: raw :: c_uint { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 7usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set___w_coredump ( & mut self , val : :: std :: os :: raw :: c_uint ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 7usize , 1u8 , val as u64 ) } } # [ inline ] pub fn __w_retcode ( & self ) -> :: std :: os :: raw :: c_uint { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 8usize , 8u8 ) as u32 ) } } # [ inline ] pub fn set___w_retcode ( & mut self , val : :: std :: os :: raw :: c_uint ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 8usize , 8u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( __w_termsig : :: std :: os :: raw :: c_uint , __w_coredump : :: std :: os :: raw :: c_uint , __w_retcode : :: std :: os :: raw :: c_uint ) -> __BindgenBitfieldUnit < [ u8 ; 4usize ] , u8 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u8 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 7u8 , { let __w_termsig : u32 = unsafe { :: std :: mem :: transmute ( __w_termsig ) } ; __w_termsig as u64 } ) ; __bindgen_bitfield_unit . set ( 7usize , 1u8 , { let __w_coredump : u32 = unsafe { :: std :: mem :: transmute ( __w_coredump ) } ; __w_coredump as u64 } ) ; __bindgen_bitfield_unit . set ( 8usize , 8u8 , { let __w_retcode : u32 = unsafe { :: std :: mem :: transmute ( __w_retcode ) } ; __w_retcode as u64 } ) ; __bindgen_bitfield_unit } } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct wait__bindgen_ty_2 { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u8 > , pub __bindgen_align : [ u32 ; 0usize ] , } # [ test ] fn bindgen_test_layout_wait__bindgen_ty_2 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < wait__bindgen_ty_2 > ( ) , 4usize , concat ! ( "Size of: " , stringify ! ( wait__bindgen_ty_2 ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < wait__bindgen_ty_2 > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( wait__bindgen_ty_2 ) ) ) ; } impl wait__bindgen_ty_2 { # [ inline ] pub fn __w_stopval ( & self ) -> :: std :: os :: raw :: c_uint { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 8u8 ) as u32 ) } } # [ inline ] pub fn set___w_stopval ( & mut self , val : :: std :: os :: raw :: c_uint ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 8u8 , val as u64 ) } } # [ inline ] pub fn __w_stopsig ( & self ) -> :: std :: os :: raw :: c_uint { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 8usize , 8u8 ) as u32 ) } } # [ inline ] pub fn set___w_stopsig ( & mut self , val : :: std :: os :: raw :: c_uint ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 8usize , 8u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( __w_stopval : :: std :: os :: raw :: c_uint , __w_stopsig : :: std :: os :: raw :: c_uint ) -> __BindgenBitfieldUnit < [ u8 ; 4usize ] , u8 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u8 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 8u8 , { let __w_stopval : u32 = unsafe { :: std :: mem :: transmute ( __w_stopval ) } ; __w_stopval as u64 } ) ; __bindgen_bitfield_unit . set ( 8usize , 8u8 , { let __w_stopsig : u32 = unsafe { :: std :: mem :: transmute ( __w_stopsig ) } ; __w_stopsig as u64 } ) ; __bindgen_bitfield_unit } } # [ test ] fn bindgen_test_layout_wait ( ) { assert_eq ! ( :: std :: mem :: size_of :: < wait > ( ) , 4usize , concat ! ( "Size of: " , stringify ! ( wait ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < wait > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( wait ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < wait > ( ) ) ) . w_status as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( wait ) , "::" , stringify ! ( w_status ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < wait > ( ) ) ) . __wait_terminated as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( wait ) , "::" , stringify ! ( __wait_terminated ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < wait > ( ) ) ) . __wait_stopped as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( wait ) , "::" , stringify ! ( __wait_stopped ) ) ) ; } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union __WAIT_STATUS { pub __uptr : * mut wait , pub __iptr : * mut :: std :: os :: raw :: c_int , _bindgen_union_align : u64 , } # [ test ] fn bindgen_test_layout___WAIT_STATUS ( ) { assert_eq ! ( :: std :: mem :: size_of :: < __WAIT_STATUS > ( ) , 8usize , concat ! ( "Size of: " , stringify ! ( __WAIT_STATUS ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < __WAIT_STATUS > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( __WAIT_STATUS ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < __WAIT_STATUS > ( ) ) ) . __uptr as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( __WAIT_STATUS ) , "::" , stringify ! ( __uptr ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < __WAIT_STATUS > ( ) ) ) . __iptr as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( __WAIT_STATUS ) , "::" , stringify ! ( __iptr ) ) ) ; } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct div_t { pub quot : :: std :: os :: raw :: c_int , pub rem : :: std :: os :: raw :: c_int , } # [ test ] fn bindgen_test_layout_div_t ( ) { assert_eq ! ( :: std :: mem :: size_of :: < div_t > ( ) , 8usize , concat ! ( "Size of: " , stringify ! ( div_t ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < div_t > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( div_t ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < div_t > ( ) ) ) . quot as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( div_t ) , "::" , stringify ! ( quot ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < div_t > ( ) ) ) . rem as * const _ as usize } , 4usize , concat ! ( "Offset of field: " , stringify ! ( div_t ) , "::" , stringify ! ( rem ) ) ) ; } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct ldiv_t { pub quot : :: std :: os :: raw :: c_long , pub rem : :: std :: os :: raw :: c_long , } # [ test ] fn bindgen_test_layout_ldiv_t ( ) { assert_eq ! ( :: std :: mem :: size_of :: < ldiv_t > ( ) , 16usize , concat ! ( "Size of: " , stringify ! ( ldiv_t ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < ldiv_t > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( ldiv_t ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < ldiv_t > ( ) ) ) . quot as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( ldiv_t ) , "::" , stringify ! ( quot ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < ldiv_t > ( ) ) ) . rem as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( ldiv_t ) , "::" , stringify ! ( rem ) ) ) ; } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct lldiv_t { pub quot : :: std :: os :: raw :: c_longlong , pub rem : :: std :: os :: raw :: c_longlong , } # [ test ] fn bindgen_test_layout_lldiv_t ( ) { assert_eq ! ( :: std :: mem :: size_of :: < lldiv_t > ( ) , 16usize , concat ! ( "Size of: " , stringify ! ( lldiv_t ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < lldiv_t > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( lldiv_t ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < lldiv_t > ( ) ) ) . quot as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( lldiv_t ) , "::" , stringify ! ( quot ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < lldiv_t > ( ) ) ) . rem as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( lldiv_t ) , "::" , stringify ! ( rem ) ) ) ; } extern "C" { pub fn __ctype_get_mb_cur_max ( ) -> usize ; } extern "C" { pub fn atof ( __nptr : * const :: std :: os :: raw :: c_char ) -> f64 ; } extern "C" { pub fn atoi ( __nptr : * const :: std :: os :: raw :: c_char ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn atol ( __nptr : * const :: std :: os :: raw :: c_char ) -> :: std :: os :: raw :: c_long ; } extern "C" { pub fn atoll ( __nptr : * const :: std :: os :: raw :: c_char ) -> :: std :: os :: raw :: c_longlong ; } extern "C" { pub fn strtod ( __nptr : * const :: std :: os :: raw :: c_char , __endptr : * mut * mut :: std :: os :: raw :: c_char ) -> f64 ; } extern "C" { pub fn strtof ( __nptr : * const :: std :: os :: raw :: c_char , __endptr : * mut * mut :: std :: os :: raw :: c_char ) -> f32 ; } extern "C" { pub fn strtold ( __nptr : * const :: std :: os :: raw :: c_char , __endptr : * mut * mut :: std :: os :: raw :: c_char ) -> f64 ; } extern "C" { pub fn strtol ( __nptr : * const :: std :: os :: raw :: c_char , __endptr : * mut * mut :: std :: os :: raw :: c_char , __base : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_long ; } extern "C" { pub fn strtoul ( __nptr : * const :: std :: os :: raw :: c_char , __endptr : * mut * mut :: std :: os :: raw :: c_char , __base : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_ulong ; } extern "C" { pub fn strtoq ( __nptr : * const :: std :: os :: raw :: c_char , __endptr : * mut * mut :: std :: os :: raw :: c_char , __base : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_longlong ; } extern "C" { pub fn strtouq ( __nptr : * const :: std :: os :: raw :: c_char , __endptr : * mut * mut :: std :: os :: raw :: c_char , __base : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_ulonglong ; } extern "C" { pub fn strtoll ( __nptr : * const :: std :: os :: raw :: c_char , __endptr : * mut * mut :: std :: os :: raw :: c_char , __base : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_longlong ; } extern "C" { pub fn strtoull ( __nptr : * const :: std :: os :: raw :: c_char , __endptr : * mut * mut :: std :: os :: raw :: c_char , __base : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_ulonglong ; } extern "C" { pub fn l64a ( __n : :: std :: os :: raw :: c_long ) -> * mut :: std :: os :: raw :: c_char ; } extern "C" { pub fn a64l ( __s : * const :: std :: os :: raw :: c_char ) -> :: std :: os :: raw :: c_long ; } pub type u_char = __u_char ; pub type u_short = __u_short ; pub type u_int = __u_int ; pub type u_long = __u_long ; pub type quad_t = __quad_t ; pub type u_quad_t = __u_quad_t ; pub type fsid_t = __fsid_t ; pub type loff_t = __loff_t ; pub type ino_t = __ino_t ; pub type dev_t = __dev_t ; pub type gid_t = __gid_t ; pub type mode_t = __mode_t ; pub type nlink_t = __nlink_t ; pub type uid_t = __uid_t ; pub type pid_t = __pid_t ; pub type id_t = __id_t ; pub type daddr_t = __daddr_t ; pub type caddr_t = __caddr_t ; pub type key_t = __key_t ; pub type clock_t = __clock_t ; pub type time_t = __time_t ; pub type clockid_t = __clockid_t ; pub type timer_t = __timer_t ; pub type ulong = :: std :: os :: raw :: c_ulong ; pub type ushort = :: std :: os :: raw :: c_ushort ; pub type uint = :: std :: os :: raw :: c_uint ; pub type u_int8_t = :: std :: os :: raw :: c_uchar ; pub type u_int16_t = :: std :: os :: raw :: c_ushort ; pub type u_int32_t = :: std :: os :: raw :: c_uint ; pub type u_int64_t = :: std :: os :: raw :: c_ulong ; pub type register_t = :: std :: os :: raw :: c_long ; pub type __sig_atomic_t = :: std :: os :: raw :: c_int ; # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct __sigset_t { pub __val : [ :: std :: os :: raw :: c_ulong ; 16usize ] , } # [ test ] fn bindgen_test_layout___sigset_t ( ) { assert_eq ! ( :: std :: mem :: size_of :: < __sigset_t > ( ) , 128usize , concat ! ( "Size of: " , stringify ! ( __sigset_t ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < __sigset_t > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( __sigset_t ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < __sigset_t > ( ) ) ) . __val as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( __sigset_t ) , "::" , stringify ! ( __val ) ) ) ; } pub type sigset_t = __sigset_t ; # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct timespec { pub tv_sec : __time_t , pub tv_nsec : __syscall_slong_t , } # [ test ] fn bindgen_test_layout_timespec ( ) { assert_eq ! ( :: std :: mem :: size_of :: < timespec > ( ) , 16usize , concat ! ( "Size of: " , stringify ! ( timespec ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < timespec > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( timespec ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < timespec > ( ) ) ) . tv_sec as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( timespec ) , "::" , stringify ! ( tv_sec ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < timespec > ( ) ) ) . tv_nsec as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( timespec ) , "::" , stringify ! ( tv_nsec ) ) ) ; } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct timeval { pub tv_sec : __time_t , pub tv_usec : __suseconds_t , } # [ test ] fn bindgen_test_layout_timeval ( ) { assert_eq ! ( :: std :: mem :: size_of :: < timeval > ( ) , 16usize , concat ! ( "Size of: " , stringify ! ( timeval ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < timeval > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( timeval ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < timeval > ( ) ) ) . tv_sec as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( timeval ) , "::" , stringify ! ( tv_sec ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < timeval > ( ) ) ) . tv_usec as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( timeval ) , "::" , stringify ! ( tv_usec ) ) ) ; } pub type suseconds_t = __suseconds_t ; pub type __fd_mask = :: std :: os :: raw :: c_long ; # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct fd_set { pub __fds_bits : [ __fd_mask ; 16usize ] , } # [ test ] fn bindgen_test_layout_fd_set ( ) { assert_eq ! ( :: std :: mem :: size_of :: < fd_set > ( ) , 128usize , concat ! ( "Size of: " , stringify ! ( fd_set ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < fd_set > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( fd_set ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < fd_set > ( ) ) ) . __fds_bits as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( fd_set ) , "::" , stringify ! ( __fds_bits ) ) ) ; } pub type fd_mask = __fd_mask ; extern "C" { pub fn select ( __nfds : :: std :: os :: raw :: c_int , __readfds : * mut fd_set , __writefds : * mut fd_set , __exceptfds : * mut fd_set , __timeout : * mut timeval ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn pselect ( __nfds : :: std :: os :: raw :: c_int , __readfds : * mut fd_set , __writefds : * mut fd_set , __exceptfds : * mut fd_set , __timeout : * const timespec , __sigmask : * const __sigset_t ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn gnu_dev_major ( __dev : :: std :: os :: raw :: c_ulonglong ) -> :: std :: os :: raw :: c_uint ; } extern "C" { pub fn gnu_dev_minor ( __dev : :: std :: os :: raw :: c_ulonglong ) -> :: std :: os :: raw :: c_uint ; } extern "C" { pub fn gnu_dev_makedev ( __major : :: std :: os :: raw :: c_uint , __minor : :: std :: os :: raw :: c_uint ) -> :: std :: os :: raw :: c_ulonglong ; } pub type blksize_t = __blksize_t ; pub type blkcnt_t = __blkcnt_t ; pub type fsblkcnt_t = __fsblkcnt_t ; pub type fsfilcnt_t = __fsfilcnt_t ; pub type pthread_t = :: std :: os :: raw :: c_ulong ; # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union pthread_attr_t { pub __size : [ :: std :: os :: raw :: c_char ; 56usize ] , pub __align : :: std :: os :: raw :: c_long , _bindgen_union_align : [ u64 ; 7usize ] , } # [ test ] fn bindgen_test_layout_pthread_attr_t ( ) { assert_eq ! ( :: std :: mem :: size_of :: < pthread_attr_t > ( ) , 56usize , concat ! ( "Size of: " , stringify ! ( pthread_attr_t ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < pthread_attr_t > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( pthread_attr_t ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < pthread_attr_t > ( ) ) ) . __size as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( pthread_attr_t ) , "::" , stringify ! ( __size ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < pthread_attr_t > ( ) ) ) . __align as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( pthread_attr_t ) , "::" , stringify ! ( __align ) ) ) ; } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct __pthread_internal_list { pub __prev : * mut __pthread_internal_list , pub __next : * mut __pthread_internal_list , } # [ test ] fn bindgen_test_layout___pthread_internal_list ( ) { assert_eq ! ( :: std :: mem :: size_of :: < __pthread_internal_list > ( ) , 16usize , concat ! ( "Size of: " , stringify ! ( __pthread_internal_list ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < __pthread_internal_list > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( __pthread_internal_list ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < __pthread_internal_list > ( ) ) ) . __prev as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( __pthread_internal_list ) , "::" , stringify ! ( __prev ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < __pthread_internal_list > ( ) ) ) . __next as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( __pthread_internal_list ) , "::" , stringify ! ( __next ) ) ) ; } pub type __pthread_list_t = __pthread_internal_list ; # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union pthread_mutex_t { pub __data : pthread_mutex_t___pthread_mutex_s , pub __size : [ :: std :: os :: raw :: c_char ; 40usize ] , pub __align : :: std :: os :: raw :: c_long , _bindgen_union_align : [ u64 ; 5usize ] , } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct pthread_mutex_t___pthread_mutex_s { pub __lock : :: std :: os :: raw :: c_int , pub __count : :: std :: os :: raw :: c_uint , pub __owner : :: std :: os :: raw :: c_int , pub __nusers : :: std :: os :: raw :: c_uint , pub __kind : :: std :: os :: raw :: c_int , pub __spins : :: std :: os :: raw :: c_short , pub __elision : :: std :: os :: raw :: c_short , pub __list : __pthread_list_t , } # [ test ] fn bindgen_test_layout_pthread_mutex_t___pthread_mutex_s ( ) { assert_eq ! ( :: std :: mem :: size_of :: < pthread_mutex_t___pthread_mutex_s > ( ) , 40usize , concat ! ( "Size of: " , stringify ! ( pthread_mutex_t___pthread_mutex_s ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < pthread_mutex_t___pthread_mutex_s > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( pthread_mutex_t___pthread_mutex_s ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < pthread_mutex_t___pthread_mutex_s > ( ) ) ) . __lock as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( pthread_mutex_t___pthread_mutex_s ) , "::" , stringify ! ( __lock ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < pthread_mutex_t___pthread_mutex_s > ( ) ) ) . __count as * const _ as usize } , 4usize , concat ! ( "Offset of field: " , stringify ! ( pthread_mutex_t___pthread_mutex_s ) , "::" , stringify ! ( __count ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < pthread_mutex_t___pthread_mutex_s > ( ) ) ) . __owner as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( pthread_mutex_t___pthread_mutex_s ) , "::" , stringify ! ( __owner ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < pthread_mutex_t___pthread_mutex_s > ( ) ) ) . __nusers as * const _ as usize } , 12usize , concat ! ( "Offset of field: " , stringify ! ( pthread_mutex_t___pthread_mutex_s ) , "::" , stringify ! ( __nusers ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < pthread_mutex_t___pthread_mutex_s > ( ) ) ) . __kind as * const _ as usize } , 16usize , concat ! ( "Offset of field: " , stringify ! ( pthread_mutex_t___pthread_mutex_s ) , "::" , stringify ! ( __kind ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < pthread_mutex_t___pthread_mutex_s > ( ) ) ) . __spins as * const _ as usize } , 20usize , concat ! ( "Offset of field: " , stringify ! ( pthread_mutex_t___pthread_mutex_s ) , "::" , stringify ! ( __spins ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < pthread_mutex_t___pthread_mutex_s > ( ) ) ) . __elision as * const _ as usize } , 22usize , concat ! ( "Offset of field: " , stringify ! ( pthread_mutex_t___pthread_mutex_s ) , "::" , stringify ! ( __elision ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < pthread_mutex_t___pthread_mutex_s > ( ) ) ) . __list as * const _ as usize } , 24usize , concat ! ( "Offset of field: " , stringify ! ( pthread_mutex_t___pthread_mutex_s ) , "::" , stringify ! ( __list ) ) ) ; } # [ test ] fn bindgen_test_layout_pthread_mutex_t ( ) { assert_eq ! ( :: std :: mem :: size_of :: < pthread_mutex_t > ( ) , 40usize , concat ! ( "Size of: " , stringify ! ( pthread_mutex_t ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < pthread_mutex_t > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( pthread_mutex_t ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < pthread_mutex_t > ( ) ) ) . __data as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( pthread_mutex_t ) , "::" , stringify ! ( __data ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < pthread_mutex_t > ( ) ) ) . __size as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( pthread_mutex_t ) , "::" , stringify ! ( __size ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < pthread_mutex_t > ( ) ) ) . __align as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( pthread_mutex_t ) , "::" , stringify ! ( __align ) ) ) ; } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union pthread_mutexattr_t { pub __size : [ :: std :: os :: raw :: c_char ; 4usize ] , pub __align : :: std :: os :: raw :: c_int , _bindgen_union_align : u32 , } # [ test ] fn bindgen_test_layout_pthread_mutexattr_t ( ) { assert_eq ! ( :: std :: mem :: size_of :: < pthread_mutexattr_t > ( ) , 4usize , concat ! ( "Size of: " , stringify ! ( pthread_mutexattr_t ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < pthread_mutexattr_t > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( pthread_mutexattr_t ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < pthread_mutexattr_t > ( ) ) ) . __size as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( pthread_mutexattr_t ) , "::" , stringify ! ( __size ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < pthread_mutexattr_t > ( ) ) ) . __align as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( pthread_mutexattr_t ) , "::" , stringify ! ( __align ) ) ) ; } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union pthread_cond_t { pub __data : pthread_cond_t__bindgen_ty_1 , pub __size : [ :: std :: os :: raw :: c_char ; 48usize ] , pub __align : :: std :: os :: raw :: c_longlong , _bindgen_union_align : [ u64 ; 6usize ] , } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct pthread_cond_t__bindgen_ty_1 { pub __lock : :: std :: os :: raw :: c_int , pub __futex : :: std :: os :: raw :: c_uint , pub __total_seq : :: std :: os :: raw :: c_ulonglong , pub __wakeup_seq : :: std :: os :: raw :: c_ulonglong , pub __woken_seq : :: std :: os :: raw :: c_ulonglong , pub __mutex : * mut :: std :: os :: raw :: c_void , pub __nwaiters : :: std :: os :: raw :: c_uint , pub __broadcast_seq : :: std :: os :: raw :: c_uint , } # [ test ] fn bindgen_test_layout_pthread_cond_t__bindgen_ty_1 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < pthread_cond_t__bindgen_ty_1 > ( ) , 48usize , concat ! ( "Size of: " , stringify ! ( pthread_cond_t__bindgen_ty_1 ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < pthread_cond_t__bindgen_ty_1 > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( pthread_cond_t__bindgen_ty_1 ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < pthread_cond_t__bindgen_ty_1 > ( ) ) ) . __lock as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( pthread_cond_t__bindgen_ty_1 ) , "::" , stringify ! ( __lock ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < pthread_cond_t__bindgen_ty_1 > ( ) ) ) . __futex as * const _ as usize } , 4usize , concat ! ( "Offset of field: " , stringify ! ( pthread_cond_t__bindgen_ty_1 ) , "::" , stringify ! ( __futex ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < pthread_cond_t__bindgen_ty_1 > ( ) ) ) . __total_seq as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( pthread_cond_t__bindgen_ty_1 ) , "::" , stringify ! ( __total_seq ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < pthread_cond_t__bindgen_ty_1 > ( ) ) ) . __wakeup_seq as * const _ as usize } , 16usize , concat ! ( "Offset of field: " , stringify ! ( pthread_cond_t__bindgen_ty_1 ) , "::" , stringify ! ( __wakeup_seq ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < pthread_cond_t__bindgen_ty_1 > ( ) ) ) . __woken_seq as * const _ as usize } , 24usize , concat ! ( "Offset of field: " , stringify ! ( pthread_cond_t__bindgen_ty_1 ) , "::" , stringify ! ( __woken_seq ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < pthread_cond_t__bindgen_ty_1 > ( ) ) ) . __mutex as * const _ as usize } , 32usize , concat ! ( "Offset of field: " , stringify ! ( pthread_cond_t__bindgen_ty_1 ) , "::" , stringify ! ( __mutex ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < pthread_cond_t__bindgen_ty_1 > ( ) ) ) . __nwaiters as * const _ as usize } , 40usize , concat ! ( "Offset of field: " , stringify ! ( pthread_cond_t__bindgen_ty_1 ) , "::" , stringify ! ( __nwaiters ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < pthread_cond_t__bindgen_ty_1 > ( ) ) ) . __broadcast_seq as * const _ as usize } , 44usize , concat ! ( "Offset of field: " , stringify ! ( pthread_cond_t__bindgen_ty_1 ) , "::" , stringify ! ( __broadcast_seq ) ) ) ; } # [ test ] fn bindgen_test_layout_pthread_cond_t ( ) { assert_eq ! ( :: std :: mem :: size_of :: < pthread_cond_t > ( ) , 48usize , concat ! ( "Size of: " , stringify ! ( pthread_cond_t ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < pthread_cond_t > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( pthread_cond_t ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < pthread_cond_t > ( ) ) ) . __data as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( pthread_cond_t ) , "::" , stringify ! ( __data ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < pthread_cond_t > ( ) ) ) . __size as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( pthread_cond_t ) , "::" , stringify ! ( __size ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < pthread_cond_t > ( ) ) ) . __align as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( pthread_cond_t ) , "::" , stringify ! ( __align ) ) ) ; } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union pthread_condattr_t { pub __size : [ :: std :: os :: raw :: c_char ; 4usize ] , pub __align : :: std :: os :: raw :: c_int , _bindgen_union_align : u32 , } # [ test ] fn bindgen_test_layout_pthread_condattr_t ( ) { assert_eq ! ( :: std :: mem :: size_of :: < pthread_condattr_t > ( ) , 4usize , concat ! ( "Size of: " , stringify ! ( pthread_condattr_t ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < pthread_condattr_t > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( pthread_condattr_t ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < pthread_condattr_t > ( ) ) ) . __size as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( pthread_condattr_t ) , "::" , stringify ! ( __size ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < pthread_condattr_t > ( ) ) ) . __align as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( pthread_condattr_t ) , "::" , stringify ! ( __align ) ) ) ; } pub type pthread_key_t = :: std :: os :: raw :: c_uint ; pub type pthread_once_t = :: std :: os :: raw :: c_int ; # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union pthread_rwlock_t { pub __data : pthread_rwlock_t__bindgen_ty_1 , pub __size : [ :: std :: os :: raw :: c_char ; 56usize ] , pub __align : :: std :: os :: raw :: c_long , _bindgen_union_align : [ u64 ; 7usize ] , } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct pthread_rwlock_t__bindgen_ty_1 { pub __lock : :: std :: os :: raw :: c_int , pub __nr_readers : :: std :: os :: raw :: c_uint , pub __readers_wakeup : :: std :: os :: raw :: c_uint , pub __writer_wakeup : :: std :: os :: raw :: c_uint , pub __nr_readers_queued : :: std :: os :: raw :: c_uint , pub __nr_writers_queued : :: std :: os :: raw :: c_uint , pub __writer : :: std :: os :: raw :: c_int , pub __shared : :: std :: os :: raw :: c_int , pub __rwelision : :: std :: os :: raw :: c_schar , pub __pad1 : [ :: std :: os :: raw :: c_uchar ; 7usize ] , pub __pad2 : :: std :: os :: raw :: c_ulong , pub __flags : :: std :: os :: raw :: c_uint , } # [ test ] fn bindgen_test_layout_pthread_rwlock_t__bindgen_ty_1 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < pthread_rwlock_t__bindgen_ty_1 > ( ) , 56usize , concat ! ( "Size of: " , stringify ! ( pthread_rwlock_t__bindgen_ty_1 ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < pthread_rwlock_t__bindgen_ty_1 > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( pthread_rwlock_t__bindgen_ty_1 ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < pthread_rwlock_t__bindgen_ty_1 > ( ) ) ) . __lock as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( pthread_rwlock_t__bindgen_ty_1 ) , "::" , stringify ! ( __lock ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < pthread_rwlock_t__bindgen_ty_1 > ( ) ) ) . __nr_readers as * const _ as usize } , 4usize , concat ! ( "Offset of field: " , stringify ! ( pthread_rwlock_t__bindgen_ty_1 ) , "::" , stringify ! ( __nr_readers ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < pthread_rwlock_t__bindgen_ty_1 > ( ) ) ) . __readers_wakeup as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( pthread_rwlock_t__bindgen_ty_1 ) , "::" , stringify ! ( __readers_wakeup ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < pthread_rwlock_t__bindgen_ty_1 > ( ) ) ) . __writer_wakeup as * const _ as usize } , 12usize , concat ! ( "Offset of field: " , stringify ! ( pthread_rwlock_t__bindgen_ty_1 ) , "::" , stringify ! ( __writer_wakeup ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < pthread_rwlock_t__bindgen_ty_1 > ( ) ) ) . __nr_readers_queued as * const _ as usize } , 16usize , concat ! ( "Offset of field: " , stringify ! ( pthread_rwlock_t__bindgen_ty_1 ) , "::" , stringify ! ( __nr_readers_queued ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < pthread_rwlock_t__bindgen_ty_1 > ( ) ) ) . __nr_writers_queued as * const _ as usize } , 20usize , concat ! ( "Offset of field: " , stringify ! ( pthread_rwlock_t__bindgen_ty_1 ) , "::" , stringify ! ( __nr_writers_queued ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < pthread_rwlock_t__bindgen_ty_1 > ( ) ) ) . __writer as * const _ as usize } , 24usize , concat ! ( "Offset of field: " , stringify ! ( pthread_rwlock_t__bindgen_ty_1 ) , "::" , stringify ! ( __writer ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < pthread_rwlock_t__bindgen_ty_1 > ( ) ) ) . __shared as * const _ as usize } , 28usize , concat ! ( "Offset of field: " , stringify ! ( pthread_rwlock_t__bindgen_ty_1 ) , "::" , stringify ! ( __shared ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < pthread_rwlock_t__bindgen_ty_1 > ( ) ) ) . __rwelision as * const _ as usize } , 32usize , concat ! ( "Offset of field: " , stringify ! ( pthread_rwlock_t__bindgen_ty_1 ) , "::" , stringify ! ( __rwelision ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < pthread_rwlock_t__bindgen_ty_1 > ( ) ) ) . __pad1 as * const _ as usize } , 33usize , concat ! ( "Offset of field: " , stringify ! ( pthread_rwlock_t__bindgen_ty_1 ) , "::" , stringify ! ( __pad1 ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < pthread_rwlock_t__bindgen_ty_1 > ( ) ) ) . __pad2 as * const _ as usize } , 40usize , concat ! ( "Offset of field: " , stringify ! ( pthread_rwlock_t__bindgen_ty_1 ) , "::" , stringify ! ( __pad2 ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < pthread_rwlock_t__bindgen_ty_1 > ( ) ) ) . __flags as * const _ as usize } , 48usize , concat ! ( "Offset of field: " , stringify ! ( pthread_rwlock_t__bindgen_ty_1 ) , "::" , stringify ! ( __flags ) ) ) ; } # [ test ] fn bindgen_test_layout_pthread_rwlock_t ( ) { assert_eq ! ( :: std :: mem :: size_of :: < pthread_rwlock_t > ( ) , 56usize , concat ! ( "Size of: " , stringify ! ( pthread_rwlock_t ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < pthread_rwlock_t > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( pthread_rwlock_t ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < pthread_rwlock_t > ( ) ) ) . __data as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( pthread_rwlock_t ) , "::" , stringify ! ( __data ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < pthread_rwlock_t > ( ) ) ) . __size as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( pthread_rwlock_t ) , "::" , stringify ! ( __size ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < pthread_rwlock_t > ( ) ) ) . __align as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( pthread_rwlock_t ) , "::" , stringify ! ( __align ) ) ) ; } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union pthread_rwlockattr_t { pub __size : [ :: std :: os :: raw :: c_char ; 8usize ] , pub __align : :: std :: os :: raw :: c_long , _bindgen_union_align : u64 , } # [ test ] fn bindgen_test_layout_pthread_rwlockattr_t ( ) { assert_eq ! ( :: std :: mem :: size_of :: < pthread_rwlockattr_t > ( ) , 8usize , concat ! ( "Size of: " , stringify ! ( pthread_rwlockattr_t ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < pthread_rwlockattr_t > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( pthread_rwlockattr_t ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < pthread_rwlockattr_t > ( ) ) ) . __size as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( pthread_rwlockattr_t ) , "::" , stringify ! ( __size ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < pthread_rwlockattr_t > ( ) ) ) . __align as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( pthread_rwlockattr_t ) , "::" , stringify ! ( __align ) ) ) ; } pub type pthread_spinlock_t = :: std :: os :: raw :: c_int ; # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union pthread_barrier_t { pub __size : [ :: std :: os :: raw :: c_char ; 32usize ] , pub __align : :: std :: os :: raw :: c_long , _bindgen_union_align : [ u64 ; 4usize ] , } # [ test ] fn bindgen_test_layout_pthread_barrier_t ( ) { assert_eq ! ( :: std :: mem :: size_of :: < pthread_barrier_t > ( ) , 32usize , concat ! ( "Size of: " , stringify ! ( pthread_barrier_t ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < pthread_barrier_t > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( pthread_barrier_t ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < pthread_barrier_t > ( ) ) ) . __size as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( pthread_barrier_t ) , "::" , stringify ! ( __size ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < pthread_barrier_t > ( ) ) ) . __align as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( pthread_barrier_t ) , "::" , stringify ! ( __align ) ) ) ; } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union pthread_barrierattr_t { pub __size : [ :: std :: os :: raw :: c_char ; 4usize ] , pub __align : :: std :: os :: raw :: c_int , _bindgen_union_align : u32 , } # [ test ] fn bindgen_test_layout_pthread_barrierattr_t ( ) { assert_eq ! ( :: std :: mem :: size_of :: < pthread_barrierattr_t > ( ) , 4usize , concat ! ( "Size of: " , stringify ! ( pthread_barrierattr_t ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < pthread_barrierattr_t > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( pthread_barrierattr_t ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < pthread_barrierattr_t > ( ) ) ) . __size as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( pthread_barrierattr_t ) , "::" , stringify ! ( __size ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < pthread_barrierattr_t > ( ) ) ) . __align as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( pthread_barrierattr_t ) , "::" , stringify ! ( __align ) ) ) ; } extern "C" { pub fn random ( ) -> :: std :: os :: raw :: c_long ; } extern "C" { pub fn srandom ( __seed : :: std :: os :: raw :: c_uint ) ; } extern "C" { pub fn initstate ( __seed : :: std :: os :: raw :: c_uint , __statebuf : * mut :: std :: os :: raw :: c_char , __statelen : usize ) -> * mut :: std :: os :: raw :: c_char ; } extern "C" { pub fn setstate ( __statebuf : * mut :: std :: os :: raw :: c_char ) -> * mut :: std :: os :: raw :: c_char ; } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct random_data { pub fptr : * mut i32 , pub rptr : * mut i32 , pub state : * mut i32 , pub rand_type : :: std :: os :: raw :: c_int , pub rand_deg : :: std :: os :: raw :: c_int , pub rand_sep : :: std :: os :: raw :: c_int , pub end_ptr : * mut i32 , } # [ test ] fn bindgen_test_layout_random_data ( ) { assert_eq ! ( :: std :: mem :: size_of :: < random_data > ( ) , 48usize , concat ! ( "Size of: " , stringify ! ( random_data ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < random_data > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( random_data ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < random_data > ( ) ) ) . fptr as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( random_data ) , "::" , stringify ! ( fptr ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < random_data > ( ) ) ) . rptr as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( random_data ) , "::" , stringify ! ( rptr ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < random_data > ( ) ) ) . state as * const _ as usize } , 16usize , concat ! ( "Offset of field: " , stringify ! ( random_data ) , "::" , stringify ! ( state ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < random_data > ( ) ) ) . rand_type as * const _ as usize } , 24usize , concat ! ( "Offset of field: " , stringify ! ( random_data ) , "::" , stringify ! ( rand_type ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < random_data > ( ) ) ) . rand_deg as * const _ as usize } , 28usize , concat ! ( "Offset of field: " , stringify ! ( random_data ) , "::" , stringify ! ( rand_deg ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < random_data > ( ) ) ) . rand_sep as * const _ as usize } , 32usize , concat ! ( "Offset of field: " , stringify ! ( random_data ) , "::" , stringify ! ( rand_sep ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < random_data > ( ) ) ) . end_ptr as * const _ as usize } , 40usize , concat ! ( "Offset of field: " , stringify ! ( random_data ) , "::" , stringify ! ( end_ptr ) ) ) ; } extern "C" { pub fn random_r ( __buf : * mut random_data , __result : * mut i32 ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn srandom_r ( __seed : :: std :: os :: raw :: c_uint , __buf : * mut random_data ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn initstate_r ( __seed : :: std :: os :: raw :: c_uint , __statebuf : * mut :: std :: os :: raw :: c_char , __statelen : usize , __buf : * mut random_data ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn setstate_r ( __statebuf : * mut :: std :: os :: raw :: c_char , __buf : * mut random_data ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn rand ( ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn srand ( __seed : :: std :: os :: raw :: c_uint ) ; } extern "C" { pub fn rand_r ( __seed : * mut :: std :: os :: raw :: c_uint ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn drand48 ( ) -> f64 ; } extern "C" { pub fn erand48 ( __xsubi : * mut :: std :: os :: raw :: c_ushort ) -> f64 ; } extern "C" { pub fn lrand48 ( ) -> :: std :: os :: raw :: c_long ; } extern "C" { pub fn nrand48 ( __xsubi : * mut :: std :: os :: raw :: c_ushort ) -> :: std :: os :: raw :: c_long ; } extern "C" { pub fn mrand48 ( ) -> :: std :: os :: raw :: c_long ; } extern "C" { pub fn jrand48 ( __xsubi : * mut :: std :: os :: raw :: c_ushort ) -> :: std :: os :: raw :: c_long ; } extern "C" { pub fn srand48 ( __seedval : :: std :: os :: raw :: c_long ) ; } extern "C" { pub fn seed48 ( __seed16v : * mut :: std :: os :: raw :: c_ushort ) -> * mut :: std :: os :: raw :: c_ushort ; } extern "C" { pub fn lcong48 ( __param : * mut :: std :: os :: raw :: c_ushort ) ; } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct drand48_data { pub __x : [ :: std :: os :: raw :: c_ushort ; 3usize ] , pub __old_x : [ :: std :: os :: raw :: c_ushort ; 3usize ] , pub __c : :: std :: os :: raw :: c_ushort , pub __init : :: std :: os :: raw :: c_ushort , pub __a : :: std :: os :: raw :: c_ulonglong , } # [ test ] fn bindgen_test_layout_drand48_data ( ) { assert_eq ! ( :: std :: mem :: size_of :: < drand48_data > ( ) , 24usize , concat ! ( "Size of: " , stringify ! ( drand48_data ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < drand48_data > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( drand48_data ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < drand48_data > ( ) ) ) . __x as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( drand48_data ) , "::" , stringify ! ( __x ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < drand48_data > ( ) ) ) . __old_x as * const _ as usize } , 6usize , concat ! ( "Offset of field: " , stringify ! ( drand48_data ) , "::" , stringify ! ( __old_x ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < drand48_data > ( ) ) ) . __c as * const _ as usize } , 12usize , concat ! ( "Offset of field: " , stringify ! ( drand48_data ) , "::" , stringify ! ( __c ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < drand48_data > ( ) ) ) . __init as * const _ as usize } , 14usize , concat ! ( "Offset of field: " , stringify ! ( drand48_data ) , "::" , stringify ! ( __init ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < drand48_data > ( ) ) ) . __a as * const _ as usize } , 16usize , concat ! ( "Offset of field: " , stringify ! ( drand48_data ) , "::" , stringify ! ( __a ) ) ) ; } extern "C" { pub fn drand48_r ( __buffer : * mut drand48_data , __result : * mut f64 ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn erand48_r ( __xsubi : * mut :: std :: os :: raw :: c_ushort , __buffer : * mut drand48_data , __result : * mut f64 ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn lrand48_r ( __buffer : * mut drand48_data , __result : * mut :: std :: os :: raw :: c_long ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn nrand48_r ( __xsubi : * mut :: std :: os :: raw :: c_ushort , __buffer : * mut drand48_data , __result : * mut :: std :: os :: raw :: c_long ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn mrand48_r ( __buffer : * mut drand48_data , __result : * mut :: std :: os :: raw :: c_long ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn jrand48_r ( __xsubi : * mut :: std :: os :: raw :: c_ushort , __buffer : * mut drand48_data , __result : * mut :: std :: os :: raw :: c_long ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn srand48_r ( __seedval : :: std :: os :: raw :: c_long , __buffer : * mut drand48_data ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn seed48_r ( __seed16v : * mut :: std :: os :: raw :: c_ushort , __buffer : * mut drand48_data ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn lcong48_r ( __param : * mut :: std :: os :: raw :: c_ushort , __buffer : * mut drand48_data ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn malloc ( __size : usize ) -> * mut :: std :: os :: raw :: c_void ; } extern "C" { pub fn calloc ( __nmemb : usize , __size : usize ) -> * mut :: std :: os :: raw :: c_void ; } extern "C" { pub fn realloc ( __ptr : * mut :: std :: os :: raw :: c_void , __size : usize ) -> * mut :: std :: os :: raw :: c_void ; } extern "C" { pub fn free ( __ptr : * mut :: std :: os :: raw :: c_void ) ; } extern "C" { pub fn cfree ( __ptr : * mut :: std :: os :: raw :: c_void ) ; } extern "C" { pub fn alloca ( __size : usize ) -> * mut :: std :: os :: raw :: c_void ; } extern "C" { pub fn valloc ( __size : usize ) -> * mut :: std :: os :: raw :: c_void ; } extern "C" { pub fn posix_memalign ( __memptr : * mut * mut :: std :: os :: raw :: c_void , __alignment : usize , __size : usize ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn aligned_alloc ( __alignment : usize , __size : usize ) -> * mut :: std :: os :: raw :: c_void ; } extern "C" { pub fn abort ( ) ; } extern "C" { pub fn atexit ( __func : :: std :: option :: Option < unsafe extern "C" fn ( ) > ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn at_quick_exit ( __func : :: std :: option :: Option < unsafe extern "C" fn ( ) > ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn on_exit ( __func : :: std :: option :: Option < unsafe extern "C" fn ( __status : :: std :: os :: raw :: c_int , __arg : * mut :: std :: os :: raw :: c_void ) > , __arg : * mut :: std :: os :: raw :: c_void ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn exit ( __status : :: std :: os :: raw :: c_int ) ; } extern "C" { pub fn quick_exit ( __status : :: std :: os :: raw :: c_int ) ; } extern "C" { pub fn _Exit ( __status : :: std :: os :: raw :: c_int ) ; } extern "C" { pub fn getenv ( __name : * const :: std :: os :: raw :: c_char ) -> * mut :: std :: os :: raw :: c_char ; } extern "C" { pub fn putenv ( __string : * mut :: std :: os :: raw :: c_char ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn setenv ( __name : * const :: std :: os :: raw :: c_char , __value : * const :: std :: os :: raw :: c_char , __replace : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn unsetenv ( __name : * const :: std :: os :: raw :: c_char ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn clearenv ( ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn mktemp ( __template : * mut :: std :: os :: raw :: c_char ) -> * mut :: std :: os :: raw :: c_char ; } extern "C" { pub fn mkstemp ( __template : * mut :: std :: os :: raw :: c_char ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn mkstemps ( __template : * mut :: std :: os :: raw :: c_char , __suffixlen : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn mkdtemp ( __template : * mut :: std :: os :: raw :: c_char ) -> * mut :: std :: os :: raw :: c_char ; } extern "C" { pub fn system ( __command : * const :: std :: os :: raw :: c_char ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn realpath ( __name : * const :: std :: os :: raw :: c_char , __resolved : * mut :: std :: os :: raw :: c_char ) -> * mut :: std :: os :: raw :: c_char ; } pub type __compar_fn_t = :: std :: option :: Option < unsafe extern "C" fn ( arg1 : * const :: std :: os :: raw :: c_void , arg2 : * const :: std :: os :: raw :: c_void ) -> :: std :: os :: raw :: c_int > ; extern "C" { pub fn bsearch ( __key : * const :: std :: os :: raw :: c_void , __base : * const :: std :: os :: raw :: c_void , __nmemb : usize , __size : usize , __compar : __compar_fn_t ) -> * mut :: std :: os :: raw :: c_void ; } extern "C" { pub fn qsort ( __base : * mut :: std :: os :: raw :: c_void , __nmemb : usize , __size : usize , __compar : __compar_fn_t ) ; } extern "C" { pub fn abs ( __x : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn labs ( __x : :: std :: os :: raw :: c_long ) -> :: std :: os :: raw :: c_long ; } extern "C" { pub fn llabs ( __x : :: std :: os :: raw :: c_longlong ) -> :: std :: os :: raw :: c_longlong ; } extern "C" { pub fn div ( __numer : :: std :: os :: raw :: c_int , __denom : :: std :: os :: raw :: c_int ) -> div_t ; } extern "C" { pub fn ldiv ( __numer : :: std :: os :: raw :: c_long , __denom : :: std :: os :: raw :: c_long ) -> ldiv_t ; } extern "C" { pub fn lldiv ( __numer : :: std :: os :: raw :: c_longlong , __denom : :: std :: os :: raw :: c_longlong ) -> lldiv_t ; } extern "C" { pub fn ecvt ( __value : f64 , __ndigit : :: std :: os :: raw :: c_int , __decpt : * mut :: std :: os :: raw :: c_int , __sign : * mut :: std :: os :: raw :: c_int ) -> * mut :: std :: os :: raw :: c_char ; } extern "C" { pub fn fcvt ( __value : f64 , __ndigit : :: std :: os :: raw :: c_int , __decpt : * mut :: std :: os :: raw :: c_int , __sign : * mut :: std :: os :: raw :: c_int ) -> * mut :: std :: os :: raw :: c_char ; } extern "C" { pub fn gcvt ( __value : f64 , __ndigit : :: std :: os :: raw :: c_int , __buf : * mut :: std :: os :: raw :: c_char ) -> * mut :: std :: os :: raw :: c_char ; } extern "C" { pub fn qecvt ( __value : f64 , __ndigit : :: std :: os :: raw :: c_int , __decpt : * mut :: std :: os :: raw :: c_int , __sign : * mut :: std :: os :: raw :: c_int ) -> * mut :: std :: os :: raw :: c_char ; } extern "C" { pub fn qfcvt ( __value : f64 , __ndigit : :: std :: os :: raw :: c_int , __decpt : * mut :: std :: os :: raw :: c_int , __sign : * mut :: std :: os :: raw :: c_int ) -> * mut :: std :: os :: raw :: c_char ; } extern "C" { pub fn qgcvt ( __value : f64 , __ndigit : :: std :: os :: raw :: c_int , __buf : * mut :: std :: os :: raw :: c_char ) -> * mut :: std :: os :: raw :: c_char ; } extern "C" { pub fn ecvt_r ( __value : f64 , __ndigit : :: std :: os :: raw :: c_int , __decpt : * mut :: std :: os :: raw :: c_int , __sign : * mut :: std :: os :: raw :: c_int , __buf : * mut :: std :: os :: raw :: c_char , __len : usize ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn fcvt_r ( __value : f64 , __ndigit : :: std :: os :: raw :: c_int , __decpt : * mut :: std :: os :: raw :: c_int , __sign : * mut :: std :: os :: raw :: c_int , __buf : * mut :: std :: os :: raw :: c_char , __len : usize ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn qecvt_r ( __value : f64 , __ndigit : :: std :: os :: raw :: c_int , __decpt : * mut :: std :: os :: raw :: c_int , __sign : * mut :: std :: os :: raw :: c_int , __buf : * mut :: std :: os :: raw :: c_char , __len : usize ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn qfcvt_r ( __value : f64 , __ndigit : :: std :: os :: raw :: c_int , __decpt : * mut :: std :: os :: raw :: c_int , __sign : * mut :: std :: os :: raw :: c_int , __buf : * mut :: std :: os :: raw :: c_char , __len : usize ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn mblen ( __s : * const :: std :: os :: raw :: c_char , __n : usize ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn mbtowc ( __pwc : * mut wchar_t , __s : * const :: std :: os :: raw :: c_char , __n : usize ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn wctomb ( __s : * mut :: std :: os :: raw :: c_char , __wchar : wchar_t ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn mbstowcs ( __pwcs : * mut wchar_t , __s : * const :: std :: os :: raw :: c_char , __n : usize ) -> usize ; } extern "C" { pub fn wcstombs ( __s : * mut :: std :: os :: raw :: c_char , __pwcs : * const wchar_t , __n : usize ) -> usize ; } extern "C" { pub fn rpmatch ( __response : * const :: std :: os :: raw :: c_char ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn getsubopt ( __optionp : * mut * mut :: std :: os :: raw :: c_char , __tokens : * const * const :: std :: os :: raw :: c_char , __valuep : * mut * mut :: std :: os :: raw :: c_char ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn getloadavg ( __loadavg : * mut f64 , __nelem : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn memcpy ( __dest : * mut :: std :: os :: raw :: c_void , __src : * const :: std :: os :: raw :: c_void , __n : usize ) -> * mut :: std :: os :: raw :: c_void ; } extern "C" { pub fn memmove ( __dest : * mut :: std :: os :: raw :: c_void , __src : * const :: std :: os :: raw :: c_void , __n : usize ) -> * mut :: std :: os :: raw :: c_void ; } extern "C" { pub fn memccpy ( __dest : * mut :: std :: os :: raw :: c_void , __src : * const :: std :: os :: raw :: c_void , __c : :: std :: os :: raw :: c_int , __n : usize ) -> * mut :: std :: os :: raw :: c_void ; } extern "C" { pub fn memset ( __s : * mut :: std :: os :: raw :: c_void , __c : :: std :: os :: raw :: c_int , __n : usize ) -> * mut :: std :: os :: raw :: c_void ; } extern "C" { pub fn memcmp ( __s1 : * const :: std :: os :: raw :: c_void , __s2 : * const :: std :: os :: raw :: c_void , __n : usize ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn memchr ( __s : * const :: std :: os :: raw :: c_void , __c : :: std :: os :: raw :: c_int , __n : usize ) -> * mut :: std :: os :: raw :: c_void ; } extern "C" { pub fn strcpy ( __dest : * mut :: std :: os :: raw :: c_char , __src : * const :: std :: os :: raw :: c_char ) -> * mut :: std :: os :: raw :: c_char ; } extern "C" { pub fn strncpy ( __dest : * mut :: std :: os :: raw :: c_char , __src : * const :: std :: os :: raw :: c_char , __n : usize ) -> * mut :: std :: os :: raw :: c_char ; } extern "C" { pub fn strcat ( __dest : * mut :: std :: os :: raw :: c_char , __src : * const :: std :: os :: raw :: c_char ) -> * mut :: std :: os :: raw :: c_char ; } extern "C" { pub fn strncat ( __dest : * mut :: std :: os :: raw :: c_char , __src : * const :: std :: os :: raw :: c_char , __n : usize ) -> * mut :: std :: os :: raw :: c_char ; } extern "C" { pub fn strcmp ( __s1 : * const :: std :: os :: raw :: c_char , __s2 : * const :: std :: os :: raw :: c_char ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn strncmp ( __s1 : * const :: std :: os :: raw :: c_char , __s2 : * const :: std :: os :: raw :: c_char , __n : usize ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn strcoll ( __s1 : * const :: std :: os :: raw :: c_char , __s2 : * const :: std :: os :: raw :: c_char ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn strxfrm ( __dest : * mut :: std :: os :: raw :: c_char , __src : * const :: std :: os :: raw :: c_char , __n : usize ) -> :: std :: os :: raw :: c_ulong ; } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct __locale_struct { pub __locales : [ * mut __locale_data ; 13usize ] , pub __ctype_b : * const :: std :: os :: raw :: c_ushort , pub __ctype_tolower : * const :: std :: os :: raw :: c_int , pub __ctype_toupper : * const :: std :: os :: raw :: c_int , pub __names : [ * const :: std :: os :: raw :: c_char ; 13usize ] , } # [ test ] fn bindgen_test_layout___locale_struct ( ) { assert_eq ! ( :: std :: mem :: size_of :: < __locale_struct > ( ) , 232usize , concat ! ( "Size of: " , stringify ! ( __locale_struct ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < __locale_struct > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( __locale_struct ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < __locale_struct > ( ) ) ) . __locales as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( __locale_struct ) , "::" , stringify ! ( __locales ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < __locale_struct > ( ) ) ) . __ctype_b as * const _ as usize } , 104usize , concat ! ( "Offset of field: " , stringify ! ( __locale_struct ) , "::" , stringify ! ( __ctype_b ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < __locale_struct > ( ) ) ) . __ctype_tolower as * const _ as usize } , 112usize , concat ! ( "Offset of field: " , stringify ! ( __locale_struct ) , "::" , stringify ! ( __ctype_tolower ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < __locale_struct > ( ) ) ) . __ctype_toupper as * const _ as usize } , 120usize , concat ! ( "Offset of field: " , stringify ! ( __locale_struct ) , "::" , stringify ! ( __ctype_toupper ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < __locale_struct > ( ) ) ) . __names as * const _ as usize } , 128usize , concat ! ( "Offset of field: " , stringify ! ( __locale_struct ) , "::" , stringify ! ( __names ) ) ) ; } pub type __locale_t = * mut __locale_struct ; pub type locale_t = __locale_t ; extern "C" { pub fn strcoll_l ( __s1 : * const :: std :: os :: raw :: c_char , __s2 : * const :: std :: os :: raw :: c_char , __l : __locale_t ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn strxfrm_l ( __dest : * mut :: std :: os :: raw :: c_char , __src : * const :: std :: os :: raw :: c_char , __n : usize , __l : __locale_t ) -> usize ; } extern "C" { pub fn strdup ( __s : * const :: std :: os :: raw :: c_char ) -> * mut :: std :: os :: raw :: c_char ; } extern "C" { pub fn strndup ( __string : * const :: std :: os :: raw :: c_char , __n : usize ) -> * mut :: std :: os :: raw :: c_char ; } extern "C" { pub fn strchr ( __s : * const :: std :: os :: raw :: c_char , __c : :: std :: os :: raw :: c_int ) -> * mut :: std :: os :: raw :: c_char ; } extern "C" { pub fn strrchr ( __s : * const :: std :: os :: raw :: c_char , __c : :: std :: os :: raw :: c_int ) -> * mut :: std :: os :: raw :: c_char ; } extern "C" { pub fn strcspn ( __s : * const :: std :: os :: raw :: c_char , __reject : * const :: std :: os :: raw :: c_char ) -> :: std :: os :: raw :: c_ulong ; } extern "C" { pub fn strspn ( __s : * const :: std :: os :: raw :: c_char , __accept : * const :: std :: os :: raw :: c_char ) -> :: std :: os :: raw :: c_ulong ; } extern "C" { pub fn strpbrk ( __s : * const :: std :: os :: raw :: c_char , __accept : * const :: std :: os :: raw :: c_char ) -> * mut :: std :: os :: raw :: c_char ; } extern "C" { pub fn strstr ( __haystack : * const :: std :: os :: raw :: c_char , __needle : * const :: std :: os :: raw :: c_char ) -> * mut :: std :: os :: raw :: c_char ; } extern "C" { pub fn strtok ( __s : * mut :: std :: os :: raw :: c_char , __delim : * const :: std :: os :: raw :: c_char ) -> * mut :: std :: os :: raw :: c_char ; } extern "C" { pub fn __strtok_r ( __s : * mut :: std :: os :: raw :: c_char , __delim : * const :: std :: os :: raw :: c_char , __save_ptr : * mut * mut :: std :: os :: raw :: c_char ) -> * mut :: std :: os :: raw :: c_char ; } extern "C" { pub fn strtok_r ( __s : * mut :: std :: os :: raw :: c_char , __delim : * const :: std :: os :: raw :: c_char , __save_ptr : * mut * mut :: std :: os :: raw :: c_char ) -> * mut :: std :: os :: raw :: c_char ; } extern "C" { pub fn strlen ( __s : * const :: std :: os :: raw :: c_char ) -> :: std :: os :: raw :: c_ulong ; } extern "C" { pub fn strnlen ( __string : * const :: std :: os :: raw :: c_char , __maxlen : usize ) -> usize ; } extern "C" { pub fn strerror ( __errnum : :: std :: os :: raw :: c_int ) -> * mut :: std :: os :: raw :: c_char ; } extern "C" { # [ link_name = "\u{1}__xpg_strerror_r" ] pub fn strerror_r ( __errnum : :: std :: os :: raw :: c_int , __buf : * mut :: std :: os :: raw :: c_char , __buflen : usize ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn strerror_l ( __errnum : :: std :: os :: raw :: c_int , __l : __locale_t ) -> * mut :: std :: os :: raw :: c_char ; } extern "C" { pub fn __bzero ( __s : * mut :: std :: os :: raw :: c_void , __n : usize ) ; } extern "C" { pub fn bcopy ( __src : * const :: std :: os :: raw :: c_void , __dest : * mut :: std :: os :: raw :: c_void , __n : usize ) ; } extern "C" { pub fn bzero ( __s : * mut :: std :: os :: raw :: c_void , __n : usize ) ; } extern "C" { pub fn bcmp ( __s1 : * const :: std :: os :: raw :: c_void , __s2 : * const :: std :: os :: raw :: c_void , __n : usize ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn index ( __s : * const :: std :: os :: raw :: c_char , __c : :: std :: os :: raw :: c_int ) -> * mut :: std :: os :: raw :: c_char ; } extern "C" { pub fn rindex ( __s : * const :: std :: os :: raw :: c_char , __c : :: std :: os :: raw :: c_int ) -> * mut :: std :: os :: raw :: c_char ; } extern "C" { pub fn ffs ( __i : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn strcasecmp ( __s1 : * const :: std :: os :: raw :: c_char , __s2 : * const :: std :: os :: raw :: c_char ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn strncasecmp ( __s1 : * const :: std :: os :: raw :: c_char , __s2 : * const :: std :: os :: raw :: c_char , __n : usize ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn strsep ( __stringp : * mut * mut :: std :: os :: raw :: c_char , __delim : * const :: std :: os :: raw :: c_char ) -> * mut :: std :: os :: raw :: c_char ; } extern "C" { pub fn strsignal ( __sig : :: std :: os :: raw :: c_int ) -> * mut :: std :: os :: raw :: c_char ; } extern "C" { pub fn __stpcpy ( __dest : * mut :: std :: os :: raw :: c_char , __src : * const :: std :: os :: raw :: c_char ) -> * mut :: std :: os :: raw :: c_char ; } extern "C" { pub fn stpcpy ( __dest : * mut :: std :: os :: raw :: c_char , __src : * const :: std :: os :: raw :: c_char ) -> * mut :: std :: os :: raw :: c_char ; } extern "C" { pub fn __stpncpy ( __dest : * mut :: std :: os :: raw :: c_char , __src : * const :: std :: os :: raw :: c_char , __n : usize ) -> * mut :: std :: os :: raw :: c_char ; } extern "C" { pub fn stpncpy ( __dest : * mut :: std :: os :: raw :: c_char , __src : * const :: std :: os :: raw :: c_char , __n : usize ) -> * mut :: std :: os :: raw :: c_char ; } pub type int_least8_t = :: std :: os :: raw :: c_schar ; pub type int_least16_t = :: std :: os :: raw :: c_short ; pub type int_least32_t = :: std :: os :: raw :: c_int ; pub type int_least64_t = :: std :: os :: raw :: c_long ; pub type uint_least8_t = :: std :: os :: raw :: c_uchar ; pub type uint_least16_t = :: std :: os :: raw :: c_ushort ; pub type uint_least32_t = :: std :: os :: raw :: c_uint ; pub type uint_least64_t = :: std :: os :: raw :: c_ulong ; pub type int_fast8_t = :: std :: os :: raw :: c_schar ; pub type int_fast16_t = :: std :: os :: raw :: c_long ; pub type int_fast32_t = :: std :: os :: raw :: c_long ; pub type int_fast64_t = :: std :: os :: raw :: c_long ; pub type uint_fast8_t = :: std :: os :: raw :: c_uchar ; pub type uint_fast16_t = :: std :: os :: raw :: c_ulong ; pub type uint_fast32_t = :: std :: os :: raw :: c_ulong ; pub type uint_fast64_t = :: std :: os :: raw :: c_ulong ; pub type intmax_t = :: std :: os :: raw :: c_long ; pub type uintmax_t = :: std :: os :: raw :: c_ulong ; pub type __gwchar_t = :: std :: os :: raw :: c_int ; # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct imaxdiv_t { pub quot : :: std :: os :: raw :: c_long , pub rem : :: std :: os :: raw :: c_long , } # [ test ] fn bindgen_test_layout_imaxdiv_t ( ) { assert_eq ! ( :: std :: mem :: size_of :: < imaxdiv_t > ( ) , 16usize , concat ! ( "Size of: " , stringify ! ( imaxdiv_t ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < imaxdiv_t > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( imaxdiv_t ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < imaxdiv_t > ( ) ) ) . quot as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( imaxdiv_t ) , "::" , stringify ! ( quot ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < imaxdiv_t > ( ) ) ) . rem as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( imaxdiv_t ) , "::" , stringify ! ( rem ) ) ) ; } extern "C" { pub fn imaxabs ( __n : intmax_t ) -> intmax_t ; } extern "C" { pub fn imaxdiv ( __numer : intmax_t , __denom : intmax_t ) -> imaxdiv_t ; } extern "C" { pub fn strtoimax ( __nptr : * const :: std :: os :: raw :: c_char , __endptr : * mut * mut :: std :: os :: raw :: c_char , __base : :: std :: os :: raw :: c_int ) -> intmax_t ; } extern "C" { pub fn strtoumax ( __nptr : * const :: std :: os :: raw :: c_char , __endptr : * mut * mut :: std :: os :: raw :: c_char , __base : :: std :: os :: raw :: c_int ) -> uintmax_t ; } extern "C" { pub fn wcstoimax ( __nptr : * const __gwchar_t , __endptr : * mut * mut __gwchar_t , __base : :: std :: os :: raw :: c_int ) -> intmax_t ; } extern "C" { pub fn wcstoumax ( __nptr : * const __gwchar_t , __endptr : * mut * mut __gwchar_t , __base : :: std :: os :: raw :: c_int ) -> uintmax_t ; } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct iovec { pub iov_base : * mut :: std :: os :: raw :: c_void , pub iov_len : usize , } # [ test ] fn bindgen_test_layout_iovec ( ) { assert_eq ! ( :: std :: mem :: size_of :: < iovec > ( ) , 16usize , concat ! ( "Size of: " , stringify ! ( iovec ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < iovec > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( iovec ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < iovec > ( ) ) ) . iov_base as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( iovec ) , "::" , stringify ! ( iov_base ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < iovec > ( ) ) ) . iov_len as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( iovec ) , "::" , stringify ! ( iov_len ) ) ) ; } extern "C" { pub fn readv ( __fd : :: std :: os :: raw :: c_int , __iovec : * const iovec , __count : :: std :: os :: raw :: c_int ) -> isize ; } extern "C" { pub fn writev ( __fd : :: std :: os :: raw :: c_int , __iovec : * const iovec , __count : :: std :: os :: raw :: c_int ) -> isize ; } extern "C" { pub fn preadv ( __fd : :: std :: os :: raw :: c_int , __iovec : * const iovec , __count : :: std :: os :: raw :: c_int , __offset : __off_t ) -> isize ; } extern "C" { pub fn pwritev ( __fd : :: std :: os :: raw :: c_int , __iovec : * const iovec , __count : :: std :: os :: raw :: c_int , __offset : __off_t ) -> isize ; } pub type socklen_t = __socklen_t ; pub const __socket_type_SOCK_STREAM : __socket_type = 1 ; pub const __socket_type_SOCK_DGRAM : __socket_type = 2 ; pub const __socket_type_SOCK_RAW : __socket_type = 3 ; pub const __socket_type_SOCK_RDM : __socket_type = 4 ; pub const __socket_type_SOCK_SEQPACKET : __socket_type = 5 ; pub const __socket_type_SOCK_DCCP : __socket_type = 6 ; pub const __socket_type_SOCK_PACKET : __socket_type = 10 ; pub const __socket_type_SOCK_CLOEXEC : __socket_type = 524288 ; pub const __socket_type_SOCK_NONBLOCK : __socket_type = 2048 ; pub type __socket_type = u32 ; pub type sa_family_t = :: std :: os :: raw :: c_ushort ; # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct sockaddr { pub sa_family : sa_family_t , pub sa_data : [ :: std :: os :: raw :: c_char ; 14usize ] , } # [ test ] fn bindgen_test_layout_sockaddr ( ) { assert_eq ! ( :: std :: mem :: size_of :: < sockaddr > ( ) , 16usize , concat ! ( "Size of: " , stringify ! ( sockaddr ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < sockaddr > ( ) , 2usize , concat ! ( "Alignment of " , stringify ! ( sockaddr ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < sockaddr > ( ) ) ) . sa_family as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( sockaddr ) , "::" , stringify ! ( sa_family ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < sockaddr > ( ) ) ) . sa_data as * const _ as usize } , 2usize , concat ! ( "Offset of field: " , stringify ! ( sockaddr ) , "::" , stringify ! ( sa_data ) ) ) ; } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub struct sockaddr_storage { pub ss_family : sa_family_t , pub __ss_padding : [ :: std :: os :: raw :: c_char ; 118usize ] , pub __ss_align : :: std :: os :: raw :: c_ulong , } # [ test ] fn bindgen_test_layout_sockaddr_storage ( ) { assert_eq ! ( :: std :: mem :: size_of :: < sockaddr_storage > ( ) , 128usize , concat ! ( "Size of: " , stringify ! ( sockaddr_storage ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < sockaddr_storage > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( sockaddr_storage ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < sockaddr_storage > ( ) ) ) . ss_family as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( sockaddr_storage ) , "::" , stringify ! ( ss_family ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < sockaddr_storage > ( ) ) ) . __ss_padding as * const _ as usize } , 2usize , concat ! ( "Offset of field: " , stringify ! ( sockaddr_storage ) , "::" , stringify ! ( __ss_padding ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < sockaddr_storage > ( ) ) ) . __ss_align as * const _ as usize } , 120usize , concat ! ( "Offset of field: " , stringify ! ( sockaddr_storage ) , "::" , stringify ! ( __ss_align ) ) ) ; } pub const MSG_OOB : _bindgen_ty_1 = 1 ; pub const MSG_PEEK : _bindgen_ty_1 = 2 ; pub const MSG_DONTROUTE : _bindgen_ty_1 = 4 ; pub const MSG_CTRUNC : _bindgen_ty_1 = 8 ; pub const MSG_PROXY : _bindgen_ty_1 = 16 ; pub const MSG_TRUNC : _bindgen_ty_1 = 32 ; pub const MSG_DONTWAIT : _bindgen_ty_1 = 64 ; pub const MSG_EOR : _bindgen_ty_1 = 128 ; pub const MSG_WAITALL : _bindgen_ty_1 = 256 ; pub const MSG_FIN : _bindgen_ty_1 = 512 ; pub const MSG_SYN : _bindgen_ty_1 = 1024 ; pub const MSG_CONFIRM : _bindgen_ty_1 = 2048 ; pub const MSG_RST : _bindgen_ty_1 = 4096 ; pub const MSG_ERRQUEUE : _bindgen_ty_1 = 8192 ; pub const MSG_NOSIGNAL : _bindgen_ty_1 = 16384 ; pub const MSG_MORE : _bindgen_ty_1 = 32768 ; pub const MSG_WAITFORONE : _bindgen_ty_1 = 65536 ; pub const MSG_FASTOPEN : _bindgen_ty_1 = 536870912 ; pub const MSG_CMSG_CLOEXEC : _bindgen_ty_1 = 1073741824 ; pub type _bindgen_ty_1 = u32 ; # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct msghdr { pub msg_name : * mut :: std :: os :: raw :: c_void , pub msg_namelen : socklen_t , pub msg_iov : * mut iovec , pub msg_iovlen : usize , pub msg_control : * mut :: std :: os :: raw :: c_void , pub msg_controllen : usize , pub msg_flags : :: std :: os :: raw :: c_int , } # [ test ] fn bindgen_test_layout_msghdr ( ) { assert_eq ! ( :: std :: mem :: size_of :: < msghdr > ( ) , 56usize , concat ! ( "Size of: " , stringify ! ( msghdr ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < msghdr > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( msghdr ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < msghdr > ( ) ) ) . msg_name as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( msghdr ) , "::" , stringify ! ( msg_name ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < msghdr > ( ) ) ) . msg_namelen as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( msghdr ) , "::" , stringify ! ( msg_namelen ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < msghdr > ( ) ) ) . msg_iov as * const _ as usize } , 16usize , concat ! ( "Offset of field: " , stringify ! ( msghdr ) , "::" , stringify ! ( msg_iov ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < msghdr > ( ) ) ) . msg_iovlen as * const _ as usize } , 24usize , concat ! ( "Offset of field: " , stringify ! ( msghdr ) , "::" , stringify ! ( msg_iovlen ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < msghdr > ( ) ) ) . msg_control as * const _ as usize } , 32usize , concat ! ( "Offset of field: " , stringify ! ( msghdr ) , "::" , stringify ! ( msg_control ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < msghdr > ( ) ) ) . msg_controllen as * const _ as usize } , 40usize , concat ! ( "Offset of field: " , stringify ! ( msghdr ) , "::" , stringify ! ( msg_controllen ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < msghdr > ( ) ) ) . msg_flags as * const _ as usize } , 48usize , concat ! ( "Offset of field: " , stringify ! ( msghdr ) , "::" , stringify ! ( msg_flags ) ) ) ; } # [ repr ( C ) ] # [ derive ( Debug ) ] pub struct cmsghdr { pub cmsg_len : usize , pub cmsg_level : :: std :: os :: raw :: c_int , pub cmsg_type : :: std :: os :: raw :: c_int , pub __cmsg_data : __IncompleteArrayField < :: std :: os :: raw :: c_uchar > , } # [ test ] fn bindgen_test_layout_cmsghdr ( ) { assert_eq ! ( :: std :: mem :: size_of :: < cmsghdr > ( ) , 16usize , concat ! ( "Size of: " , stringify ! ( cmsghdr ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < cmsghdr > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( cmsghdr ) ) ) ; } extern "C" { pub fn __cmsg_nxthdr ( __mhdr : * mut msghdr , __cmsg : * mut cmsghdr ) -> * mut cmsghdr ; } pub const SCM_RIGHTS : _bindgen_ty_2 = 1 ; pub type _bindgen_ty_2 = u32 ; # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct linger { pub l_onoff : :: std :: os :: raw :: c_int , pub l_linger : :: std :: os :: raw :: c_int , } # [ test ] fn bindgen_test_layout_linger ( ) { assert_eq ! ( :: std :: mem :: size_of :: < linger > ( ) , 8usize , concat ! ( "Size of: " , stringify ! ( linger ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < linger > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( linger ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < linger > ( ) ) ) . l_onoff as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( linger ) , "::" , stringify ! ( l_onoff ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < linger > ( ) ) ) . l_linger as * const _ as usize } , 4usize , concat ! ( "Offset of field: " , stringify ! ( linger ) , "::" , stringify ! ( l_linger ) ) ) ; } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct osockaddr { pub sa_family : :: std :: os :: raw :: c_ushort , pub sa_data : [ :: std :: os :: raw :: c_uchar ; 14usize ] , } # [ test ] fn bindgen_test_layout_osockaddr ( ) { assert_eq ! ( :: std :: mem :: size_of :: < osockaddr > ( ) , 16usize , concat ! ( "Size of: " , stringify ! ( osockaddr ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < osockaddr > ( ) , 2usize , concat ! ( "Alignment of " , stringify ! ( osockaddr ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < osockaddr > ( ) ) ) . sa_family as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( osockaddr ) , "::" , stringify ! ( sa_family ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < osockaddr > ( ) ) ) . sa_data as * const _ as usize } , 2usize , concat ! ( "Offset of field: " , stringify ! ( osockaddr ) , "::" , stringify ! ( sa_data ) ) ) ; } pub const SHUT_RD : _bindgen_ty_3 = 0 ; pub const SHUT_WR : _bindgen_ty_3 = 1 ; pub const SHUT_RDWR : _bindgen_ty_3 = 2 ; pub type _bindgen_ty_3 = u32 ; extern "C" { pub fn socket ( __domain : :: std :: os :: raw :: c_int , __type : :: std :: os :: raw :: c_int , __protocol : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn socketpair ( __domain : :: std :: os :: raw :: c_int , __type : :: std :: os :: raw :: c_int , __protocol : :: std :: os :: raw :: c_int , __fds : * mut :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn bind ( __fd : :: std :: os :: raw :: c_int , __addr : * const sockaddr , __len : socklen_t ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn getsockname ( __fd : :: std :: os :: raw :: c_int , __addr : * mut sockaddr , __len : * mut socklen_t ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn connect ( __fd : :: std :: os :: raw :: c_int , __addr : * const sockaddr , __len : socklen_t ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn getpeername ( __fd : :: std :: os :: raw :: c_int , __addr : * mut sockaddr , __len : * mut socklen_t ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn send ( __fd : :: std :: os :: raw :: c_int , __buf : * const :: std :: os :: raw :: c_void , __n : usize , __flags : :: std :: os :: raw :: c_int ) -> isize ; } extern "C" { pub fn recv ( __fd : :: std :: os :: raw :: c_int , __buf : * mut :: std :: os :: raw :: c_void , __n : usize , __flags : :: std :: os :: raw :: c_int ) -> isize ; } extern "C" { pub fn sendto ( __fd : :: std :: os :: raw :: c_int , __buf : * const :: std :: os :: raw :: c_void , __n : usize , __flags : :: std :: os :: raw :: c_int , __addr : * const sockaddr , __addr_len : socklen_t ) -> isize ; } extern "C" { pub fn recvfrom ( __fd : :: std :: os :: raw :: c_int , __buf : * mut :: std :: os :: raw :: c_void , __n : usize , __flags : :: std :: os :: raw :: c_int , __addr : * mut sockaddr , __addr_len : * mut socklen_t ) -> isize ; } extern "C" { pub fn sendmsg ( __fd : :: std :: os :: raw :: c_int , __message : * const msghdr , __flags : :: std :: os :: raw :: c_int ) -> isize ; } extern "C" { pub fn recvmsg ( __fd : :: std :: os :: raw :: c_int , __message : * mut msghdr , __flags : :: std :: os :: raw :: c_int ) -> isize ; } extern "C" { pub fn getsockopt ( __fd : :: std :: os :: raw :: c_int , __level : :: std :: os :: raw :: c_int , __optname : :: std :: os :: raw :: c_int , __optval : * mut :: std :: os :: raw :: c_void , __optlen : * mut socklen_t ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn setsockopt ( __fd : :: std :: os :: raw :: c_int , __level : :: std :: os :: raw :: c_int , __optname : :: std :: os :: raw :: c_int , __optval : * const :: std :: os :: raw :: c_void , __optlen : socklen_t ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn listen ( __fd : :: std :: os :: raw :: c_int , __n : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn accept ( __fd : :: std :: os :: raw :: c_int , __addr : * mut sockaddr , __addr_len : * mut socklen_t ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn shutdown ( __fd : :: std :: os :: raw :: c_int , __how : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn sockatmark ( __fd : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn isfdtype ( __fd : :: std :: os :: raw :: c_int , __fdtype : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } pub type in_addr_t = u32 ; # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct in_addr { pub s_addr : in_addr_t , } # [ test ] fn bindgen_test_layout_in_addr ( ) { assert_eq ! ( :: std :: mem :: size_of :: < in_addr > ( ) , 4usize , concat ! ( "Size of: " , stringify ! ( in_addr ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < in_addr > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( in_addr ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < in_addr > ( ) ) ) . s_addr as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( in_addr ) , "::" , stringify ! ( s_addr ) ) ) ; } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub struct ip_opts { pub ip_dst : in_addr , pub ip_opts : [ :: std :: os :: raw :: c_char ; 40usize ] , } # [ test ] fn bindgen_test_layout_ip_opts ( ) { assert_eq ! ( :: std :: mem :: size_of :: < ip_opts > ( ) , 44usize , concat ! ( "Size of: " , stringify ! ( ip_opts ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < ip_opts > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( ip_opts ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < ip_opts > ( ) ) ) . ip_dst as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( ip_opts ) , "::" , stringify ! ( ip_dst ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < ip_opts > ( ) ) ) . ip_opts as * const _ as usize } , 4usize , concat ! ( "Offset of field: " , stringify ! ( ip_opts ) , "::" , stringify ! ( ip_opts ) ) ) ; } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct ip_mreqn { pub imr_multiaddr : in_addr , pub imr_address : in_addr , pub imr_ifindex : :: std :: os :: raw :: c_int , } # [ test ] fn bindgen_test_layout_ip_mreqn ( ) { assert_eq ! ( :: std :: mem :: size_of :: < ip_mreqn > ( ) , 12usize , concat ! ( "Size of: " , stringify ! ( ip_mreqn ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < ip_mreqn > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( ip_mreqn ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < ip_mreqn > ( ) ) ) . imr_multiaddr as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( ip_mreqn ) , "::" , stringify ! ( imr_multiaddr ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < ip_mreqn > ( ) ) ) . imr_address as * const _ as usize } , 4usize , concat ! ( "Offset of field: " , stringify ! ( ip_mreqn ) , "::" , stringify ! ( imr_address ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < ip_mreqn > ( ) ) ) . imr_ifindex as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( ip_mreqn ) , "::" , stringify ! ( imr_ifindex ) ) ) ; } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct in_pktinfo { pub ipi_ifindex : :: std :: os :: raw :: c_int , pub ipi_spec_dst : in_addr , pub ipi_addr : in_addr , } # [ test ] fn bindgen_test_layout_in_pktinfo ( ) { assert_eq ! ( :: std :: mem :: size_of :: < in_pktinfo > ( ) , 12usize , concat ! ( "Size of: " , stringify ! ( in_pktinfo ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < in_pktinfo > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( in_pktinfo ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < in_pktinfo > ( ) ) ) . ipi_ifindex as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( in_pktinfo ) , "::" , stringify ! ( ipi_ifindex ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < in_pktinfo > ( ) ) ) . ipi_spec_dst as * const _ as usize } , 4usize , concat ! ( "Offset of field: " , stringify ! ( in_pktinfo ) , "::" , stringify ! ( ipi_spec_dst ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < in_pktinfo > ( ) ) ) . ipi_addr as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( in_pktinfo ) , "::" , stringify ! ( ipi_addr ) ) ) ; } pub const IPPROTO_IP : _bindgen_ty_4 = 0 ; pub const IPPROTO_ICMP : _bindgen_ty_4 = 1 ; pub const IPPROTO_IGMP : _bindgen_ty_4 = 2 ; pub const IPPROTO_IPIP : _bindgen_ty_4 = 4 ; pub const IPPROTO_TCP : _bindgen_ty_4 = 6 ; pub const IPPROTO_EGP : _bindgen_ty_4 = 8 ; pub const IPPROTO_PUP : _bindgen_ty_4 = 12 ; pub const IPPROTO_UDP : _bindgen_ty_4 = 17 ; pub const IPPROTO_IDP : _bindgen_ty_4 = 22 ; pub const IPPROTO_TP : _bindgen_ty_4 = 29 ; pub const IPPROTO_DCCP : _bindgen_ty_4 = 33 ; pub const IPPROTO_IPV6 : _bindgen_ty_4 = 41 ; pub const IPPROTO_RSVP : _bindgen_ty_4 = 46 ; pub const IPPROTO_GRE : _bindgen_ty_4 = 47 ; pub const IPPROTO_ESP : _bindgen_ty_4 = 50 ; pub const IPPROTO_AH : _bindgen_ty_4 = 51 ; pub const IPPROTO_MTP : _bindgen_ty_4 = 92 ; pub const IPPROTO_BEETPH : _bindgen_ty_4 = 94 ; pub const IPPROTO_ENCAP : _bindgen_ty_4 = 98 ; pub const IPPROTO_PIM : _bindgen_ty_4 = 103 ; pub const IPPROTO_COMP : _bindgen_ty_4 = 108 ; pub const IPPROTO_SCTP : _bindgen_ty_4 = 132 ; pub const IPPROTO_UDPLITE : _bindgen_ty_4 = 136 ; pub const IPPROTO_MPLS : _bindgen_ty_4 = 137 ; pub const IPPROTO_RAW : _bindgen_ty_4 = 255 ; pub const IPPROTO_MAX : _bindgen_ty_4 = 256 ; pub type _bindgen_ty_4 = u32 ; pub const IPPROTO_HOPOPTS : _bindgen_ty_5 = 0 ; pub const IPPROTO_ROUTING : _bindgen_ty_5 = 43 ; pub const IPPROTO_FRAGMENT : _bindgen_ty_5 = 44 ; pub const IPPROTO_ICMPV6 : _bindgen_ty_5 = 58 ; pub const IPPROTO_NONE : _bindgen_ty_5 = 59 ; pub const IPPROTO_DSTOPTS : _bindgen_ty_5 = 60 ; pub const IPPROTO_MH : _bindgen_ty_5 = 135 ; pub type _bindgen_ty_5 = u32 ; pub type in_port_t = u16 ; pub const IPPORT_ECHO : _bindgen_ty_6 = 7 ; pub const IPPORT_DISCARD : _bindgen_ty_6 = 9 ; pub const IPPORT_SYSTAT : _bindgen_ty_6 = 11 ; pub const IPPORT_DAYTIME : _bindgen_ty_6 = 13 ; pub const IPPORT_NETSTAT : _bindgen_ty_6 = 15 ; pub const IPPORT_FTP : _bindgen_ty_6 = 21 ; pub const IPPORT_TELNET : _bindgen_ty_6 = 23 ; pub const IPPORT_SMTP : _bindgen_ty_6 = 25 ; pub const IPPORT_TIMESERVER : _bindgen_ty_6 = 37 ; pub const IPPORT_NAMESERVER : _bindgen_ty_6 = 42 ; pub const IPPORT_WHOIS : _bindgen_ty_6 = 43 ; pub const IPPORT_MTP : _bindgen_ty_6 = 57 ; pub const IPPORT_TFTP : _bindgen_ty_6 = 69 ; pub const IPPORT_RJE : _bindgen_ty_6 = 77 ; pub const IPPORT_FINGER : _bindgen_ty_6 = 79 ; pub const IPPORT_TTYLINK : _bindgen_ty_6 = 87 ; pub const IPPORT_SUPDUP : _bindgen_ty_6 = 95 ; pub const IPPORT_EXECSERVER : _bindgen_ty_6 = 512 ; pub const IPPORT_LOGINSERVER : _bindgen_ty_6 = 513 ; pub const IPPORT_CMDSERVER : _bindgen_ty_6 = 514 ; pub const IPPORT_EFSSERVER : _bindgen_ty_6 = 520 ; pub const IPPORT_BIFFUDP : _bindgen_ty_6 = 512 ; pub const IPPORT_WHOSERVER : _bindgen_ty_6 = 513 ; pub const IPPORT_ROUTESERVER : _bindgen_ty_6 = 520 ; pub const IPPORT_RESERVED : _bindgen_ty_6 = 1024 ; pub const IPPORT_USERRESERVED : _bindgen_ty_6 = 5000 ; pub type _bindgen_ty_6 = u32 ; # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub struct in6_addr { pub __in6_u : in6_addr__bindgen_ty_1 , } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union in6_addr__bindgen_ty_1 { pub __u6_addr8 : [ u8 ; 16usize ] , pub __u6_addr16 : [ u16 ; 8usize ] , pub __u6_addr32 : [ u32 ; 4usize ] , _bindgen_union_align : [ u32 ; 4usize ] , } # [ test ] fn bindgen_test_layout_in6_addr__bindgen_ty_1 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < in6_addr__bindgen_ty_1 > ( ) , 16usize , concat ! ( "Size of: " , stringify ! ( in6_addr__bindgen_ty_1 ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < in6_addr__bindgen_ty_1 > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( in6_addr__bindgen_ty_1 ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < in6_addr__bindgen_ty_1 > ( ) ) ) . __u6_addr8 as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( in6_addr__bindgen_ty_1 ) , "::" , stringify ! ( __u6_addr8 ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < in6_addr__bindgen_ty_1 > ( ) ) ) . __u6_addr16 as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( in6_addr__bindgen_ty_1 ) , "::" , stringify ! ( __u6_addr16 ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < in6_addr__bindgen_ty_1 > ( ) ) ) . __u6_addr32 as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( in6_addr__bindgen_ty_1 ) , "::" , stringify ! ( __u6_addr32 ) ) ) ; } # [ test ] fn bindgen_test_layout_in6_addr ( ) { assert_eq ! ( :: std :: mem :: size_of :: < in6_addr > ( ) , 16usize , concat ! ( "Size of: " , stringify ! ( in6_addr ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < in6_addr > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( in6_addr ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < in6_addr > ( ) ) ) . __in6_u as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( in6_addr ) , "::" , stringify ! ( __in6_u ) ) ) ; } extern "C" { # [ link_name = "\u{1}in6addr_any" ] pub static mut in6addr_any : in6_addr ; } extern "C" { # [ link_name = "\u{1}in6addr_loopback" ] pub static mut in6addr_loopback : in6_addr ; } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct sockaddr_in { pub sin_family : sa_family_t , pub sin_port : in_port_t , pub sin_addr : in_addr , pub sin_zero : [ :: std :: os :: raw :: c_uchar ; 8usize ] , } # [ test ] fn bindgen_test_layout_sockaddr_in ( ) { assert_eq ! ( :: std :: mem :: size_of :: < sockaddr_in > ( ) , 16usize , concat ! ( "Size of: " , stringify ! ( sockaddr_in ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < sockaddr_in > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( sockaddr_in ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < sockaddr_in > ( ) ) ) . sin_family as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( sockaddr_in ) , "::" , stringify ! ( sin_family ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < sockaddr_in > ( ) ) ) . sin_port as * const _ as usize } , 2usize , concat ! ( "Offset of field: " , stringify ! ( sockaddr_in ) , "::" , stringify ! ( sin_port ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < sockaddr_in > ( ) ) ) . sin_addr as * const _ as usize } , 4usize , concat ! ( "Offset of field: " , stringify ! ( sockaddr_in ) , "::" , stringify ! ( sin_addr ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < sockaddr_in > ( ) ) ) . sin_zero as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( sockaddr_in ) , "::" , stringify ! ( sin_zero ) ) ) ; } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub struct sockaddr_in6 { pub sin6_family : sa_family_t , pub sin6_port : in_port_t , pub sin6_flowinfo : u32 , pub sin6_addr : in6_addr , pub sin6_scope_id : u32 , } # [ test ] fn bindgen_test_layout_sockaddr_in6 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < sockaddr_in6 > ( ) , 28usize , concat ! ( "Size of: " , stringify ! ( sockaddr_in6 ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < sockaddr_in6 > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( sockaddr_in6 ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < sockaddr_in6 > ( ) ) ) . sin6_family as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( sockaddr_in6 ) , "::" , stringify ! ( sin6_family ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < sockaddr_in6 > ( ) ) ) . sin6_port as * const _ as usize } , 2usize , concat ! ( "Offset of field: " , stringify ! ( sockaddr_in6 ) , "::" , stringify ! ( sin6_port ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < sockaddr_in6 > ( ) ) ) . sin6_flowinfo as * const _ as usize } , 4usize , concat ! ( "Offset of field: " , stringify ! ( sockaddr_in6 ) , "::" , stringify ! ( sin6_flowinfo ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < sockaddr_in6 > ( ) ) ) . sin6_addr as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( sockaddr_in6 ) , "::" , stringify ! ( sin6_addr ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < sockaddr_in6 > ( ) ) ) . sin6_scope_id as * const _ as usize } , 24usize , concat ! ( "Offset of field: " , stringify ! ( sockaddr_in6 ) , "::" , stringify ! ( sin6_scope_id ) ) ) ; } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct ip_mreq { pub imr_multiaddr : in_addr , pub imr_interface : in_addr , } # [ test ] fn bindgen_test_layout_ip_mreq ( ) { assert_eq ! ( :: std :: mem :: size_of :: < ip_mreq > ( ) , 8usize , concat ! ( "Size of: " , stringify ! ( ip_mreq ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < ip_mreq > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( ip_mreq ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < ip_mreq > ( ) ) ) . imr_multiaddr as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( ip_mreq ) , "::" , stringify ! ( imr_multiaddr ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < ip_mreq > ( ) ) ) . imr_interface as * const _ as usize } , 4usize , concat ! ( "Offset of field: " , stringify ! ( ip_mreq ) , "::" , stringify ! ( imr_interface ) ) ) ; } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct ip_mreq_source { pub imr_multiaddr : in_addr , pub imr_interface : in_addr , pub imr_sourceaddr : in_addr , } # [ test ] fn bindgen_test_layout_ip_mreq_source ( ) { assert_eq ! ( :: std :: mem :: size_of :: < ip_mreq_source > ( ) , 12usize , concat ! ( "Size of: " , stringify ! ( ip_mreq_source ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < ip_mreq_source > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( ip_mreq_source ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < ip_mreq_source > ( ) ) ) . imr_multiaddr as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( ip_mreq_source ) , "::" , stringify ! ( imr_multiaddr ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < ip_mreq_source > ( ) ) ) . imr_interface as * const _ as usize } , 4usize , concat ! ( "Offset of field: " , stringify ! ( ip_mreq_source ) , "::" , stringify ! ( imr_interface ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < ip_mreq_source > ( ) ) ) . imr_sourceaddr as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( ip_mreq_source ) , "::" , stringify ! ( imr_sourceaddr ) ) ) ; } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub struct ipv6_mreq { pub ipv6mr_multiaddr : in6_addr , pub ipv6mr_interface : :: std :: os :: raw :: c_uint , } # [ test ] fn bindgen_test_layout_ipv6_mreq ( ) { assert_eq ! ( :: std :: mem :: size_of :: < ipv6_mreq > ( ) , 20usize , concat ! ( "Size of: " , stringify ! ( ipv6_mreq ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < ipv6_mreq > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( ipv6_mreq ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < ipv6_mreq > ( ) ) ) . ipv6mr_multiaddr as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( ipv6_mreq ) , "::" , stringify ! ( ipv6mr_multiaddr ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < ipv6_mreq > ( ) ) ) . ipv6mr_interface as * const _ as usize } , 16usize , concat ! ( "Offset of field: " , stringify ! ( ipv6_mreq ) , "::" , stringify ! ( ipv6mr_interface ) ) ) ; } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub struct group_req { pub gr_interface : u32 , pub gr_group : sockaddr_storage , } # [ test ] fn bindgen_test_layout_group_req ( ) { assert_eq ! ( :: std :: mem :: size_of :: < group_req > ( ) , 136usize , concat ! ( "Size of: " , stringify ! ( group_req ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < group_req > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( group_req ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < group_req > ( ) ) ) . gr_interface as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( group_req ) , "::" , stringify ! ( gr_interface ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < group_req > ( ) ) ) . gr_group as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( group_req ) , "::" , stringify ! ( gr_group ) ) ) ; } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub struct group_source_req { pub gsr_interface : u32 , pub gsr_group : sockaddr_storage , pub gsr_source : sockaddr_storage , } # [ test ] fn bindgen_test_layout_group_source_req ( ) { assert_eq ! ( :: std :: mem :: size_of :: < group_source_req > ( ) , 264usize , concat ! ( "Size of: " , stringify ! ( group_source_req ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < group_source_req > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( group_source_req ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < group_source_req > ( ) ) ) . gsr_interface as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( group_source_req ) , "::" , stringify ! ( gsr_interface ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < group_source_req > ( ) ) ) . gsr_group as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( group_source_req ) , "::" , stringify ! ( gsr_group ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < group_source_req > ( ) ) ) . gsr_source as * const _ as usize } , 136usize , concat ! ( "Offset of field: " , stringify ! ( group_source_req ) , "::" , stringify ! ( gsr_source ) ) ) ; } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct ip_msfilter { pub imsf_multiaddr : in_addr , pub imsf_interface : in_addr , pub imsf_fmode : u32 , pub imsf_numsrc : u32 , pub imsf_slist : [ in_addr ; 1usize ] , } # [ test ] fn bindgen_test_layout_ip_msfilter ( ) { assert_eq ! ( :: std :: mem :: size_of :: < ip_msfilter > ( ) , 20usize , concat ! ( "Size of: " , stringify ! ( ip_msfilter ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < ip_msfilter > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( ip_msfilter ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < ip_msfilter > ( ) ) ) . imsf_multiaddr as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( ip_msfilter ) , "::" , stringify ! ( imsf_multiaddr ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < ip_msfilter > ( ) ) ) . imsf_interface as * const _ as usize } , 4usize , concat ! ( "Offset of field: " , stringify ! ( ip_msfilter ) , "::" , stringify ! ( imsf_interface ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < ip_msfilter > ( ) ) ) . imsf_fmode as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( ip_msfilter ) , "::" , stringify ! ( imsf_fmode ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < ip_msfilter > ( ) ) ) . imsf_numsrc as * const _ as usize } , 12usize , concat ! ( "Offset of field: " , stringify ! ( ip_msfilter ) , "::" , stringify ! ( imsf_numsrc ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < ip_msfilter > ( ) ) ) . imsf_slist as * const _ as usize } , 16usize , concat ! ( "Offset of field: " , stringify ! ( ip_msfilter ) , "::" , stringify ! ( imsf_slist ) ) ) ; } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub struct group_filter { pub gf_interface : u32 , pub gf_group : sockaddr_storage , pub gf_fmode : u32 , pub gf_numsrc : u32 , pub gf_slist : [ sockaddr_storage ; 1usize ] , } # [ test ] fn bindgen_test_layout_group_filter ( ) { assert_eq ! ( :: std :: mem :: size_of :: < group_filter > ( ) , 272usize , concat ! ( "Size of: " , stringify ! ( group_filter ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < group_filter > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( group_filter ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < group_filter > ( ) ) ) . gf_interface as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( group_filter ) , "::" , stringify ! ( gf_interface ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < group_filter > ( ) ) ) . gf_group as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( group_filter ) , "::" , stringify ! ( gf_group ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < group_filter > ( ) ) ) . gf_fmode as * const _ as usize } , 136usize , concat ! ( "Offset of field: " , stringify ! ( group_filter ) , "::" , stringify ! ( gf_fmode ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < group_filter > ( ) ) ) . gf_numsrc as * const _ as usize } , 140usize , concat ! ( "Offset of field: " , stringify ! ( group_filter ) , "::" , stringify ! ( gf_numsrc ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < group_filter > ( ) ) ) . gf_slist as * const _ as usize } , 144usize , concat ! ( "Offset of field: " , stringify ! ( group_filter ) , "::" , stringify ! ( gf_slist ) ) ) ; } extern "C" { pub fn ntohl ( __netlong : u32 ) -> u32 ; } extern "C" { pub fn ntohs ( __netshort : u16 ) -> u16 ; } extern "C" { pub fn htonl ( __hostlong : u32 ) -> u32 ; } extern "C" { pub fn htons ( __hostshort : u16 ) -> u16 ; } extern "C" { pub fn bindresvport ( __sockfd : :: std :: os :: raw :: c_int , __sock_in : * mut sockaddr_in ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn bindresvport6 ( __sockfd : :: std :: os :: raw :: c_int , __sock_in : * mut sockaddr_in6 ) -> :: std :: os :: raw :: c_int ; } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct asn_codec_ctx_s { pub max_stack_size : usize , } # [ test ] fn bindgen_test_layout_asn_codec_ctx_s ( ) { assert_eq ! ( :: std :: mem :: size_of :: < asn_codec_ctx_s > ( ) , 8usize , concat ! ( "Size of: " , stringify ! ( asn_codec_ctx_s ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < asn_codec_ctx_s > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( asn_codec_ctx_s ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < asn_codec_ctx_s > ( ) ) ) . max_stack_size as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( asn_codec_ctx_s ) , "::" , stringify ! ( max_stack_size ) ) ) ; } pub type asn_codec_ctx_t = asn_codec_ctx_s ; # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct asn_enc_rval_s { pub encoded : isize , pub failed_type : * mut asn_TYPE_descriptor_s , pub structure_ptr : * mut :: std :: os :: raw :: c_void , } # [ test ] fn bindgen_test_layout_asn_enc_rval_s ( ) { assert_eq ! ( :: std :: mem :: size_of :: < asn_enc_rval_s > ( ) , 24usize , concat ! ( "Size of: " , stringify ! ( asn_enc_rval_s ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < asn_enc_rval_s > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( asn_enc_rval_s ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < asn_enc_rval_s > ( ) ) ) . encoded as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( asn_enc_rval_s ) , "::" , stringify ! ( encoded ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < asn_enc_rval_s > ( ) ) ) . failed_type as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( asn_enc_rval_s ) , "::" , stringify ! ( failed_type ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < asn_enc_rval_s > ( ) ) ) . structure_ptr as * const _ as usize } , 16usize , concat ! ( "Offset of field: " , stringify ! ( asn_enc_rval_s ) , "::" , stringify ! ( structure_ptr ) ) ) ; } pub type asn_enc_rval_t = asn_enc_rval_s ; pub const asn_dec_rval_code_e_RC_OK : asn_dec_rval_code_e = 0 ; pub const asn_dec_rval_code_e_RC_WMORE : asn_dec_rval_code_e = 1 ; pub const asn_dec_rval_code_e_RC_FAIL : asn_dec_rval_code_e = 2 ; pub type asn_dec_rval_code_e = u32 ; # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct asn_dec_rval_s { pub code : asn_dec_rval_code_e , pub consumed : usize , } # [ test ] fn bindgen_test_layout_asn_dec_rval_s ( ) { assert_eq ! ( :: std :: mem :: size_of :: < asn_dec_rval_s > ( ) , 16usize , concat ! ( "Size of: " , stringify ! ( asn_dec_rval_s ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < asn_dec_rval_s > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( asn_dec_rval_s ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < asn_dec_rval_s > ( ) ) ) . code as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( asn_dec_rval_s ) , "::" , stringify ! ( code ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < asn_dec_rval_s > ( ) ) ) . consumed as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( asn_dec_rval_s ) , "::" , stringify ! ( consumed ) ) ) ; } pub type asn_dec_rval_t = asn_dec_rval_s ; pub type asn_app_consume_bytes_f = :: std :: option :: Option < unsafe extern "C" fn ( buffer : * const :: std :: os :: raw :: c_void , size : usize , application_specific_key : * mut :: std :: os :: raw :: c_void ) -> :: std :: os :: raw :: c_int > ; pub type asn_app_constraint_failed_f = :: std :: option :: Option < unsafe extern "C" fn ( application_specific_key : * mut :: std :: os :: raw :: c_void , type_descriptor_which_failed : * mut asn_TYPE_descriptor_s , structure_which_failed_ptr : * const :: std :: os :: raw :: c_void , error_message_format : * const :: std :: os :: raw :: c_char , ... ) > ; pub type ber_tlv_len_t = isize ; extern "C" { pub fn ber_fetch_length ( _is_constructed : :: std :: os :: raw :: c_int , bufptr : * const :: std :: os :: raw :: c_void , size : usize , len_r : * mut ber_tlv_len_t ) -> isize ; } extern "C" { pub fn ber_skip_length ( opt_codec_ctx : * mut asn_codec_ctx_s , _is_constructed : :: std :: os :: raw :: c_int , bufptr : * const :: std :: os :: raw :: c_void , size : usize ) -> isize ; } extern "C" { pub fn der_tlv_length_serialize ( len : ber_tlv_len_t , bufptr : * mut :: std :: os :: raw :: c_void , size : usize ) -> usize ; } pub const asn_tag_class_ASN_TAG_CLASS_UNIVERSAL : asn_tag_class = 0 ; pub const asn_tag_class_ASN_TAG_CLASS_APPLICATION : asn_tag_class = 1 ; pub const asn_tag_class_ASN_TAG_CLASS_CONTEXT : asn_tag_class = 2 ; pub const asn_tag_class_ASN_TAG_CLASS_PRIVATE : asn_tag_class = 3 ; pub type asn_tag_class = u32 ; pub type ber_tlv_tag_t = :: std :: os :: raw :: c_uint ; extern "C" { pub fn ber_tlv_tag_snprint ( tag : ber_tlv_tag_t , buf : * mut :: std :: os :: raw :: c_char , buflen : usize ) -> isize ; } extern "C" { pub fn ber_tlv_tag_fwrite ( tag : ber_tlv_tag_t , arg1 : * mut FILE ) -> isize ; } extern "C" { pub fn ber_tlv_tag_string ( tag : ber_tlv_tag_t ) -> * mut :: std :: os :: raw :: c_char ; } extern "C" { pub fn ber_fetch_tag ( bufptr : * const :: std :: os :: raw :: c_void , size : usize , tag_r : * mut ber_tlv_tag_t ) -> isize ; } extern "C" { pub fn ber_tlv_tag_serialize ( tag : ber_tlv_tag_t , bufptr : * mut :: std :: os :: raw :: c_void , size : usize ) -> usize ; } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct asn_struct_ctx_s { pub phase : :: std :: os :: raw :: c_short , pub step : :: std :: os :: raw :: c_short , pub context : :: std :: os :: raw :: c_int , pub ptr : * mut :: std :: os :: raw :: c_void , pub left : ber_tlv_len_t , } # [ test ] fn bindgen_test_layout_asn_struct_ctx_s ( ) { assert_eq ! ( :: std :: mem :: size_of :: < asn_struct_ctx_s > ( ) , 24usize , concat ! ( "Size of: " , stringify ! ( asn_struct_ctx_s ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < asn_struct_ctx_s > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( asn_struct_ctx_s ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < asn_struct_ctx_s > ( ) ) ) . phase as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( asn_struct_ctx_s ) , "::" , stringify ! ( phase ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < asn_struct_ctx_s > ( ) ) ) . step as * const _ as usize } , 2usize , concat ! ( "Offset of field: " , stringify ! ( asn_struct_ctx_s ) , "::" , stringify ! ( step ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < asn_struct_ctx_s > ( ) ) ) . context as * const _ as usize } , 4usize , concat ! ( "Offset of field: " , stringify ! ( asn_struct_ctx_s ) , "::" , stringify ! ( context ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < asn_struct_ctx_s > ( ) ) ) . ptr as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( asn_struct_ctx_s ) , "::" , stringify ! ( ptr ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < asn_struct_ctx_s > ( ) ) ) . left as * const _ as usize } , 16usize , concat ! ( "Offset of field: " , stringify ! ( asn_struct_ctx_s ) , "::" , stringify ! ( left ) ) ) ; } pub type asn_struct_ctx_t = asn_struct_ctx_s ; extern "C" { pub fn ber_decode ( opt_codec_ctx : * mut asn_codec_ctx_s , type_descriptor : * mut asn_TYPE_descriptor_s , struct_ptr : * mut * mut :: std :: os :: raw :: c_void , buffer : * const :: std :: os :: raw :: c_void , size : usize ) -> asn_dec_rval_t ; } pub type ber_type_decoder_f = :: std :: option :: Option < unsafe extern "C" fn ( opt_codec_ctx : * mut asn_codec_ctx_s , type_descriptor : * mut asn_TYPE_descriptor_s , struct_ptr : * mut * mut :: std :: os :: raw :: c_void , buf_ptr : * const :: std :: os :: raw :: c_void , size : usize , tag_mode : :: std :: os :: raw :: c_int ) -> asn_dec_rval_t > ; extern "C" { 
 /// INTERNALLY USEFUL FUNCTIONS * 
 pub fn ber_check_tags ( opt_codec_ctx : * mut asn_codec_ctx_s , type_descriptor : * mut asn_TYPE_descriptor_s , opt_ctx : * mut asn_struct_ctx_t , ptr : * const :: std :: os :: raw :: c_void , size : usize , tag_mode : :: std :: os :: raw :: c_int , last_tag_form : :: std :: os :: raw :: c_int , last_length : * mut ber_tlv_len_t , opt_tlv_form : * mut :: std :: os :: raw :: c_int ) -> asn_dec_rval_t ; } extern "C" { pub fn der_encode ( type_descriptor : * mut asn_TYPE_descriptor_s , struct_ptr : * mut :: std :: os :: raw :: c_void , consume_bytes_cb : asn_app_consume_bytes_f , app_key : * mut :: std :: os :: raw :: c_void ) -> asn_enc_rval_t ; } extern "C" { pub fn der_encode_to_buffer ( type_descriptor : * mut asn_TYPE_descriptor_s , struct_ptr : * mut :: std :: os :: raw :: c_void , buffer : * mut :: std :: os :: raw :: c_void , buffer_size : usize ) -> asn_enc_rval_t ; } pub type der_type_encoder_f = :: std :: option :: Option < unsafe extern "C" fn ( type_descriptor : * mut asn_TYPE_descriptor_s , struct_ptr : * mut :: std :: os :: raw :: c_void , tag_mode : :: std :: os :: raw :: c_int , tag : ber_tlv_tag_t , consume_bytes_cb : asn_app_consume_bytes_f , app_key : * mut :: std :: os :: raw :: c_void ) -> asn_enc_rval_t > ; extern "C" { 
 /// INTERNALLY USEFUL FUNCTIONS * 
 pub fn der_write_tags ( type_descriptor : * mut asn_TYPE_descriptor_s , struct_length : usize , tag_mode : :: std :: os :: raw :: c_int , last_tag_form : :: std :: os :: raw :: c_int , tag : ber_tlv_tag_t , consume_bytes_cb : asn_app_consume_bytes_f , app_key : * mut :: std :: os :: raw :: c_void ) -> isize ; } extern "C" { pub fn xer_decode ( opt_codec_ctx : * mut asn_codec_ctx_s , type_descriptor : * mut asn_TYPE_descriptor_s , struct_ptr : * mut * mut :: std :: os :: raw :: c_void , buffer : * const :: std :: os :: raw :: c_void , size : usize ) -> asn_dec_rval_t ; } pub type xer_type_decoder_f = :: std :: option :: Option < unsafe extern "C" fn ( opt_codec_ctx : * mut asn_codec_ctx_t , type_descriptor : * mut asn_TYPE_descriptor_s , struct_ptr : * mut * mut :: std :: os :: raw :: c_void , opt_mname : * const :: std :: os :: raw :: c_char , buf_ptr : * const :: std :: os :: raw :: c_void , size : usize ) -> asn_dec_rval_t > ; extern "C" { 
 /// INTERNALLY USEFUL FUNCTIONS * 
 pub fn xer_decode_general ( opt_codec_ctx : * mut asn_codec_ctx_t , ctx : * mut asn_struct_ctx_t , struct_key : * mut :: std :: os :: raw :: c_void , xml_tag : * const :: std :: os :: raw :: c_char , buf_ptr : * const :: std :: os :: raw :: c_void , size : usize , opt_unexpected_tag_decoder : :: std :: option :: Option < unsafe extern "C" fn ( struct_key : * mut :: std :: os :: raw :: c_void , chunk_buf : * const :: std :: os :: raw :: c_void , chunk_size : usize ) -> :: std :: os :: raw :: c_int > , body_receiver : :: std :: option :: Option < unsafe extern "C" fn ( struct_key : * mut :: std :: os :: raw :: c_void , chunk_buf : * const :: std :: os :: raw :: c_void , chunk_size : usize , have_more : :: std :: os :: raw :: c_int ) -> isize > ) -> asn_dec_rval_t ; } pub const pxer_chunk_type_PXER_TAG : pxer_chunk_type = 0 ; pub const pxer_chunk_type_PXER_TEXT : pxer_chunk_type = 1 ; pub const pxer_chunk_type_PXER_COMMENT : pxer_chunk_type = 2 ; pub type pxer_chunk_type = u32 ; pub use self :: pxer_chunk_type as pxer_chunk_type_e ; extern "C" { pub fn xer_next_token ( stateContext : * mut :: std :: os :: raw :: c_int , buffer : * const :: std :: os :: raw :: c_void , size : usize , _ch_type : * mut pxer_chunk_type_e ) -> isize ; } pub const xer_check_tag_XCT_BROKEN : xer_check_tag = 0 ; pub const xer_check_tag_XCT_OPENING : xer_check_tag = 1 ; pub const xer_check_tag_XCT_CLOSING : xer_check_tag = 2 ; pub const xer_check_tag_XCT_BOTH : xer_check_tag = 3 ; pub const xer_check_tag_XCT__UNK__MASK : xer_check_tag = 4 ; pub const xer_check_tag_XCT_UNKNOWN_OP : xer_check_tag = 5 ; pub const xer_check_tag_XCT_UNKNOWN_CL : xer_check_tag = 6 ; pub const xer_check_tag_XCT_UNKNOWN_BO : xer_check_tag = 7 ; pub type xer_check_tag = u32 ; pub use self :: xer_check_tag as xer_check_tag_e ; extern "C" { pub fn xer_check_tag ( buf_ptr : * const :: std :: os :: raw :: c_void , size : :: std :: os :: raw :: c_int , need_tag : * const :: std :: os :: raw :: c_char ) -> xer_check_tag_e ; } extern "C" { pub fn xer_whitespace_span ( chunk_buf : * const :: std :: os :: raw :: c_void , chunk_size : usize ) -> usize ; } extern "C" { pub fn xer_skip_unknown ( tcv : xer_check_tag_e , depth : * mut ber_tlv_len_t ) -> :: std :: os :: raw :: c_int ; } pub const xer_encoder_flags_e_XER_F_BASIC : xer_encoder_flags_e = 1 ; pub const xer_encoder_flags_e_XER_F_CANONICAL : xer_encoder_flags_e = 2 ; pub type xer_encoder_flags_e = u32 ; extern "C" { pub fn xer_encode ( type_descriptor : * mut asn_TYPE_descriptor_s , struct_ptr : * mut :: std :: os :: raw :: c_void , xer_flags : xer_encoder_flags_e , consume_bytes_cb : asn_app_consume_bytes_f , app_key : * mut :: std :: os :: raw :: c_void ) -> asn_enc_rval_t ; } extern "C" { pub fn xer_fprint ( stream : * mut FILE , td : * mut asn_TYPE_descriptor_s , sptr : * mut :: std :: os :: raw :: c_void ) -> :: std :: os :: raw :: c_int ; } pub type xer_type_encoder_f = :: std :: option :: Option < unsafe extern "C" fn ( type_descriptor : * mut asn_TYPE_descriptor_s , struct_ptr : * mut :: std :: os :: raw :: c_void , ilevel : :: std :: os :: raw :: c_int , xer_flags : xer_encoder_flags_e , consume_bytes_cb : asn_app_consume_bytes_f , app_key : * mut :: std :: os :: raw :: c_void ) -> asn_enc_rval_t > ; # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct asn_per_constraint_s { pub flags : asn_per_constraint_s_asn_per_constraint_flags , pub range_bits : :: std :: os :: raw :: c_int , pub effective_bits : :: std :: os :: raw :: c_int , pub lower_bound : :: std :: os :: raw :: c_long , pub upper_bound : :: std :: os :: raw :: c_long , } pub const asn_per_constraint_s_asn_per_constraint_flags_APC_UNCONSTRAINED : asn_per_constraint_s_asn_per_constraint_flags = 0 ; pub const asn_per_constraint_s_asn_per_constraint_flags_APC_SEMI_CONSTRAINED : asn_per_constraint_s_asn_per_constraint_flags = 1 ; pub const asn_per_constraint_s_asn_per_constraint_flags_APC_CONSTRAINED : asn_per_constraint_s_asn_per_constraint_flags = 2 ; pub const asn_per_constraint_s_asn_per_constraint_flags_APC_EXTENSIBLE : asn_per_constraint_s_asn_per_constraint_flags = 4 ; pub type asn_per_constraint_s_asn_per_constraint_flags = u32 ; # [ test ] fn bindgen_test_layout_asn_per_constraint_s ( ) { assert_eq ! ( :: std :: mem :: size_of :: < asn_per_constraint_s > ( ) , 32usize , concat ! ( "Size of: " , stringify ! ( asn_per_constraint_s ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < asn_per_constraint_s > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( asn_per_constraint_s ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < asn_per_constraint_s > ( ) ) ) . flags as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( asn_per_constraint_s ) , "::" , stringify ! ( flags ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < asn_per_constraint_s > ( ) ) ) . range_bits as * const _ as usize } , 4usize , concat ! ( "Offset of field: " , stringify ! ( asn_per_constraint_s ) , "::" , stringify ! ( range_bits ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < asn_per_constraint_s > ( ) ) ) . effective_bits as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( asn_per_constraint_s ) , "::" , stringify ! ( effective_bits ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < asn_per_constraint_s > ( ) ) ) . lower_bound as * const _ as usize } , 16usize , concat ! ( "Offset of field: " , stringify ! ( asn_per_constraint_s ) , "::" , stringify ! ( lower_bound ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < asn_per_constraint_s > ( ) ) ) . upper_bound as * const _ as usize } , 24usize , concat ! ( "Offset of field: " , stringify ! ( asn_per_constraint_s ) , "::" , stringify ! ( upper_bound ) ) ) ; } pub type asn_per_constraint_t = asn_per_constraint_s ; # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct asn_per_constraints_s { pub value : asn_per_constraint_t , pub size : asn_per_constraint_t , pub value2code : :: std :: option :: Option < unsafe extern "C" fn ( value : :: std :: os :: raw :: c_uint ) -> :: std :: os :: raw :: c_int > , pub code2value : :: std :: option :: Option < unsafe extern "C" fn ( code : :: std :: os :: raw :: c_uint ) -> :: std :: os :: raw :: c_int > , } # [ test ] fn bindgen_test_layout_asn_per_constraints_s ( ) { assert_eq ! ( :: std :: mem :: size_of :: < asn_per_constraints_s > ( ) , 80usize , concat ! ( "Size of: " , stringify ! ( asn_per_constraints_s ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < asn_per_constraints_s > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( asn_per_constraints_s ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < asn_per_constraints_s > ( ) ) ) . value as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( asn_per_constraints_s ) , "::" , stringify ! ( value ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < asn_per_constraints_s > ( ) ) ) . size as * const _ as usize } , 32usize , concat ! ( "Offset of field: " , stringify ! ( asn_per_constraints_s ) , "::" , stringify ! ( size ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < asn_per_constraints_s > ( ) ) ) . value2code as * const _ as usize } , 64usize , concat ! ( "Offset of field: " , stringify ! ( asn_per_constraints_s ) , "::" , stringify ! ( value2code ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < asn_per_constraints_s > ( ) ) ) . code2value as * const _ as usize } , 72usize , concat ! ( "Offset of field: " , stringify ! ( asn_per_constraints_s ) , "::" , stringify ! ( code2value ) ) ) ; } pub type asn_per_constraints_t = asn_per_constraints_s ; # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct asn_per_data_s { pub buffer : * const u8 , pub nboff : usize , pub nbits : usize , pub moved : usize , pub refill : :: std :: option :: Option < unsafe extern "C" fn ( arg1 : * mut asn_per_data_s ) -> :: std :: os :: raw :: c_int > , pub refill_key : * mut :: std :: os :: raw :: c_void , } # [ test ] fn bindgen_test_layout_asn_per_data_s ( ) { assert_eq ! ( :: std :: mem :: size_of :: < asn_per_data_s > ( ) , 48usize , concat ! ( "Size of: " , stringify ! ( asn_per_data_s ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < asn_per_data_s > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( asn_per_data_s ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < asn_per_data_s > ( ) ) ) . buffer as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( asn_per_data_s ) , "::" , stringify ! ( buffer ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < asn_per_data_s > ( ) ) ) . nboff as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( asn_per_data_s ) , "::" , stringify ! ( nboff ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < asn_per_data_s > ( ) ) ) . nbits as * const _ as usize } , 16usize , concat ! ( "Offset of field: " , stringify ! ( asn_per_data_s ) , "::" , stringify ! ( nbits ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < asn_per_data_s > ( ) ) ) . moved as * const _ as usize } , 24usize , concat ! ( "Offset of field: " , stringify ! ( asn_per_data_s ) , "::" , stringify ! ( moved ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < asn_per_data_s > ( ) ) ) . refill as * const _ as usize } , 32usize , concat ! ( "Offset of field: " , stringify ! ( asn_per_data_s ) , "::" , stringify ! ( refill ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < asn_per_data_s > ( ) ) ) . refill_key as * const _ as usize } , 40usize , concat ! ( "Offset of field: " , stringify ! ( asn_per_data_s ) , "::" , stringify ! ( refill_key ) ) ) ; } pub type asn_per_data_t = asn_per_data_s ; extern "C" { pub fn per_get_few_bits ( per_data : * mut asn_per_data_t , get_nbits : :: std :: os :: raw :: c_int ) -> i32 ; } extern "C" { pub fn per_get_undo ( per_data : * mut asn_per_data_t , get_nbits : :: std :: os :: raw :: c_int ) ; } extern "C" { pub fn per_get_many_bits ( pd : * mut asn_per_data_t , dst : * mut u8 , right_align : :: std :: os :: raw :: c_int , get_nbits : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn uper_get_length ( pd : * mut asn_per_data_t , effective_bound_bits : :: std :: os :: raw :: c_int , repeat : * mut :: std :: os :: raw :: c_int ) -> isize ; } extern "C" { pub fn uper_get_nslength ( pd : * mut asn_per_data_t ) -> isize ; } extern "C" { pub fn uper_get_nsnnwn ( pd : * mut asn_per_data_t ) -> isize ; } extern "C" { pub fn per_data_string ( pd : * mut asn_per_data_t ) -> * mut :: std :: os :: raw :: c_char ; } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct asn_per_outp_s { pub buffer : * mut u8 , pub nboff : usize , pub nbits : usize , pub tmpspace : [ u8 ; 32usize ] , pub outper : :: std :: option :: Option < unsafe extern "C" fn ( data : * const :: std :: os :: raw :: c_void , size : usize , op_key : * mut :: std :: os :: raw :: c_void ) -> :: std :: os :: raw :: c_int > , pub op_key : * mut :: std :: os :: raw :: c_void , pub flushed_bytes : usize , } # [ test ] fn bindgen_test_layout_asn_per_outp_s ( ) { assert_eq ! ( :: std :: mem :: size_of :: < asn_per_outp_s > ( ) , 80usize , concat ! ( "Size of: " , stringify ! ( asn_per_outp_s ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < asn_per_outp_s > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( asn_per_outp_s ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < asn_per_outp_s > ( ) ) ) . buffer as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( asn_per_outp_s ) , "::" , stringify ! ( buffer ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < asn_per_outp_s > ( ) ) ) . nboff as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( asn_per_outp_s ) , "::" , stringify ! ( nboff ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < asn_per_outp_s > ( ) ) ) . nbits as * const _ as usize } , 16usize , concat ! ( "Offset of field: " , stringify ! ( asn_per_outp_s ) , "::" , stringify ! ( nbits ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < asn_per_outp_s > ( ) ) ) . tmpspace as * const _ as usize } , 24usize , concat ! ( "Offset of field: " , stringify ! ( asn_per_outp_s ) , "::" , stringify ! ( tmpspace ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < asn_per_outp_s > ( ) ) ) . outper as * const _ as usize } , 56usize , concat ! ( "Offset of field: " , stringify ! ( asn_per_outp_s ) , "::" , stringify ! ( outper ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < asn_per_outp_s > ( ) ) ) . op_key as * const _ as usize } , 64usize , concat ! ( "Offset of field: " , stringify ! ( asn_per_outp_s ) , "::" , stringify ! ( op_key ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < asn_per_outp_s > ( ) ) ) . flushed_bytes as * const _ as usize } , 72usize , concat ! ( "Offset of field: " , stringify ! ( asn_per_outp_s ) , "::" , stringify ! ( flushed_bytes ) ) ) ; } pub type asn_per_outp_t = asn_per_outp_s ; extern "C" { pub fn per_put_few_bits ( per_data : * mut asn_per_outp_t , bits : u32 , obits : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn per_put_many_bits ( po : * mut asn_per_outp_t , src : * const u8 , put_nbits : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn uper_put_length ( po : * mut asn_per_outp_t , whole_length : usize ) -> isize ; } extern "C" { pub fn uper_put_nslength ( po : * mut asn_per_outp_t , length : usize ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn uper_put_nsnnwn ( po : * mut asn_per_outp_t , n : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn uper_decode_complete ( opt_codec_ctx : * mut asn_codec_ctx_s , type_descriptor : * mut asn_TYPE_descriptor_s , struct_ptr : * mut * mut :: std :: os :: raw :: c_void , buffer : * const :: std :: os :: raw :: c_void , size : usize ) -> asn_dec_rval_t ; } extern "C" { pub fn uper_decode ( opt_codec_ctx : * mut asn_codec_ctx_s , type_descriptor : * mut asn_TYPE_descriptor_s , struct_ptr : * mut * mut :: std :: os :: raw :: c_void , buffer : * const :: std :: os :: raw :: c_void , size : usize , skip_bits : :: std :: os :: raw :: c_int , unused_bits : :: std :: os :: raw :: c_int ) -> asn_dec_rval_t ; } pub type per_type_decoder_f = :: std :: option :: Option < unsafe extern "C" fn ( opt_codec_ctx : * mut asn_codec_ctx_t , type_descriptor : * mut asn_TYPE_descriptor_s , constraints : * mut asn_per_constraints_t , struct_ptr : * mut * mut :: std :: os :: raw :: c_void , per_data : * mut asn_per_data_t ) -> asn_dec_rval_t > ; extern "C" { pub fn uper_encode ( type_descriptor : * mut asn_TYPE_descriptor_s , struct_ptr : * mut :: std :: os :: raw :: c_void , consume_bytes_cb : asn_app_consume_bytes_f , app_key : * mut :: std :: os :: raw :: c_void ) -> asn_enc_rval_t ; } extern "C" { pub fn uper_encode_to_buffer ( type_descriptor : * mut asn_TYPE_descriptor_s , struct_ptr : * mut :: std :: os :: raw :: c_void , buffer : * mut :: std :: os :: raw :: c_void , buffer_size : usize ) -> asn_enc_rval_t ; } extern "C" { pub fn uper_encode_to_new_buffer ( type_descriptor : * mut asn_TYPE_descriptor_s , constraints : * mut asn_per_constraints_t , struct_ptr : * mut :: std :: os :: raw :: c_void , buffer_r : * mut * mut :: std :: os :: raw :: c_void ) -> isize ; } pub type per_type_encoder_f = :: std :: option :: Option < unsafe extern "C" fn ( type_descriptor : * mut asn_TYPE_descriptor_s , constraints : * mut asn_per_constraints_t , struct_ptr : * mut :: std :: os :: raw :: c_void , per_output : * mut asn_per_outp_t ) -> asn_enc_rval_t > ; extern "C" { pub fn asn_check_constraints ( type_descriptor : * mut asn_TYPE_descriptor_s , struct_ptr : * const :: std :: os :: raw :: c_void , errbuf : * mut :: std :: os :: raw :: c_char , errlen : * mut usize ) -> :: std :: os :: raw :: c_int ; } pub type asn_constr_check_f = :: std :: option :: Option < unsafe extern "C" fn ( type_descriptor : * mut asn_TYPE_descriptor_s , struct_ptr : * const :: std :: os :: raw :: c_void , optional_callback : asn_app_constraint_failed_f , optional_app_key : * mut :: std :: os :: raw :: c_void ) -> :: std :: os :: raw :: c_int > ; extern "C" { 
 /// INTERNALLY USEFUL FUNCTIONS * 
 pub fn asn_generic_no_constraint ( type_descriptor : * mut asn_TYPE_descriptor_s , struct_ptr : * const :: std :: os :: raw :: c_void , optional_callback : asn_app_constraint_failed_f , optional_app_key : * mut :: std :: os :: raw :: c_void ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn asn_generic_unknown_constraint ( type_descriptor : * mut asn_TYPE_descriptor_s , struct_ptr : * const :: std :: os :: raw :: c_void , optional_callback : asn_app_constraint_failed_f , optional_app_key : * mut :: std :: os :: raw :: c_void ) -> :: std :: os :: raw :: c_int ; } pub type asn_struct_free_f = :: std :: option :: Option < unsafe extern "C" fn ( type_descriptor : * mut asn_TYPE_descriptor_s , struct_ptr : * mut :: std :: os :: raw :: c_void , free_contents_only : :: std :: os :: raw :: c_int ) > ; pub type asn_struct_print_f = :: std :: option :: Option < unsafe extern "C" fn ( type_descriptor : * mut asn_TYPE_descriptor_s , struct_ptr : * const :: std :: os :: raw :: c_void , level : :: std :: os :: raw :: c_int , callback : asn_app_consume_bytes_f , app_key : * mut :: std :: os :: raw :: c_void ) -> :: std :: os :: raw :: c_int > ; pub type asn_outmost_tag_f = :: std :: option :: Option < unsafe extern "C" fn ( type_descriptor : * mut asn_TYPE_descriptor_s , struct_ptr : * const :: std :: os :: raw :: c_void , tag_mode : :: std :: os :: raw :: c_int , tag : ber_tlv_tag_t ) -> ber_tlv_tag_t > ; extern "C" { pub fn asn_TYPE_outmost_tag ( type_descriptor : * mut asn_TYPE_descriptor_s , struct_ptr : * const :: std :: os :: raw :: c_void , tag_mode : :: std :: os :: raw :: c_int , tag : ber_tlv_tag_t ) -> ber_tlv_tag_t ; } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct asn_TYPE_descriptor_s { pub name : * mut :: std :: os :: raw :: c_char , pub xml_tag : * mut :: std :: os :: raw :: c_char , pub free_struct : asn_struct_free_f , pub print_struct : asn_struct_print_f , pub check_constraints : asn_constr_check_f , pub ber_decoder : ber_type_decoder_f , pub der_encoder : der_type_encoder_f , pub xer_decoder : xer_type_decoder_f , pub xer_encoder : xer_type_encoder_f , pub uper_decoder : per_type_decoder_f , pub uper_encoder : per_type_encoder_f , 
 /// Internally useful members. Not to be used by applications directly. * 
 pub outmost_tag : asn_outmost_tag_f , pub tags : * mut ber_tlv_tag_t , pub tags_count : :: std :: os :: raw :: c_int , pub all_tags : * mut ber_tlv_tag_t , pub all_tags_count : :: std :: os :: raw :: c_int , pub per_constraints : * mut asn_per_constraints_t , pub elements : * mut asn_TYPE_member_s , pub elements_count : :: std :: os :: raw :: c_int , pub specifics : * mut :: std :: os :: raw :: c_void , } # [ test ] fn bindgen_test_layout_asn_TYPE_descriptor_s ( ) { assert_eq ! ( :: std :: mem :: size_of :: < asn_TYPE_descriptor_s > ( ) , 160usize , concat ! ( "Size of: " , stringify ! ( asn_TYPE_descriptor_s ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < asn_TYPE_descriptor_s > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( asn_TYPE_descriptor_s ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < asn_TYPE_descriptor_s > ( ) ) ) . name as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( asn_TYPE_descriptor_s ) , "::" , stringify ! ( name ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < asn_TYPE_descriptor_s > ( ) ) ) . xml_tag as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( asn_TYPE_descriptor_s ) , "::" , stringify ! ( xml_tag ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < asn_TYPE_descriptor_s > ( ) ) ) . free_struct as * const _ as usize } , 16usize , concat ! ( "Offset of field: " , stringify ! ( asn_TYPE_descriptor_s ) , "::" , stringify ! ( free_struct ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < asn_TYPE_descriptor_s > ( ) ) ) . print_struct as * const _ as usize } , 24usize , concat ! ( "Offset of field: " , stringify ! ( asn_TYPE_descriptor_s ) , "::" , stringify ! ( print_struct ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < asn_TYPE_descriptor_s > ( ) ) ) . check_constraints as * const _ as usize } , 32usize , concat ! ( "Offset of field: " , stringify ! ( asn_TYPE_descriptor_s ) , "::" , stringify ! ( check_constraints ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < asn_TYPE_descriptor_s > ( ) ) ) . ber_decoder as * const _ as usize } , 40usize , concat ! ( "Offset of field: " , stringify ! ( asn_TYPE_descriptor_s ) , "::" , stringify ! ( ber_decoder ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < asn_TYPE_descriptor_s > ( ) ) ) . der_encoder as * const _ as usize } , 48usize , concat ! ( "Offset of field: " , stringify ! ( asn_TYPE_descriptor_s ) , "::" , stringify ! ( der_encoder ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < asn_TYPE_descriptor_s > ( ) ) ) . xer_decoder as * const _ as usize } , 56usize , concat ! ( "Offset of field: " , stringify ! ( asn_TYPE_descriptor_s ) , "::" , stringify ! ( xer_decoder ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < asn_TYPE_descriptor_s > ( ) ) ) . xer_encoder as * const _ as usize } , 64usize , concat ! ( "Offset of field: " , stringify ! ( asn_TYPE_descriptor_s ) , "::" , stringify ! ( xer_encoder ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < asn_TYPE_descriptor_s > ( ) ) ) . uper_decoder as * const _ as usize } , 72usize , concat ! ( "Offset of field: " , stringify ! ( asn_TYPE_descriptor_s ) , "::" , stringify ! ( uper_decoder ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < asn_TYPE_descriptor_s > ( ) ) ) . uper_encoder as * const _ as usize } , 80usize , concat ! ( "Offset of field: " , stringify ! ( asn_TYPE_descriptor_s ) , "::" , stringify ! ( uper_encoder ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < asn_TYPE_descriptor_s > ( ) ) ) . outmost_tag as * const _ as usize } , 88usize , concat ! ( "Offset of field: " , stringify ! ( asn_TYPE_descriptor_s ) , "::" , stringify ! ( outmost_tag ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < asn_TYPE_descriptor_s > ( ) ) ) . tags as * const _ as usize } , 96usize , concat ! ( "Offset of field: " , stringify ! ( asn_TYPE_descriptor_s ) , "::" , stringify ! ( tags ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < asn_TYPE_descriptor_s > ( ) ) ) . tags_count as * const _ as usize } , 104usize , concat ! ( "Offset of field: " , stringify ! ( asn_TYPE_descriptor_s ) , "::" , stringify ! ( tags_count ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < asn_TYPE_descriptor_s > ( ) ) ) . all_tags as * const _ as usize } , 112usize , concat ! ( "Offset of field: " , stringify ! ( asn_TYPE_descriptor_s ) , "::" , stringify ! ( all_tags ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < asn_TYPE_descriptor_s > ( ) ) ) . all_tags_count as * const _ as usize } , 120usize , concat ! ( "Offset of field: " , stringify ! ( asn_TYPE_descriptor_s ) , "::" , stringify ! ( all_tags_count ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < asn_TYPE_descriptor_s > ( ) ) ) . per_constraints as * const _ as usize } , 128usize , concat ! ( "Offset of field: " , stringify ! ( asn_TYPE_descriptor_s ) , "::" , stringify ! ( per_constraints ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < asn_TYPE_descriptor_s > ( ) ) ) . elements as * const _ as usize } , 136usize , concat ! ( "Offset of field: " , stringify ! ( asn_TYPE_descriptor_s ) , "::" , stringify ! ( elements ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < asn_TYPE_descriptor_s > ( ) ) ) . elements_count as * const _ as usize } , 144usize , concat ! ( "Offset of field: " , stringify ! ( asn_TYPE_descriptor_s ) , "::" , stringify ! ( elements_count ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < asn_TYPE_descriptor_s > ( ) ) ) . specifics as * const _ as usize } , 152usize , concat ! ( "Offset of field: " , stringify ! ( asn_TYPE_descriptor_s ) , "::" , stringify ! ( specifics ) ) ) ; } pub type asn_TYPE_descriptor_t = asn_TYPE_descriptor_s ; pub const asn_TYPE_flags_e_ATF_NOFLAGS : asn_TYPE_flags_e = 0 ; pub const asn_TYPE_flags_e_ATF_POINTER : asn_TYPE_flags_e = 1 ; pub const asn_TYPE_flags_e_ATF_OPEN_TYPE : asn_TYPE_flags_e = 2 ; pub type asn_TYPE_flags_e = u32 ; # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct asn_TYPE_member_s { pub flags : asn_TYPE_flags_e , pub optional : :: std :: os :: raw :: c_int , pub memb_offset : :: std :: os :: raw :: c_int , pub tag : ber_tlv_tag_t , pub tag_mode : :: std :: os :: raw :: c_int , pub type_ : * mut asn_TYPE_descriptor_t , pub memb_constraints : asn_constr_check_f , pub per_constraints : * mut asn_per_constraints_t , pub default_value : :: std :: option :: Option < unsafe extern "C" fn ( setval : :: std :: os :: raw :: c_int , sptr : * mut * mut :: std :: os :: raw :: c_void ) -> :: std :: os :: raw :: c_int > , pub name : * mut :: std :: os :: raw :: c_char , } # [ test ] fn bindgen_test_layout_asn_TYPE_member_s ( ) { assert_eq ! ( :: std :: mem :: size_of :: < asn_TYPE_member_s > ( ) , 64usize , concat ! ( "Size of: " , stringify ! ( asn_TYPE_member_s ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < asn_TYPE_member_s > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( asn_TYPE_member_s ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < asn_TYPE_member_s > ( ) ) ) . flags as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( asn_TYPE_member_s ) , "::" , stringify ! ( flags ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < asn_TYPE_member_s > ( ) ) ) . optional as * const _ as usize } , 4usize , concat ! ( "Offset of field: " , stringify ! ( asn_TYPE_member_s ) , "::" , stringify ! ( optional ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < asn_TYPE_member_s > ( ) ) ) . memb_offset as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( asn_TYPE_member_s ) , "::" , stringify ! ( memb_offset ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < asn_TYPE_member_s > ( ) ) ) . tag as * const _ as usize } , 12usize , concat ! ( "Offset of field: " , stringify ! ( asn_TYPE_member_s ) , "::" , stringify ! ( tag ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < asn_TYPE_member_s > ( ) ) ) . tag_mode as * const _ as usize } , 16usize , concat ! ( "Offset of field: " , stringify ! ( asn_TYPE_member_s ) , "::" , stringify ! ( tag_mode ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < asn_TYPE_member_s > ( ) ) ) . type_ as * const _ as usize } , 24usize , concat ! ( "Offset of field: " , stringify ! ( asn_TYPE_member_s ) , "::" , stringify ! ( type_ ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < asn_TYPE_member_s > ( ) ) ) . memb_constraints as * const _ as usize } , 32usize , concat ! ( "Offset of field: " , stringify ! ( asn_TYPE_member_s ) , "::" , stringify ! ( memb_constraints ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < asn_TYPE_member_s > ( ) ) ) . per_constraints as * const _ as usize } , 40usize , concat ! ( "Offset of field: " , stringify ! ( asn_TYPE_member_s ) , "::" , stringify ! ( per_constraints ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < asn_TYPE_member_s > ( ) ) ) . default_value as * const _ as usize } , 48usize , concat ! ( "Offset of field: " , stringify ! ( asn_TYPE_member_s ) , "::" , stringify ! ( default_value ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < asn_TYPE_member_s > ( ) ) ) . name as * const _ as usize } , 56usize , concat ! ( "Offset of field: " , stringify ! ( asn_TYPE_member_s ) , "::" , stringify ! ( name ) ) ) ; } pub type asn_TYPE_member_t = asn_TYPE_member_s ; # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct asn_TYPE_tag2member_s { pub el_tag : ber_tlv_tag_t , pub el_no : :: std :: os :: raw :: c_int , pub toff_first : :: std :: os :: raw :: c_int , pub toff_last : :: std :: os :: raw :: c_int , } # [ test ] fn bindgen_test_layout_asn_TYPE_tag2member_s ( ) { assert_eq ! ( :: std :: mem :: size_of :: < asn_TYPE_tag2member_s > ( ) , 16usize , concat ! ( "Size of: " , stringify ! ( asn_TYPE_tag2member_s ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < asn_TYPE_tag2member_s > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( asn_TYPE_tag2member_s ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < asn_TYPE_tag2member_s > ( ) ) ) . el_tag as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( asn_TYPE_tag2member_s ) , "::" , stringify ! ( el_tag ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < asn_TYPE_tag2member_s > ( ) ) ) . el_no as * const _ as usize } , 4usize , concat ! ( "Offset of field: " , stringify ! ( asn_TYPE_tag2member_s ) , "::" , stringify ! ( el_no ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < asn_TYPE_tag2member_s > ( ) ) ) . toff_first as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( asn_TYPE_tag2member_s ) , "::" , stringify ! ( toff_first ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < asn_TYPE_tag2member_s > ( ) ) ) . toff_last as * const _ as usize } , 12usize , concat ! ( "Offset of field: " , stringify ! ( asn_TYPE_tag2member_s ) , "::" , stringify ! ( toff_last ) ) ) ; } pub type asn_TYPE_tag2member_t = asn_TYPE_tag2member_s ; extern "C" { pub fn asn_fprint ( stream : * mut FILE , td : * mut asn_TYPE_descriptor_t , struct_ptr : * const :: std :: os :: raw :: c_void ) -> :: std :: os :: raw :: c_int ; } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct ASN__PRIMITIVE_TYPE_s { pub buf : * mut u8 , pub size : :: std :: os :: raw :: c_int , } # [ test ] fn bindgen_test_layout_ASN__PRIMITIVE_TYPE_s ( ) { assert_eq ! ( :: std :: mem :: size_of :: < ASN__PRIMITIVE_TYPE_s > ( ) , 16usize , concat ! ( "Size of: " , stringify ! ( ASN__PRIMITIVE_TYPE_s ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < ASN__PRIMITIVE_TYPE_s > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( ASN__PRIMITIVE_TYPE_s ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < ASN__PRIMITIVE_TYPE_s > ( ) ) ) . buf as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( ASN__PRIMITIVE_TYPE_s ) , "::" , stringify ! ( buf ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < ASN__PRIMITIVE_TYPE_s > ( ) ) ) . size as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( ASN__PRIMITIVE_TYPE_s ) , "::" , stringify ! ( size ) ) ) ; } pub type ASN__PRIMITIVE_TYPE_t = ASN__PRIMITIVE_TYPE_s ; extern "C" { pub fn ASN__PRIMITIVE_TYPE_free ( type_descriptor : * mut asn_TYPE_descriptor_s , struct_ptr : * mut :: std :: os :: raw :: c_void , free_contents_only : :: std :: os :: raw :: c_int ) ; } extern "C" { pub fn ber_decode_primitive ( opt_codec_ctx : * mut asn_codec_ctx_s , type_descriptor : * mut asn_TYPE_descriptor_s , struct_ptr : * mut * mut :: std :: os :: raw :: c_void , buf_ptr : * const :: std :: os :: raw :: c_void , size : usize , tag_mode : :: std :: os :: raw :: c_int ) -> asn_dec_rval_t ; } extern "C" { pub fn der_encode_primitive ( type_descriptor : * mut asn_TYPE_descriptor_s , struct_ptr : * mut :: std :: os :: raw :: c_void , tag_mode : :: std :: os :: raw :: c_int , tag : ber_tlv_tag_t , consume_bytes_cb : asn_app_consume_bytes_f , app_key : * mut :: std :: os :: raw :: c_void ) -> asn_enc_rval_t ; } pub const xer_pbd_rval_XPBD_SYSTEM_FAILURE : xer_pbd_rval = 0 ; pub const xer_pbd_rval_XPBD_DECODER_LIMIT : xer_pbd_rval = 1 ; pub const xer_pbd_rval_XPBD_BROKEN_ENCODING : xer_pbd_rval = 2 ; pub const xer_pbd_rval_XPBD_NOT_BODY_IGNORE : xer_pbd_rval = 3 ; pub const xer_pbd_rval_XPBD_BODY_CONSUMED : xer_pbd_rval = 4 ; pub type xer_pbd_rval = u32 ; pub type xer_primitive_body_decoder_f = :: std :: option :: Option < unsafe extern "C" fn ( td : * mut asn_TYPE_descriptor_t , struct_ptr : * mut :: std :: os :: raw :: c_void , chunk_buf : * const :: std :: os :: raw :: c_void , chunk_size : usize ) -> xer_pbd_rval > ; extern "C" { pub fn xer_decode_primitive ( opt_codec_ctx : * mut asn_codec_ctx_t , type_descriptor : * mut asn_TYPE_descriptor_t , struct_ptr : * mut * mut :: std :: os :: raw :: c_void , struct_size : usize , opt_mname : * const :: std :: os :: raw :: c_char , buf_ptr : * const :: std :: os :: raw :: c_void , size : usize , prim_body_decoder : xer_primitive_body_decoder_f ) -> asn_dec_rval_t ; } pub type INTEGER_t = ASN__PRIMITIVE_TYPE_t ; extern "C" { # [ link_name = "\u{1}asn_DEF_INTEGER" ] pub static mut asn_DEF_INTEGER : asn_TYPE_descriptor_t ; } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct asn_INTEGER_enum_map_s { pub nat_value : :: std :: os :: raw :: c_long , pub enum_len : usize , pub enum_name : * const :: std :: os :: raw :: c_char , } # [ test ] fn bindgen_test_layout_asn_INTEGER_enum_map_s ( ) { assert_eq ! ( :: std :: mem :: size_of :: < asn_INTEGER_enum_map_s > ( ) , 24usize , concat ! ( "Size of: " , stringify ! ( asn_INTEGER_enum_map_s ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < asn_INTEGER_enum_map_s > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( asn_INTEGER_enum_map_s ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < asn_INTEGER_enum_map_s > ( ) ) ) . nat_value as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( asn_INTEGER_enum_map_s ) , "::" , stringify ! ( nat_value ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < asn_INTEGER_enum_map_s > ( ) ) ) . enum_len as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( asn_INTEGER_enum_map_s ) , "::" , stringify ! ( enum_len ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < asn_INTEGER_enum_map_s > ( ) ) ) . enum_name as * const _ as usize } , 16usize , concat ! ( "Offset of field: " , stringify ! ( asn_INTEGER_enum_map_s ) , "::" , stringify ! ( enum_name ) ) ) ; } pub type asn_INTEGER_enum_map_t = asn_INTEGER_enum_map_s ; # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct asn_INTEGER_specifics_s { pub value2enum : * mut asn_INTEGER_enum_map_t , pub enum2value : * mut :: std :: os :: raw :: c_uint , pub map_count : :: std :: os :: raw :: c_int , pub extension : :: std :: os :: raw :: c_int , pub strict_enumeration : :: std :: os :: raw :: c_int , pub field_width : :: std :: os :: raw :: c_int , pub field_unsigned : :: std :: os :: raw :: c_int , } # [ test ] fn bindgen_test_layout_asn_INTEGER_specifics_s ( ) { assert_eq ! ( :: std :: mem :: size_of :: < asn_INTEGER_specifics_s > ( ) , 40usize , concat ! ( "Size of: " , stringify ! ( asn_INTEGER_specifics_s ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < asn_INTEGER_specifics_s > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( asn_INTEGER_specifics_s ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < asn_INTEGER_specifics_s > ( ) ) ) . value2enum as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( asn_INTEGER_specifics_s ) , "::" , stringify ! ( value2enum ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < asn_INTEGER_specifics_s > ( ) ) ) . enum2value as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( asn_INTEGER_specifics_s ) , "::" , stringify ! ( enum2value ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < asn_INTEGER_specifics_s > ( ) ) ) . map_count as * const _ as usize } , 16usize , concat ! ( "Offset of field: " , stringify ! ( asn_INTEGER_specifics_s ) , "::" , stringify ! ( map_count ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < asn_INTEGER_specifics_s > ( ) ) ) . extension as * const _ as usize } , 20usize , concat ! ( "Offset of field: " , stringify ! ( asn_INTEGER_specifics_s ) , "::" , stringify ! ( extension ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < asn_INTEGER_specifics_s > ( ) ) ) . strict_enumeration as * const _ as usize } , 24usize , concat ! ( "Offset of field: " , stringify ! ( asn_INTEGER_specifics_s ) , "::" , stringify ! ( strict_enumeration ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < asn_INTEGER_specifics_s > ( ) ) ) . field_width as * const _ as usize } , 28usize , concat ! ( "Offset of field: " , stringify ! ( asn_INTEGER_specifics_s ) , "::" , stringify ! ( field_width ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < asn_INTEGER_specifics_s > ( ) ) ) . field_unsigned as * const _ as usize } , 32usize , concat ! ( "Offset of field: " , stringify ! ( asn_INTEGER_specifics_s ) , "::" , stringify ! ( field_unsigned ) ) ) ; } pub type asn_INTEGER_specifics_t = asn_INTEGER_specifics_s ; extern "C" { pub fn INTEGER_print ( type_descriptor : * mut asn_TYPE_descriptor_s , struct_ptr : * const :: std :: os :: raw :: c_void , level : :: std :: os :: raw :: c_int , callback : asn_app_consume_bytes_f , app_key : * mut :: std :: os :: raw :: c_void ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn INTEGER_decode_ber ( opt_codec_ctx : * mut asn_codec_ctx_s , type_descriptor : * mut asn_TYPE_descriptor_s , struct_ptr : * mut * mut :: std :: os :: raw :: c_void , buf_ptr : * const :: std :: os :: raw :: c_void , size : usize , tag_mode : :: std :: os :: raw :: c_int ) -> asn_dec_rval_t ; } extern "C" { pub fn INTEGER_encode_der ( type_descriptor : * mut asn_TYPE_descriptor_s , struct_ptr : * mut :: std :: os :: raw :: c_void , tag_mode : :: std :: os :: raw :: c_int , tag : ber_tlv_tag_t , consume_bytes_cb : asn_app_consume_bytes_f , app_key : * mut :: std :: os :: raw :: c_void ) -> asn_enc_rval_t ; } extern "C" { pub fn INTEGER_decode_xer ( opt_codec_ctx : * mut asn_codec_ctx_t , type_descriptor : * mut asn_TYPE_descriptor_s , struct_ptr : * mut * mut :: std :: os :: raw :: c_void , opt_mname : * const :: std :: os :: raw :: c_char , buf_ptr : * const :: std :: os :: raw :: c_void , size : usize ) -> asn_dec_rval_t ; } extern "C" { pub fn INTEGER_encode_xer ( type_descriptor : * mut asn_TYPE_descriptor_s , struct_ptr : * mut :: std :: os :: raw :: c_void , ilevel : :: std :: os :: raw :: c_int , xer_flags : xer_encoder_flags_e , consume_bytes_cb : asn_app_consume_bytes_f , app_key : * mut :: std :: os :: raw :: c_void ) -> asn_enc_rval_t ; } extern "C" { pub fn INTEGER_decode_uper ( opt_codec_ctx : * mut asn_codec_ctx_t , type_descriptor : * mut asn_TYPE_descriptor_s , constraints : * mut asn_per_constraints_t , struct_ptr : * mut * mut :: std :: os :: raw :: c_void , per_data : * mut asn_per_data_t ) -> asn_dec_rval_t ; } extern "C" { pub fn INTEGER_encode_uper ( type_descriptor : * mut asn_TYPE_descriptor_s , constraints : * mut asn_per_constraints_t , struct_ptr : * mut :: std :: os :: raw :: c_void , per_output : * mut asn_per_outp_t ) -> asn_enc_rval_t ; } extern "C" { 
 /// Some handy conversion routines. * 
 pub fn asn_INTEGER2long ( i : * const INTEGER_t , l : * mut :: std :: os :: raw :: c_long ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn asn_INTEGER2ulong ( i : * const INTEGER_t , l : * mut :: std :: os :: raw :: c_ulong ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn asn_long2INTEGER ( i : * mut INTEGER_t , l : :: std :: os :: raw :: c_long ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn asn_ulong2INTEGER ( i : * mut INTEGER_t , l : :: std :: os :: raw :: c_ulong ) -> :: std :: os :: raw :: c_int ; } pub const asn_strtol_result_e_ASN_STRTOL_ERROR_RANGE : asn_strtol_result_e = -3 ; pub const asn_strtol_result_e_ASN_STRTOL_ERROR_INVAL : asn_strtol_result_e = -2 ; pub const asn_strtol_result_e_ASN_STRTOL_EXPECT_MORE : asn_strtol_result_e = -1 ; pub const asn_strtol_result_e_ASN_STRTOL_OK : asn_strtol_result_e = 0 ; pub const asn_strtol_result_e_ASN_STRTOL_EXTRA_DATA : asn_strtol_result_e = 1 ; pub type asn_strtol_result_e = i32 ; extern "C" { pub fn asn_strtol_lim ( str : * const :: std :: os :: raw :: c_char , end : * mut * const :: std :: os :: raw :: c_char , l : * mut :: std :: os :: raw :: c_long ) -> asn_strtol_result_e ; } extern "C" { pub fn asn_strtol ( str : * const :: std :: os :: raw :: c_char , end : * const :: std :: os :: raw :: c_char , l : * mut :: std :: os :: raw :: c_long ) -> asn_strtol_result_e ; } extern "C" { pub fn INTEGER_map_value2enum ( specs : * mut asn_INTEGER_specifics_t , value : :: std :: os :: raw :: c_long ) -> * const asn_INTEGER_enum_map_t ; } extern "C" { # [ link_name = "\u{1}asn_DEF_NativeInteger" ] pub static mut asn_DEF_NativeInteger : asn_TYPE_descriptor_t ; } extern "C" { pub fn NativeInteger_free ( type_descriptor : * mut asn_TYPE_descriptor_s , struct_ptr : * mut :: std :: os :: raw :: c_void , free_contents_only : :: std :: os :: raw :: c_int ) ; } extern "C" { pub fn NativeInteger_print ( type_descriptor : * mut asn_TYPE_descriptor_s , struct_ptr : * const :: std :: os :: raw :: c_void , level : :: std :: os :: raw :: c_int , callback : asn_app_consume_bytes_f , app_key : * mut :: std :: os :: raw :: c_void ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn NativeInteger_decode_ber ( opt_codec_ctx : * mut asn_codec_ctx_s , type_descriptor : * mut asn_TYPE_descriptor_s , struct_ptr : * mut * mut :: std :: os :: raw :: c_void , buf_ptr : * const :: std :: os :: raw :: c_void , size : usize , tag_mode : :: std :: os :: raw :: c_int ) -> asn_dec_rval_t ; } extern "C" { pub fn NativeInteger_encode_der ( type_descriptor : * mut asn_TYPE_descriptor_s , struct_ptr : * mut :: std :: os :: raw :: c_void , tag_mode : :: std :: os :: raw :: c_int , tag : ber_tlv_tag_t , consume_bytes_cb : asn_app_consume_bytes_f , app_key : * mut :: std :: os :: raw :: c_void ) -> asn_enc_rval_t ; } extern "C" { pub fn NativeInteger_decode_xer ( opt_codec_ctx : * mut asn_codec_ctx_t , type_descriptor : * mut asn_TYPE_descriptor_s , struct_ptr : * mut * mut :: std :: os :: raw :: c_void , opt_mname : * const :: std :: os :: raw :: c_char , buf_ptr : * const :: std :: os :: raw :: c_void , size : usize ) -> asn_dec_rval_t ; } extern "C" { pub fn NativeInteger_encode_xer ( type_descriptor : * mut asn_TYPE_descriptor_s , struct_ptr : * mut :: std :: os :: raw :: c_void , ilevel : :: std :: os :: raw :: c_int , xer_flags : xer_encoder_flags_e , consume_bytes_cb : asn_app_consume_bytes_f , app_key : * mut :: std :: os :: raw :: c_void ) -> asn_enc_rval_t ; } extern "C" { pub fn NativeInteger_decode_uper ( opt_codec_ctx : * mut asn_codec_ctx_t , type_descriptor : * mut asn_TYPE_descriptor_s , constraints : * mut asn_per_constraints_t , struct_ptr : * mut * mut :: std :: os :: raw :: c_void , per_data : * mut asn_per_data_t ) -> asn_dec_rval_t ; } extern "C" { pub fn NativeInteger_encode_uper ( type_descriptor : * mut asn_TYPE_descriptor_s , constraints : * mut asn_per_constraints_t , struct_ptr : * mut :: std :: os :: raw :: c_void , per_output : * mut asn_per_outp_t ) -> asn_enc_rval_t ; } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct asn_SEQUENCE_specifics_s { pub struct_size : :: std :: os :: raw :: c_int , pub ctx_offset : :: std :: os :: raw :: c_int , pub tag2el : * mut asn_TYPE_tag2member_t , pub tag2el_count : :: std :: os :: raw :: c_int , pub oms : * mut :: std :: os :: raw :: c_int , pub roms_count : :: std :: os :: raw :: c_int , pub aoms_count : :: std :: os :: raw :: c_int , pub ext_after : :: std :: os :: raw :: c_int , pub ext_before : :: std :: os :: raw :: c_int , } # [ test ] fn bindgen_test_layout_asn_SEQUENCE_specifics_s ( ) { assert_eq ! ( :: std :: mem :: size_of :: < asn_SEQUENCE_specifics_s > ( ) , 48usize , concat ! ( "Size of: " , stringify ! ( asn_SEQUENCE_specifics_s ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < asn_SEQUENCE_specifics_s > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( asn_SEQUENCE_specifics_s ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < asn_SEQUENCE_specifics_s > ( ) ) ) . struct_size as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( asn_SEQUENCE_specifics_s ) , "::" , stringify ! ( struct_size ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < asn_SEQUENCE_specifics_s > ( ) ) ) . ctx_offset as * const _ as usize } , 4usize , concat ! ( "Offset of field: " , stringify ! ( asn_SEQUENCE_specifics_s ) , "::" , stringify ! ( ctx_offset ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < asn_SEQUENCE_specifics_s > ( ) ) ) . tag2el as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( asn_SEQUENCE_specifics_s ) , "::" , stringify ! ( tag2el ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < asn_SEQUENCE_specifics_s > ( ) ) ) . tag2el_count as * const _ as usize } , 16usize , concat ! ( "Offset of field: " , stringify ! ( asn_SEQUENCE_specifics_s ) , "::" , stringify ! ( tag2el_count ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < asn_SEQUENCE_specifics_s > ( ) ) ) . oms as * const _ as usize } , 24usize , concat ! ( "Offset of field: " , stringify ! ( asn_SEQUENCE_specifics_s ) , "::" , stringify ! ( oms ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < asn_SEQUENCE_specifics_s > ( ) ) ) . roms_count as * const _ as usize } , 32usize , concat ! ( "Offset of field: " , stringify ! ( asn_SEQUENCE_specifics_s ) , "::" , stringify ! ( roms_count ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < asn_SEQUENCE_specifics_s > ( ) ) ) . aoms_count as * const _ as usize } , 36usize , concat ! ( "Offset of field: " , stringify ! ( asn_SEQUENCE_specifics_s ) , "::" , stringify ! ( aoms_count ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < asn_SEQUENCE_specifics_s > ( ) ) ) . ext_after as * const _ as usize } , 40usize , concat ! ( "Offset of field: " , stringify ! ( asn_SEQUENCE_specifics_s ) , "::" , stringify ! ( ext_after ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < asn_SEQUENCE_specifics_s > ( ) ) ) . ext_before as * const _ as usize } , 44usize , concat ! ( "Offset of field: " , stringify ! ( asn_SEQUENCE_specifics_s ) , "::" , stringify ! ( ext_before ) ) ) ; } pub type asn_SEQUENCE_specifics_t = asn_SEQUENCE_specifics_s ; extern "C" { pub fn SEQUENCE_free ( type_descriptor : * mut asn_TYPE_descriptor_s , struct_ptr : * mut :: std :: os :: raw :: c_void , free_contents_only : :: std :: os :: raw :: c_int ) ; } extern "C" { pub fn SEQUENCE_print ( type_descriptor : * mut asn_TYPE_descriptor_s , struct_ptr : * const :: std :: os :: raw :: c_void , level : :: std :: os :: raw :: c_int , callback : asn_app_consume_bytes_f , app_key : * mut :: std :: os :: raw :: c_void ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn SEQUENCE_constraint ( type_descriptor : * mut asn_TYPE_descriptor_s , struct_ptr : * const :: std :: os :: raw :: c_void , optional_callback : asn_app_constraint_failed_f , optional_app_key : * mut :: std :: os :: raw :: c_void ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn SEQUENCE_decode_ber ( opt_codec_ctx : * mut asn_codec_ctx_s , type_descriptor : * mut asn_TYPE_descriptor_s , struct_ptr : * mut * mut :: std :: os :: raw :: c_void , buf_ptr : * const :: std :: os :: raw :: c_void , size : usize , tag_mode : :: std :: os :: raw :: c_int ) -> asn_dec_rval_t ; } extern "C" { pub fn SEQUENCE_encode_der ( type_descriptor : * mut asn_TYPE_descriptor_s , struct_ptr : * mut :: std :: os :: raw :: c_void , tag_mode : :: std :: os :: raw :: c_int , tag : ber_tlv_tag_t , consume_bytes_cb : asn_app_consume_bytes_f , app_key : * mut :: std :: os :: raw :: c_void ) -> asn_enc_rval_t ; } extern "C" { pub fn SEQUENCE_decode_xer ( opt_codec_ctx : * mut asn_codec_ctx_t , type_descriptor : * mut asn_TYPE_descriptor_s , struct_ptr : * mut * mut :: std :: os :: raw :: c_void , opt_mname : * const :: std :: os :: raw :: c_char , buf_ptr : * const :: std :: os :: raw :: c_void , size : usize ) -> asn_dec_rval_t ; } extern "C" { pub fn SEQUENCE_encode_xer ( type_descriptor : * mut asn_TYPE_descriptor_s , struct_ptr : * mut :: std :: os :: raw :: c_void , ilevel : :: std :: os :: raw :: c_int , xer_flags : xer_encoder_flags_e , consume_bytes_cb : asn_app_consume_bytes_f , app_key : * mut :: std :: os :: raw :: c_void ) -> asn_enc_rval_t ; } extern "C" { pub fn SEQUENCE_decode_uper ( opt_codec_ctx : * mut asn_codec_ctx_t , type_descriptor : * mut asn_TYPE_descriptor_s , constraints : * mut asn_per_constraints_t , struct_ptr : * mut * mut :: std :: os :: raw :: c_void , per_data : * mut asn_per_data_t ) -> asn_dec_rval_t ; } extern "C" { pub fn SEQUENCE_encode_uper ( type_descriptor : * mut asn_TYPE_descriptor_s , constraints : * mut asn_per_constraints_t , struct_ptr : * mut :: std :: os :: raw :: c_void , per_output : * mut asn_per_outp_t ) -> asn_enc_rval_t ; } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct Header { pub timestamp : :: std :: os :: raw :: c_long , pub _asn_ctx : asn_struct_ctx_t , } # [ test ] fn bindgen_test_layout_Header ( ) { assert_eq ! ( :: std :: mem :: size_of :: < Header > ( ) , 32usize , concat ! ( "Size of: " , stringify ! ( Header ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < Header > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( Header ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < Header > ( ) ) ) . timestamp as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( Header ) , "::" , stringify ! ( timestamp ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < Header > ( ) ) ) . _asn_ctx as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( Header ) , "::" , stringify ! ( _asn_ctx ) ) ) ; } pub type Header_t = Header ; extern "C" { # [ link_name = "\u{1}asn_DEF_Header" ] pub static mut asn_DEF_Header : asn_TYPE_descriptor_t ; } extern "C" { pub fn __assert_fail ( __assertion : * const :: std :: os :: raw :: c_char , __file : * const :: std :: os :: raw :: c_char , __line : :: std :: os :: raw :: c_uint , __function : * const :: std :: os :: raw :: c_char ) ; } extern "C" { pub fn __assert_perror_fail ( __errnum : :: std :: os :: raw :: c_int , __file : * const :: std :: os :: raw :: c_char , __line : :: std :: os :: raw :: c_uint , __function : * const :: std :: os :: raw :: c_char ) ; } extern "C" { pub fn __assert ( __assertion : * const :: std :: os :: raw :: c_char , __file : * const :: std :: os :: raw :: c_char , __line : :: std :: os :: raw :: c_int ) ; } extern "C" { pub fn get_asn1c_environment_version ( ) -> :: std :: os :: raw :: c_int ; } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct ReferencePoint { pub latitude : :: std :: os :: raw :: c_long , pub longitude : :: std :: os :: raw :: c_long , pub altitude : :: std :: os :: raw :: c_long , pub _asn_ctx : asn_struct_ctx_t , } # [ test ] fn bindgen_test_layout_ReferencePoint ( ) { assert_eq ! ( :: std :: mem :: size_of :: < ReferencePoint > ( ) , 48usize , concat ! ( "Size of: " , stringify ! ( ReferencePoint ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < ReferencePoint > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( ReferencePoint ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < ReferencePoint > ( ) ) ) . latitude as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( ReferencePoint ) , "::" , stringify ! ( latitude ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < ReferencePoint > ( ) ) ) . longitude as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( ReferencePoint ) , "::" , stringify ! ( longitude ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < ReferencePoint > ( ) ) ) . altitude as * const _ as usize } , 16usize , concat ! ( "Offset of field: " , stringify ! ( ReferencePoint ) , "::" , stringify ! ( altitude ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < ReferencePoint > ( ) ) ) . _asn_ctx as * const _ as usize } , 24usize , concat ! ( "Offset of field: " , stringify ! ( ReferencePoint ) , "::" , stringify ! ( _asn_ctx ) ) ) ; } pub type ReferencePoint_t = ReferencePoint ; extern "C" { # [ link_name = "\u{1}asn_DEF_ReferencePoint" ] pub static mut asn_DEF_ReferencePoint : asn_TYPE_descriptor_t ; } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct PositionOffset { pub position_north : :: std :: os :: raw :: c_long , pub position_east : :: std :: os :: raw :: c_long , pub std_dev_position_north : * mut :: std :: os :: raw :: c_long , pub std_dev_position_east : * mut :: std :: os :: raw :: c_long , pub _asn_ctx : asn_struct_ctx_t , } # [ test ] fn bindgen_test_layout_PositionOffset ( ) { assert_eq ! ( :: std :: mem :: size_of :: < PositionOffset > ( ) , 56usize , concat ! ( "Size of: " , stringify ! ( PositionOffset ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < PositionOffset > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( PositionOffset ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < PositionOffset > ( ) ) ) . position_north as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( PositionOffset ) , "::" , stringify ! ( position_north ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < PositionOffset > ( ) ) ) . position_east as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( PositionOffset ) , "::" , stringify ! ( position_east ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < PositionOffset > ( ) ) ) . std_dev_position_north as * const _ as usize } , 16usize , concat ! ( "Offset of field: " , stringify ! ( PositionOffset ) , "::" , stringify ! ( std_dev_position_north ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < PositionOffset > ( ) ) ) . std_dev_position_east as * const _ as usize } , 24usize , concat ! ( "Offset of field: " , stringify ! ( PositionOffset ) , "::" , stringify ! ( std_dev_position_east ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < PositionOffset > ( ) ) ) . _asn_ctx as * const _ as usize } , 32usize , concat ! ( "Offset of field: " , stringify ! ( PositionOffset ) , "::" , stringify ! ( _asn_ctx ) ) ) ; } pub type PositionOffset_t = PositionOffset ; extern "C" { # [ link_name = "\u{1}asn_DEF_PositionOffset" ] pub static mut asn_DEF_PositionOffset : asn_TYPE_descriptor_t ; } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct MovingVector { pub velocity_north : :: std :: os :: raw :: c_long , pub velocity_east : :: std :: os :: raw :: c_long , pub std_dev_velocity_north : * mut :: std :: os :: raw :: c_long , pub std_dev_velocity_east : * mut :: std :: os :: raw :: c_long , pub _asn_ctx : asn_struct_ctx_t , } # [ test ] fn bindgen_test_layout_MovingVector ( ) { assert_eq ! ( :: std :: mem :: size_of :: < MovingVector > ( ) , 56usize , concat ! ( "Size of: " , stringify ! ( MovingVector ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < MovingVector > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( MovingVector ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MovingVector > ( ) ) ) . velocity_north as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( MovingVector ) , "::" , stringify ! ( velocity_north ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MovingVector > ( ) ) ) . velocity_east as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( MovingVector ) , "::" , stringify ! ( velocity_east ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MovingVector > ( ) ) ) . std_dev_velocity_north as * const _ as usize } , 16usize , concat ! ( "Offset of field: " , stringify ! ( MovingVector ) , "::" , stringify ! ( std_dev_velocity_north ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MovingVector > ( ) ) ) . std_dev_velocity_east as * const _ as usize } , 24usize , concat ! ( "Offset of field: " , stringify ! ( MovingVector ) , "::" , stringify ! ( std_dev_velocity_east ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < MovingVector > ( ) ) ) . _asn_ctx as * const _ as usize } , 32usize , concat ! ( "Offset of field: " , stringify ! ( MovingVector ) , "::" , stringify ! ( _asn_ctx ) ) ) ; } pub type MovingVector_t = MovingVector ; extern "C" { # [ link_name = "\u{1}asn_DEF_MovingVector" ] pub static mut asn_DEF_MovingVector : asn_TYPE_descriptor_t ; } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct ObjectSize { pub length : :: std :: os :: raw :: c_long , pub width : * mut :: std :: os :: raw :: c_long , pub height : * mut :: std :: os :: raw :: c_long , pub std_dev_length : * mut :: std :: os :: raw :: c_long , pub std_dev_width : * mut :: std :: os :: raw :: c_long , pub std_dev_height : * mut :: std :: os :: raw :: c_long , pub _asn_ctx : asn_struct_ctx_t , } # [ test ] fn bindgen_test_layout_ObjectSize ( ) { assert_eq ! ( :: std :: mem :: size_of :: < ObjectSize > ( ) , 72usize , concat ! ( "Size of: " , stringify ! ( ObjectSize ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < ObjectSize > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( ObjectSize ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < ObjectSize > ( ) ) ) . length as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( ObjectSize ) , "::" , stringify ! ( length ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < ObjectSize > ( ) ) ) . width as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( ObjectSize ) , "::" , stringify ! ( width ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < ObjectSize > ( ) ) ) . height as * const _ as usize } , 16usize , concat ! ( "Offset of field: " , stringify ! ( ObjectSize ) , "::" , stringify ! ( height ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < ObjectSize > ( ) ) ) . std_dev_length as * const _ as usize } , 24usize , concat ! ( "Offset of field: " , stringify ! ( ObjectSize ) , "::" , stringify ! ( std_dev_length ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < ObjectSize > ( ) ) ) . std_dev_width as * const _ as usize } , 32usize , concat ! ( "Offset of field: " , stringify ! ( ObjectSize ) , "::" , stringify ! ( std_dev_width ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < ObjectSize > ( ) ) ) . std_dev_height as * const _ as usize } , 40usize , concat ! ( "Offset of field: " , stringify ! ( ObjectSize ) , "::" , stringify ! ( std_dev_height ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < ObjectSize > ( ) ) ) . _asn_ctx as * const _ as usize } , 48usize , concat ! ( "Offset of field: " , stringify ! ( ObjectSize ) , "::" , stringify ! ( _asn_ctx ) ) ) ; } pub type ObjectSize_t = ObjectSize ; extern "C" { # [ link_name = "\u{1}asn_DEF_ObjectSize" ] pub static mut asn_DEF_ObjectSize : asn_TYPE_descriptor_t ; } extern "C" { # [ link_name = "\u{1}asn_DEF_NativeEnumerated" ] pub static mut asn_DEF_NativeEnumerated : asn_TYPE_descriptor_t ; } extern "C" { pub fn NativeEnumerated_encode_xer ( type_descriptor : * mut asn_TYPE_descriptor_s , struct_ptr : * mut :: std :: os :: raw :: c_void , ilevel : :: std :: os :: raw :: c_int , xer_flags : xer_encoder_flags_e , consume_bytes_cb : asn_app_consume_bytes_f , app_key : * mut :: std :: os :: raw :: c_void ) -> asn_enc_rval_t ; } extern "C" { pub fn NativeEnumerated_decode_uper ( opt_codec_ctx : * mut asn_codec_ctx_t , type_descriptor : * mut asn_TYPE_descriptor_s , constraints : * mut asn_per_constraints_t , struct_ptr : * mut * mut :: std :: os :: raw :: c_void , per_data : * mut asn_per_data_t ) -> asn_dec_rval_t ; } extern "C" { pub fn NativeEnumerated_encode_uper ( type_descriptor : * mut asn_TYPE_descriptor_s , constraints : * mut asn_per_constraints_t , struct_ptr : * mut :: std :: os :: raw :: c_void , per_output : * mut asn_per_outp_t ) -> asn_enc_rval_t ; } pub const ObjectType_ObjectType_not_classified : ObjectType = 0 ; pub const ObjectType_ObjectType_pedestrian : ObjectType = 1 ; pub const ObjectType_ObjectType_car : ObjectType = 2 ; pub const ObjectType_ObjectType_van_or_transporter : ObjectType = 3 ; pub const ObjectType_ObjectType_truck : ObjectType = 4 ; pub const ObjectType_ObjectType_bus : ObjectType = 5 ; pub const ObjectType_ObjectType_motorbike : ObjectType = 6 ; pub const ObjectType_ObjectType_bicycle : ObjectType = 7 ; pub const ObjectType_ObjectType_optional_1 : ObjectType = 8 ; pub const ObjectType_ObjectType_optional_2 : ObjectType = 9 ; pub const ObjectType_ObjectType_optinal_3 : ObjectType = 10 ; pub type ObjectType = u32 ; pub use self :: ObjectType as e_ObjectType ; pub type ObjectType_t = :: std :: os :: raw :: c_long ; extern "C" { # [ link_name = "\u{1}asn_DEF_ObjectType" ] pub static mut asn_DEF_ObjectType : asn_TYPE_descriptor_t ; } extern "C" { pub fn ObjectType_free ( type_descriptor : * mut asn_TYPE_descriptor_s , struct_ptr : * mut :: std :: os :: raw :: c_void , free_contents_only : :: std :: os :: raw :: c_int ) ; } extern "C" { pub fn ObjectType_print ( type_descriptor : * mut asn_TYPE_descriptor_s , struct_ptr : * const :: std :: os :: raw :: c_void , level : :: std :: os :: raw :: c_int , callback : asn_app_consume_bytes_f , app_key : * mut :: std :: os :: raw :: c_void ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn ObjectType_constraint ( type_descriptor : * mut asn_TYPE_descriptor_s , struct_ptr : * const :: std :: os :: raw :: c_void , optional_callback : asn_app_constraint_failed_f , optional_app_key : * mut :: std :: os :: raw :: c_void ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn ObjectType_decode_ber ( opt_codec_ctx : * mut asn_codec_ctx_s , type_descriptor : * mut asn_TYPE_descriptor_s , struct_ptr : * mut * mut :: std :: os :: raw :: c_void , buf_ptr : * const :: std :: os :: raw :: c_void , size : usize , tag_mode : :: std :: os :: raw :: c_int ) -> asn_dec_rval_t ; } extern "C" { pub fn ObjectType_encode_der ( type_descriptor : * mut asn_TYPE_descriptor_s , struct_ptr : * mut :: std :: os :: raw :: c_void , tag_mode : :: std :: os :: raw :: c_int , tag : ber_tlv_tag_t , consume_bytes_cb : asn_app_consume_bytes_f , app_key : * mut :: std :: os :: raw :: c_void ) -> asn_enc_rval_t ; } extern "C" { pub fn ObjectType_decode_xer ( opt_codec_ctx : * mut asn_codec_ctx_t , type_descriptor : * mut asn_TYPE_descriptor_s , struct_ptr : * mut * mut :: std :: os :: raw :: c_void , opt_mname : * const :: std :: os :: raw :: c_char , buf_ptr : * const :: std :: os :: raw :: c_void , size : usize ) -> asn_dec_rval_t ; } extern "C" { pub fn ObjectType_encode_xer ( type_descriptor : * mut asn_TYPE_descriptor_s , struct_ptr : * mut :: std :: os :: raw :: c_void , ilevel : :: std :: os :: raw :: c_int , xer_flags : xer_encoder_flags_e , consume_bytes_cb : asn_app_consume_bytes_f , app_key : * mut :: std :: os :: raw :: c_void ) -> asn_enc_rval_t ; } extern "C" { pub fn ObjectType_decode_uper ( opt_codec_ctx : * mut asn_codec_ctx_t , type_descriptor : * mut asn_TYPE_descriptor_s , constraints : * mut asn_per_constraints_t , struct_ptr : * mut * mut :: std :: os :: raw :: c_void , per_data : * mut asn_per_data_t ) -> asn_dec_rval_t ; } extern "C" { pub fn ObjectType_encode_uper ( type_descriptor : * mut asn_TYPE_descriptor_s , constraints : * mut asn_per_constraints_t , struct_ptr : * mut :: std :: os :: raw :: c_void , per_output : * mut asn_per_outp_t ) -> asn_enc_rval_t ; } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct Covariance { pub north_pos_east_pos : * mut :: std :: os :: raw :: c_long , pub north_pos_north_vel : * mut :: std :: os :: raw :: c_long , pub north_pos_east_vel : * mut :: std :: os :: raw :: c_long , pub east_pos_north_vel : * mut :: std :: os :: raw :: c_long , pub east_pos_east_vel : * mut :: std :: os :: raw :: c_long , pub north_vel_east_vel : * mut :: std :: os :: raw :: c_long , pub _asn_ctx : asn_struct_ctx_t , } # [ test ] fn bindgen_test_layout_Covariance ( ) { assert_eq ! ( :: std :: mem :: size_of :: < Covariance > ( ) , 72usize , concat ! ( "Size of: " , stringify ! ( Covariance ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < Covariance > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( Covariance ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < Covariance > ( ) ) ) . north_pos_east_pos as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( Covariance ) , "::" , stringify ! ( north_pos_east_pos ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < Covariance > ( ) ) ) . north_pos_north_vel as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( Covariance ) , "::" , stringify ! ( north_pos_north_vel ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < Covariance > ( ) ) ) . north_pos_east_vel as * const _ as usize } , 16usize , concat ! ( "Offset of field: " , stringify ! ( Covariance ) , "::" , stringify ! ( north_pos_east_vel ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < Covariance > ( ) ) ) . east_pos_north_vel as * const _ as usize } , 24usize , concat ! ( "Offset of field: " , stringify ! ( Covariance ) , "::" , stringify ! ( east_pos_north_vel ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < Covariance > ( ) ) ) . east_pos_east_vel as * const _ as usize } , 32usize , concat ! ( "Offset of field: " , stringify ! ( Covariance ) , "::" , stringify ! ( east_pos_east_vel ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < Covariance > ( ) ) ) . north_vel_east_vel as * const _ as usize } , 40usize , concat ! ( "Offset of field: " , stringify ! ( Covariance ) , "::" , stringify ! ( north_vel_east_vel ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < Covariance > ( ) ) ) . _asn_ctx as * const _ as usize } , 48usize , concat ! ( "Offset of field: " , stringify ! ( Covariance ) , "::" , stringify ! ( _asn_ctx ) ) ) ; } pub type Covariance_t = Covariance ; extern "C" { # [ link_name = "\u{1}asn_DEF_Covariance" ] pub static mut asn_DEF_Covariance : asn_TYPE_descriptor_t ; } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct PathPoint { pub position_offset : PositionOffset_t , pub probybility : :: std :: os :: raw :: c_long , pub _asn_ctx : asn_struct_ctx_t , } # [ test ] fn bindgen_test_layout_PathPoint ( ) { assert_eq ! ( :: std :: mem :: size_of :: < PathPoint > ( ) , 88usize , concat ! ( "Size of: " , stringify ! ( PathPoint ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < PathPoint > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( PathPoint ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < PathPoint > ( ) ) ) . position_offset as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( PathPoint ) , "::" , stringify ! ( position_offset ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < PathPoint > ( ) ) ) . probybility as * const _ as usize } , 56usize , concat ! ( "Offset of field: " , stringify ! ( PathPoint ) , "::" , stringify ! ( probybility ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < PathPoint > ( ) ) ) . _asn_ctx as * const _ as usize } , 64usize , concat ! ( "Offset of field: " , stringify ! ( PathPoint ) , "::" , stringify ! ( _asn_ctx ) ) ) ; } pub type PathPoint_t = PathPoint ; extern "C" { # [ link_name = "\u{1}asn_DEF_PathPoint" ] pub static mut asn_DEF_PathPoint : asn_TYPE_descriptor_t ; } extern "C" { 
 /// Implementation of the SET OF structure. 
 pub fn asn_set_add ( asn_set_of_x : * mut :: std :: os :: raw :: c_void , ptr : * mut :: std :: os :: raw :: c_void ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn asn_set_del ( asn_set_of_x : * mut :: std :: os :: raw :: c_void , number : :: std :: os :: raw :: c_int , _do_free : :: std :: os :: raw :: c_int ) ; } extern "C" { pub fn asn_set_empty ( asn_set_of_x : * mut :: std :: os :: raw :: c_void ) ; } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct asn_anonymous_set_ { pub array : * mut * mut :: std :: os :: raw :: c_void , pub count : :: std :: os :: raw :: c_int , pub size : :: std :: os :: raw :: c_int , pub free : :: std :: option :: Option < unsafe extern "C" fn ( arg1 : * mut :: std :: os :: raw :: c_void ) > , } # [ test ] fn bindgen_test_layout_asn_anonymous_set_ ( ) { assert_eq ! ( :: std :: mem :: size_of :: < asn_anonymous_set_ > ( ) , 24usize , concat ! ( "Size of: " , stringify ! ( asn_anonymous_set_ ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < asn_anonymous_set_ > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( asn_anonymous_set_ ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < asn_anonymous_set_ > ( ) ) ) . array as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( asn_anonymous_set_ ) , "::" , stringify ! ( array ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < asn_anonymous_set_ > ( ) ) ) . count as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( asn_anonymous_set_ ) , "::" , stringify ! ( count ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < asn_anonymous_set_ > ( ) ) ) . size as * const _ as usize } , 12usize , concat ! ( "Offset of field: " , stringify ! ( asn_anonymous_set_ ) , "::" , stringify ! ( size ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < asn_anonymous_set_ > ( ) ) ) . free as * const _ as usize } , 16usize , concat ! ( "Offset of field: " , stringify ! ( asn_anonymous_set_ ) , "::" , stringify ! ( free ) ) ) ; } extern "C" { pub fn asn_sequence_del ( asn_sequence_of_x : * mut :: std :: os :: raw :: c_void , number : :: std :: os :: raw :: c_int , _do_free : :: std :: os :: raw :: c_int ) ; } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct asn_anonymous_sequence_ { pub array : * mut * mut :: std :: os :: raw :: c_void , pub count : :: std :: os :: raw :: c_int , pub size : :: std :: os :: raw :: c_int , pub free : :: std :: option :: Option < unsafe extern "C" fn ( arg1 : * mut :: std :: os :: raw :: c_void ) > , } # [ test ] fn bindgen_test_layout_asn_anonymous_sequence_ ( ) { assert_eq ! ( :: std :: mem :: size_of :: < asn_anonymous_sequence_ > ( ) , 24usize , concat ! ( "Size of: " , stringify ! ( asn_anonymous_sequence_ ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < asn_anonymous_sequence_ > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( asn_anonymous_sequence_ ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < asn_anonymous_sequence_ > ( ) ) ) . array as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( asn_anonymous_sequence_ ) , "::" , stringify ! ( array ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < asn_anonymous_sequence_ > ( ) ) ) . count as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( asn_anonymous_sequence_ ) , "::" , stringify ! ( count ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < asn_anonymous_sequence_ > ( ) ) ) . size as * const _ as usize } , 12usize , concat ! ( "Offset of field: " , stringify ! ( asn_anonymous_sequence_ ) , "::" , stringify ! ( size ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < asn_anonymous_sequence_ > ( ) ) ) . free as * const _ as usize } , 16usize , concat ! ( "Offset of field: " , stringify ! ( asn_anonymous_sequence_ ) , "::" , stringify ! ( free ) ) ) ; } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct asn_SET_OF_specifics_s { pub struct_size : :: std :: os :: raw :: c_int , pub ctx_offset : :: std :: os :: raw :: c_int , pub as_XMLValueList : :: std :: os :: raw :: c_int , } # [ test ] fn bindgen_test_layout_asn_SET_OF_specifics_s ( ) { assert_eq ! ( :: std :: mem :: size_of :: < asn_SET_OF_specifics_s > ( ) , 12usize , concat ! ( "Size of: " , stringify ! ( asn_SET_OF_specifics_s ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < asn_SET_OF_specifics_s > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( asn_SET_OF_specifics_s ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < asn_SET_OF_specifics_s > ( ) ) ) . struct_size as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( asn_SET_OF_specifics_s ) , "::" , stringify ! ( struct_size ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < asn_SET_OF_specifics_s > ( ) ) ) . ctx_offset as * const _ as usize } , 4usize , concat ! ( "Offset of field: " , stringify ! ( asn_SET_OF_specifics_s ) , "::" , stringify ! ( ctx_offset ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < asn_SET_OF_specifics_s > ( ) ) ) . as_XMLValueList as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( asn_SET_OF_specifics_s ) , "::" , stringify ! ( as_XMLValueList ) ) ) ; } pub type asn_SET_OF_specifics_t = asn_SET_OF_specifics_s ; extern "C" { pub fn SET_OF_free ( type_descriptor : * mut asn_TYPE_descriptor_s , struct_ptr : * mut :: std :: os :: raw :: c_void , free_contents_only : :: std :: os :: raw :: c_int ) ; } extern "C" { pub fn SET_OF_print ( type_descriptor : * mut asn_TYPE_descriptor_s , struct_ptr : * const :: std :: os :: raw :: c_void , level : :: std :: os :: raw :: c_int , callback : asn_app_consume_bytes_f , app_key : * mut :: std :: os :: raw :: c_void ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn SET_OF_constraint ( type_descriptor : * mut asn_TYPE_descriptor_s , struct_ptr : * const :: std :: os :: raw :: c_void , optional_callback : asn_app_constraint_failed_f , optional_app_key : * mut :: std :: os :: raw :: c_void ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn SET_OF_decode_ber ( opt_codec_ctx : * mut asn_codec_ctx_s , type_descriptor : * mut asn_TYPE_descriptor_s , struct_ptr : * mut * mut :: std :: os :: raw :: c_void , buf_ptr : * const :: std :: os :: raw :: c_void , size : usize , tag_mode : :: std :: os :: raw :: c_int ) -> asn_dec_rval_t ; } extern "C" { pub fn SET_OF_encode_der ( type_descriptor : * mut asn_TYPE_descriptor_s , struct_ptr : * mut :: std :: os :: raw :: c_void , tag_mode : :: std :: os :: raw :: c_int , tag : ber_tlv_tag_t , consume_bytes_cb : asn_app_consume_bytes_f , app_key : * mut :: std :: os :: raw :: c_void ) -> asn_enc_rval_t ; } extern "C" { pub fn SET_OF_decode_xer ( opt_codec_ctx : * mut asn_codec_ctx_t , type_descriptor : * mut asn_TYPE_descriptor_s , struct_ptr : * mut * mut :: std :: os :: raw :: c_void , opt_mname : * const :: std :: os :: raw :: c_char , buf_ptr : * const :: std :: os :: raw :: c_void , size : usize ) -> asn_dec_rval_t ; } extern "C" { pub fn SET_OF_encode_xer ( type_descriptor : * mut asn_TYPE_descriptor_s , struct_ptr : * mut :: std :: os :: raw :: c_void , ilevel : :: std :: os :: raw :: c_int , xer_flags : xer_encoder_flags_e , consume_bytes_cb : asn_app_consume_bytes_f , app_key : * mut :: std :: os :: raw :: c_void ) -> asn_enc_rval_t ; } extern "C" { pub fn SET_OF_decode_uper ( opt_codec_ctx : * mut asn_codec_ctx_t , type_descriptor : * mut asn_TYPE_descriptor_s , constraints : * mut asn_per_constraints_t , struct_ptr : * mut * mut :: std :: os :: raw :: c_void , per_data : * mut asn_per_data_t ) -> asn_dec_rval_t ; } extern "C" { pub fn SET_OF_encode_uper ( type_descriptor : * mut asn_TYPE_descriptor_s , constraints : * mut asn_per_constraints_t , struct_ptr : * mut :: std :: os :: raw :: c_void , per_output : * mut asn_per_outp_t ) -> asn_enc_rval_t ; } extern "C" { pub fn SEQUENCE_OF_encode_der ( type_descriptor : * mut asn_TYPE_descriptor_s , struct_ptr : * mut :: std :: os :: raw :: c_void , tag_mode : :: std :: os :: raw :: c_int , tag : ber_tlv_tag_t , consume_bytes_cb : asn_app_consume_bytes_f , app_key : * mut :: std :: os :: raw :: c_void ) -> asn_enc_rval_t ; } extern "C" { pub fn SEQUENCE_OF_encode_xer ( type_descriptor : * mut asn_TYPE_descriptor_s , struct_ptr : * mut :: std :: os :: raw :: c_void , ilevel : :: std :: os :: raw :: c_int , xer_flags : xer_encoder_flags_e , consume_bytes_cb : asn_app_consume_bytes_f , app_key : * mut :: std :: os :: raw :: c_void ) -> asn_enc_rval_t ; } extern "C" { pub fn SEQUENCE_OF_encode_uper ( type_descriptor : * mut asn_TYPE_descriptor_s , constraints : * mut asn_per_constraints_t , struct_ptr : * mut :: std :: os :: raw :: c_void , per_output : * mut asn_per_outp_t ) -> asn_enc_rval_t ; } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct Path { pub list : Path__bindgen_ty_1 , pub _asn_ctx : asn_struct_ctx_t , } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct Path__bindgen_ty_1 { pub array : * mut * mut PathPoint , pub count : :: std :: os :: raw :: c_int , pub size : :: std :: os :: raw :: c_int , pub free : :: std :: option :: Option < unsafe extern "C" fn ( arg1 : * mut PathPoint ) > , } # [ test ] fn bindgen_test_layout_Path__bindgen_ty_1 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < Path__bindgen_ty_1 > ( ) , 24usize , concat ! ( "Size of: " , stringify ! ( Path__bindgen_ty_1 ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < Path__bindgen_ty_1 > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( Path__bindgen_ty_1 ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < Path__bindgen_ty_1 > ( ) ) ) . array as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( Path__bindgen_ty_1 ) , "::" , stringify ! ( array ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < Path__bindgen_ty_1 > ( ) ) ) . count as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( Path__bindgen_ty_1 ) , "::" , stringify ! ( count ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < Path__bindgen_ty_1 > ( ) ) ) . size as * const _ as usize } , 12usize , concat ! ( "Offset of field: " , stringify ! ( Path__bindgen_ty_1 ) , "::" , stringify ! ( size ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < Path__bindgen_ty_1 > ( ) ) ) . free as * const _ as usize } , 16usize , concat ! ( "Offset of field: " , stringify ! ( Path__bindgen_ty_1 ) , "::" , stringify ! ( free ) ) ) ; } # [ test ] fn bindgen_test_layout_Path ( ) { assert_eq ! ( :: std :: mem :: size_of :: < Path > ( ) , 48usize , concat ! ( "Size of: " , stringify ! ( Path ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < Path > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( Path ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < Path > ( ) ) ) . list as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( Path ) , "::" , stringify ! ( list ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < Path > ( ) ) ) . _asn_ctx as * const _ as usize } , 24usize , concat ! ( "Offset of field: " , stringify ! ( Path ) , "::" , stringify ! ( _asn_ctx ) ) ) ; } pub type Path_t = Path ; extern "C" { # [ link_name = "\u{1}asn_DEF_Path" ] pub static mut asn_DEF_Path : asn_TYPE_descriptor_t ; } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct PredictedPath { pub timestamp_dt : :: std :: os :: raw :: c_long , pub path : Path_t , pub _asn_ctx : asn_struct_ctx_t , } # [ test ] fn bindgen_test_layout_PredictedPath ( ) { assert_eq ! ( :: std :: mem :: size_of :: < PredictedPath > ( ) , 80usize , concat ! ( "Size of: " , stringify ! ( PredictedPath ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < PredictedPath > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( PredictedPath ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < PredictedPath > ( ) ) ) . timestamp_dt as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( PredictedPath ) , "::" , stringify ! ( timestamp_dt ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < PredictedPath > ( ) ) ) . path as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( PredictedPath ) , "::" , stringify ! ( path ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < PredictedPath > ( ) ) ) . _asn_ctx as * const _ as usize } , 56usize , concat ! ( "Offset of field: " , stringify ! ( PredictedPath ) , "::" , stringify ! ( _asn_ctx ) ) ) ; } pub type PredictedPath_t = PredictedPath ; extern "C" { # [ link_name = "\u{1}asn_DEF_PredictedPath" ] pub static mut asn_DEF_PredictedPath : asn_TYPE_descriptor_t ; } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct SectorIds { pub list : SectorIds__bindgen_ty_1 , pub _asn_ctx : asn_struct_ctx_t , } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct SectorIds__bindgen_ty_1 { pub array : * mut * mut :: std :: os :: raw :: c_long , pub count : :: std :: os :: raw :: c_int , pub size : :: std :: os :: raw :: c_int , pub free : :: std :: option :: Option < unsafe extern "C" fn ( arg1 : * mut :: std :: os :: raw :: c_long ) > , } # [ test ] fn bindgen_test_layout_SectorIds__bindgen_ty_1 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < SectorIds__bindgen_ty_1 > ( ) , 24usize , concat ! ( "Size of: " , stringify ! ( SectorIds__bindgen_ty_1 ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < SectorIds__bindgen_ty_1 > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( SectorIds__bindgen_ty_1 ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < SectorIds__bindgen_ty_1 > ( ) ) ) . array as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( SectorIds__bindgen_ty_1 ) , "::" , stringify ! ( array ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < SectorIds__bindgen_ty_1 > ( ) ) ) . count as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( SectorIds__bindgen_ty_1 ) , "::" , stringify ! ( count ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < SectorIds__bindgen_ty_1 > ( ) ) ) . size as * const _ as usize } , 12usize , concat ! ( "Offset of field: " , stringify ! ( SectorIds__bindgen_ty_1 ) , "::" , stringify ! ( size ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < SectorIds__bindgen_ty_1 > ( ) ) ) . free as * const _ as usize } , 16usize , concat ! ( "Offset of field: " , stringify ! ( SectorIds__bindgen_ty_1 ) , "::" , stringify ! ( free ) ) ) ; } # [ test ] fn bindgen_test_layout_SectorIds ( ) { assert_eq ! ( :: std :: mem :: size_of :: < SectorIds > ( ) , 48usize , concat ! ( "Size of: " , stringify ! ( SectorIds ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < SectorIds > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( SectorIds ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < SectorIds > ( ) ) ) . list as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( SectorIds ) , "::" , stringify ! ( list ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < SectorIds > ( ) ) ) . _asn_ctx as * const _ as usize } , 24usize , concat ! ( "Offset of field: " , stringify ! ( SectorIds ) , "::" , stringify ! ( _asn_ctx ) ) ) ; } pub type SectorIds_t = SectorIds ; extern "C" { # [ link_name = "\u{1}asn_DEF_SectorIds" ] pub static mut asn_DEF_SectorIds : asn_TYPE_descriptor_t ; } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct Error { pub id : :: std :: os :: raw :: c_long , pub sector_ids : SectorIds_t , pub _asn_ctx : asn_struct_ctx_t , } # [ test ] fn bindgen_test_layout_Error ( ) { assert_eq ! ( :: std :: mem :: size_of :: < Error > ( ) , 80usize , concat ! ( "Size of: " , stringify ! ( Error ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < Error > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( Error ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < Error > ( ) ) ) . id as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( Error ) , "::" , stringify ! ( id ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < Error > ( ) ) ) . sector_ids as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( Error ) , "::" , stringify ! ( sector_ids ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < Error > ( ) ) ) . _asn_ctx as * const _ as usize } , 56usize , concat ! ( "Offset of field: " , stringify ! ( Error ) , "::" , stringify ! ( _asn_ctx ) ) ) ; } pub type Error_t = Error ; extern "C" { # [ link_name = "\u{1}asn_DEF_Error" ] pub static mut asn_DEF_Error : asn_TYPE_descriptor_t ; } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct Errors { pub list : Errors__bindgen_ty_1 , pub _asn_ctx : asn_struct_ctx_t , } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct Errors__bindgen_ty_1 { pub array : * mut * mut Error , pub count : :: std :: os :: raw :: c_int , pub size : :: std :: os :: raw :: c_int , pub free : :: std :: option :: Option < unsafe extern "C" fn ( arg1 : * mut Error ) > , } # [ test ] fn bindgen_test_layout_Errors__bindgen_ty_1 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < Errors__bindgen_ty_1 > ( ) , 24usize , concat ! ( "Size of: " , stringify ! ( Errors__bindgen_ty_1 ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < Errors__bindgen_ty_1 > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( Errors__bindgen_ty_1 ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < Errors__bindgen_ty_1 > ( ) ) ) . array as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( Errors__bindgen_ty_1 ) , "::" , stringify ! ( array ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < Errors__bindgen_ty_1 > ( ) ) ) . count as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( Errors__bindgen_ty_1 ) , "::" , stringify ! ( count ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < Errors__bindgen_ty_1 > ( ) ) ) . size as * const _ as usize } , 12usize , concat ! ( "Offset of field: " , stringify ! ( Errors__bindgen_ty_1 ) , "::" , stringify ! ( size ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < Errors__bindgen_ty_1 > ( ) ) ) . free as * const _ as usize } , 16usize , concat ! ( "Offset of field: " , stringify ! ( Errors__bindgen_ty_1 ) , "::" , stringify ! ( free ) ) ) ; } # [ test ] fn bindgen_test_layout_Errors ( ) { assert_eq ! ( :: std :: mem :: size_of :: < Errors > ( ) , 48usize , concat ! ( "Size of: " , stringify ! ( Errors ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < Errors > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( Errors ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < Errors > ( ) ) ) . list as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( Errors ) , "::" , stringify ! ( list ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < Errors > ( ) ) ) . _asn_ctx as * const _ as usize } , 24usize , concat ! ( "Offset of field: " , stringify ! ( Errors ) , "::" , stringify ! ( _asn_ctx ) ) ) ; } pub type Errors_t = Errors ; extern "C" { # [ link_name = "\u{1}asn_DEF_Errors" ] pub static mut asn_DEF_Errors : asn_TYPE_descriptor_t ; } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct EnvironmentEnvelope { pub version : :: std :: os :: raw :: c_long , pub server_id : :: std :: os :: raw :: c_long , pub reference_point : ReferencePoint_t , pub error_codes : Errors_t , pub _asn_ctx : asn_struct_ctx_t , } # [ test ] fn bindgen_test_layout_EnvironmentEnvelope ( ) { assert_eq ! ( :: std :: mem :: size_of :: < EnvironmentEnvelope > ( ) , 136usize , concat ! ( "Size of: " , stringify ! ( EnvironmentEnvelope ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < EnvironmentEnvelope > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( EnvironmentEnvelope ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < EnvironmentEnvelope > ( ) ) ) . version as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( EnvironmentEnvelope ) , "::" , stringify ! ( version ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < EnvironmentEnvelope > ( ) ) ) . server_id as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( EnvironmentEnvelope ) , "::" , stringify ! ( server_id ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < EnvironmentEnvelope > ( ) ) ) . reference_point as * const _ as usize } , 16usize , concat ! ( "Offset of field: " , stringify ! ( EnvironmentEnvelope ) , "::" , stringify ! ( reference_point ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < EnvironmentEnvelope > ( ) ) ) . error_codes as * const _ as usize } , 64usize , concat ! ( "Offset of field: " , stringify ! ( EnvironmentEnvelope ) , "::" , stringify ! ( error_codes ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < EnvironmentEnvelope > ( ) ) ) . _asn_ctx as * const _ as usize } , 112usize , concat ! ( "Offset of field: " , stringify ! ( EnvironmentEnvelope ) , "::" , stringify ! ( _asn_ctx ) ) ) ; } pub type EnvironmentEnvelope_t = EnvironmentEnvelope ; extern "C" { # [ link_name = "\u{1}asn_DEF_EnvironmentEnvelope" ] pub static mut asn_DEF_EnvironmentEnvelope : asn_TYPE_descriptor_t ; } pub type BOOLEAN_t = :: std :: os :: raw :: c_int ; extern "C" { # [ link_name = "\u{1}asn_DEF_BOOLEAN" ] pub static mut asn_DEF_BOOLEAN : asn_TYPE_descriptor_t ; } extern "C" { pub fn BOOLEAN_free ( type_descriptor : * mut asn_TYPE_descriptor_s , struct_ptr : * mut :: std :: os :: raw :: c_void , free_contents_only : :: std :: os :: raw :: c_int ) ; } extern "C" { pub fn BOOLEAN_print ( type_descriptor : * mut asn_TYPE_descriptor_s , struct_ptr : * const :: std :: os :: raw :: c_void , level : :: std :: os :: raw :: c_int , callback : asn_app_consume_bytes_f , app_key : * mut :: std :: os :: raw :: c_void ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn BOOLEAN_decode_ber ( opt_codec_ctx : * mut asn_codec_ctx_s , type_descriptor : * mut asn_TYPE_descriptor_s , struct_ptr : * mut * mut :: std :: os :: raw :: c_void , buf_ptr : * const :: std :: os :: raw :: c_void , size : usize , tag_mode : :: std :: os :: raw :: c_int ) -> asn_dec_rval_t ; } extern "C" { pub fn BOOLEAN_encode_der ( type_descriptor : * mut asn_TYPE_descriptor_s , struct_ptr : * mut :: std :: os :: raw :: c_void , tag_mode : :: std :: os :: raw :: c_int , tag : ber_tlv_tag_t , consume_bytes_cb : asn_app_consume_bytes_f , app_key : * mut :: std :: os :: raw :: c_void ) -> asn_enc_rval_t ; } extern "C" { pub fn BOOLEAN_decode_xer ( opt_codec_ctx : * mut asn_codec_ctx_t , type_descriptor : * mut asn_TYPE_descriptor_s , struct_ptr : * mut * mut :: std :: os :: raw :: c_void , opt_mname : * const :: std :: os :: raw :: c_char , buf_ptr : * const :: std :: os :: raw :: c_void , size : usize ) -> asn_dec_rval_t ; } extern "C" { pub fn BOOLEAN_encode_xer ( type_descriptor : * mut asn_TYPE_descriptor_s , struct_ptr : * mut :: std :: os :: raw :: c_void , ilevel : :: std :: os :: raw :: c_int , xer_flags : xer_encoder_flags_e , consume_bytes_cb : asn_app_consume_bytes_f , app_key : * mut :: std :: os :: raw :: c_void ) -> asn_enc_rval_t ; } extern "C" { pub fn BOOLEAN_decode_uper ( opt_codec_ctx : * mut asn_codec_ctx_t , type_descriptor : * mut asn_TYPE_descriptor_s , constraints : * mut asn_per_constraints_t , struct_ptr : * mut * mut :: std :: os :: raw :: c_void , per_data : * mut asn_per_data_t ) -> asn_dec_rval_t ; } extern "C" { pub fn BOOLEAN_encode_uper ( type_descriptor : * mut asn_TYPE_descriptor_s , constraints : * mut asn_per_constraints_t , struct_ptr : * mut :: std :: os :: raw :: c_void , per_output : * mut asn_per_outp_t ) -> asn_enc_rval_t ; } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct EnvironmentObjectDetection { pub timestamp : :: std :: os :: raw :: c_long , pub measured : BOOLEAN_t , pub global_id : :: std :: os :: raw :: c_long , pub probability_of_existence : :: std :: os :: raw :: c_long , pub position_offset : PositionOffset_t , pub moving_vector : * mut MovingVector , pub type_ : ObjectType_t , pub type_probability : :: std :: os :: raw :: c_long , pub size : ObjectSize_t , pub covariance : Covariance_t , pub orientation : :: std :: os :: raw :: c_long , pub std_dev_orientation : :: std :: os :: raw :: c_long , pub predicted_path : PredictedPath_t , pub _asn_ctx : asn_struct_ctx_t , } # [ test ] fn bindgen_test_layout_EnvironmentObjectDetection ( ) { assert_eq ! ( :: std :: mem :: size_of :: < EnvironmentObjectDetection > ( ) , 376usize , concat ! ( "Size of: " , stringify ! ( EnvironmentObjectDetection ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < EnvironmentObjectDetection > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( EnvironmentObjectDetection ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < EnvironmentObjectDetection > ( ) ) ) . timestamp as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( EnvironmentObjectDetection ) , "::" , stringify ! ( timestamp ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < EnvironmentObjectDetection > ( ) ) ) . measured as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( EnvironmentObjectDetection ) , "::" , stringify ! ( measured ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < EnvironmentObjectDetection > ( ) ) ) . global_id as * const _ as usize } , 16usize , concat ! ( "Offset of field: " , stringify ! ( EnvironmentObjectDetection ) , "::" , stringify ! ( global_id ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < EnvironmentObjectDetection > ( ) ) ) . probability_of_existence as * const _ as usize } , 24usize , concat ! ( "Offset of field: " , stringify ! ( EnvironmentObjectDetection ) , "::" , stringify ! ( probability_of_existence ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < EnvironmentObjectDetection > ( ) ) ) . position_offset as * const _ as usize } , 32usize , concat ! ( "Offset of field: " , stringify ! ( EnvironmentObjectDetection ) , "::" , stringify ! ( position_offset ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < EnvironmentObjectDetection > ( ) ) ) . moving_vector as * const _ as usize } , 88usize , concat ! ( "Offset of field: " , stringify ! ( EnvironmentObjectDetection ) , "::" , stringify ! ( moving_vector ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < EnvironmentObjectDetection > ( ) ) ) . type_ as * const _ as usize } , 96usize , concat ! ( "Offset of field: " , stringify ! ( EnvironmentObjectDetection ) , "::" , stringify ! ( type_ ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < EnvironmentObjectDetection > ( ) ) ) . type_probability as * const _ as usize } , 104usize , concat ! ( "Offset of field: " , stringify ! ( EnvironmentObjectDetection ) , "::" , stringify ! ( type_probability ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < EnvironmentObjectDetection > ( ) ) ) . size as * const _ as usize } , 112usize , concat ! ( "Offset of field: " , stringify ! ( EnvironmentObjectDetection ) , "::" , stringify ! ( size ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < EnvironmentObjectDetection > ( ) ) ) . covariance as * const _ as usize } , 184usize , concat ! ( "Offset of field: " , stringify ! ( EnvironmentObjectDetection ) , "::" , stringify ! ( covariance ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < EnvironmentObjectDetection > ( ) ) ) . orientation as * const _ as usize } , 256usize , concat ! ( "Offset of field: " , stringify ! ( EnvironmentObjectDetection ) , "::" , stringify ! ( orientation ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < EnvironmentObjectDetection > ( ) ) ) . std_dev_orientation as * const _ as usize } , 264usize , concat ! ( "Offset of field: " , stringify ! ( EnvironmentObjectDetection ) , "::" , stringify ! ( std_dev_orientation ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < EnvironmentObjectDetection > ( ) ) ) . predicted_path as * const _ as usize } , 272usize , concat ! ( "Offset of field: " , stringify ! ( EnvironmentObjectDetection ) , "::" , stringify ! ( predicted_path ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < EnvironmentObjectDetection > ( ) ) ) . _asn_ctx as * const _ as usize } , 352usize , concat ! ( "Offset of field: " , stringify ! ( EnvironmentObjectDetection ) , "::" , stringify ! ( _asn_ctx ) ) ) ; } pub type EnvironmentObjectDetection_t = EnvironmentObjectDetection ; extern "C" { # [ link_name = "\u{1}asn_DEF_EnvironmentObjectDetection" ] pub static mut asn_DEF_EnvironmentObjectDetection : asn_TYPE_descriptor_t ; } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct EnvironmentObjectDetections { pub list : EnvironmentObjectDetections__bindgen_ty_1 , pub _asn_ctx : asn_struct_ctx_t , } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct EnvironmentObjectDetections__bindgen_ty_1 { pub array : * mut * mut EnvironmentObjectDetection , pub count : :: std :: os :: raw :: c_int , pub size : :: std :: os :: raw :: c_int , pub free : :: std :: option :: Option < unsafe extern "C" fn ( arg1 : * mut EnvironmentObjectDetection ) > , } # [ test ] fn bindgen_test_layout_EnvironmentObjectDetections__bindgen_ty_1 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < EnvironmentObjectDetections__bindgen_ty_1 > ( ) , 24usize , concat ! ( "Size of: " , stringify ! ( EnvironmentObjectDetections__bindgen_ty_1 ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < EnvironmentObjectDetections__bindgen_ty_1 > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( EnvironmentObjectDetections__bindgen_ty_1 ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < EnvironmentObjectDetections__bindgen_ty_1 > ( ) ) ) . array as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( EnvironmentObjectDetections__bindgen_ty_1 ) , "::" , stringify ! ( array ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < EnvironmentObjectDetections__bindgen_ty_1 > ( ) ) ) . count as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( EnvironmentObjectDetections__bindgen_ty_1 ) , "::" , stringify ! ( count ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < EnvironmentObjectDetections__bindgen_ty_1 > ( ) ) ) . size as * const _ as usize } , 12usize , concat ! ( "Offset of field: " , stringify ! ( EnvironmentObjectDetections__bindgen_ty_1 ) , "::" , stringify ! ( size ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < EnvironmentObjectDetections__bindgen_ty_1 > ( ) ) ) . free as * const _ as usize } , 16usize , concat ! ( "Offset of field: " , stringify ! ( EnvironmentObjectDetections__bindgen_ty_1 ) , "::" , stringify ! ( free ) ) ) ; } # [ test ] fn bindgen_test_layout_EnvironmentObjectDetections ( ) { assert_eq ! ( :: std :: mem :: size_of :: < EnvironmentObjectDetections > ( ) , 48usize , concat ! ( "Size of: " , stringify ! ( EnvironmentObjectDetections ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < EnvironmentObjectDetections > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( EnvironmentObjectDetections ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < EnvironmentObjectDetections > ( ) ) ) . list as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( EnvironmentObjectDetections ) , "::" , stringify ! ( list ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < EnvironmentObjectDetections > ( ) ) ) . _asn_ctx as * const _ as usize } , 24usize , concat ! ( "Offset of field: " , stringify ! ( EnvironmentObjectDetections ) , "::" , stringify ! ( _asn_ctx ) ) ) ; } pub type EnvironmentObjectDetections_t = EnvironmentObjectDetections ; extern "C" { # [ link_name = "\u{1}asn_DEF_EnvironmentObjectDetections" ] pub static mut asn_DEF_EnvironmentObjectDetections : asn_TYPE_descriptor_t ; } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct EnvironmentFrame { pub header : Header_t , pub envelope : EnvironmentEnvelope_t , pub object_detections : EnvironmentObjectDetections_t , pub _asn_ctx : asn_struct_ctx_t , } # [ test ] fn bindgen_test_layout_EnvironmentFrame ( ) { assert_eq ! ( :: std :: mem :: size_of :: < EnvironmentFrame > ( ) , 240usize , concat ! ( "Size of: " , stringify ! ( EnvironmentFrame ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < EnvironmentFrame > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( EnvironmentFrame ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < EnvironmentFrame > ( ) ) ) . header as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( EnvironmentFrame ) , "::" , stringify ! ( header ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < EnvironmentFrame > ( ) ) ) . envelope as * const _ as usize } , 32usize , concat ! ( "Offset of field: " , stringify ! ( EnvironmentFrame ) , "::" , stringify ! ( envelope ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < EnvironmentFrame > ( ) ) ) . object_detections as * const _ as usize } , 168usize , concat ! ( "Offset of field: " , stringify ! ( EnvironmentFrame ) , "::" , stringify ! ( object_detections ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < EnvironmentFrame > ( ) ) ) . _asn_ctx as * const _ as usize } , 216usize , concat ! ( "Offset of field: " , stringify ! ( EnvironmentFrame ) , "::" , stringify ! ( _asn_ctx ) ) ) ; } pub type EnvironmentFrame_t = EnvironmentFrame ; extern "C" { # [ link_name = "\u{1}asn_DEF_EnvironmentFrame" ] pub static mut asn_DEF_EnvironmentFrame : asn_TYPE_descriptor_t ; } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct Area { pub list : Area__bindgen_ty_1 , pub _asn_ctx : asn_struct_ctx_t , } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct Area__bindgen_ty_1 { pub array : * mut * mut ReferencePoint , pub count : :: std :: os :: raw :: c_int , pub size : :: std :: os :: raw :: c_int , pub free : :: std :: option :: Option < unsafe extern "C" fn ( arg1 : * mut ReferencePoint ) > , } # [ test ] fn bindgen_test_layout_Area__bindgen_ty_1 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < Area__bindgen_ty_1 > ( ) , 24usize , concat ! ( "Size of: " , stringify ! ( Area__bindgen_ty_1 ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < Area__bindgen_ty_1 > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( Area__bindgen_ty_1 ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < Area__bindgen_ty_1 > ( ) ) ) . array as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( Area__bindgen_ty_1 ) , "::" , stringify ! ( array ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < Area__bindgen_ty_1 > ( ) ) ) . count as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( Area__bindgen_ty_1 ) , "::" , stringify ! ( count ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < Area__bindgen_ty_1 > ( ) ) ) . size as * const _ as usize } , 12usize , concat ! ( "Offset of field: " , stringify ! ( Area__bindgen_ty_1 ) , "::" , stringify ! ( size ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < Area__bindgen_ty_1 > ( ) ) ) . free as * const _ as usize } , 16usize , concat ! ( "Offset of field: " , stringify ! ( Area__bindgen_ty_1 ) , "::" , stringify ! ( free ) ) ) ; } # [ test ] fn bindgen_test_layout_Area ( ) { assert_eq ! ( :: std :: mem :: size_of :: < Area > ( ) , 48usize , concat ! ( "Size of: " , stringify ! ( Area ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < Area > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( Area ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < Area > ( ) ) ) . list as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( Area ) , "::" , stringify ! ( list ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < Area > ( ) ) ) . _asn_ctx as * const _ as usize } , 24usize , concat ! ( "Offset of field: " , stringify ! ( Area ) , "::" , stringify ! ( _asn_ctx ) ) ) ; } pub type Area_t = Area ; extern "C" { # [ link_name = "\u{1}asn_DEF_Area" ] pub static mut asn_DEF_Area : asn_TYPE_descriptor_t ; } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct Sector { pub id : :: std :: os :: raw :: c_long , pub area : Area_t , pub _asn_ctx : asn_struct_ctx_t , } # [ test ] fn bindgen_test_layout_Sector ( ) { assert_eq ! ( :: std :: mem :: size_of :: < Sector > ( ) , 80usize , concat ! ( "Size of: " , stringify ! ( Sector ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < Sector > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( Sector ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < Sector > ( ) ) ) . id as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( Sector ) , "::" , stringify ! ( id ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < Sector > ( ) ) ) . area as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( Sector ) , "::" , stringify ! ( area ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < Sector > ( ) ) ) . _asn_ctx as * const _ as usize } , 56usize , concat ! ( "Offset of field: " , stringify ! ( Sector ) , "::" , stringify ! ( _asn_ctx ) ) ) ; } pub type Sector_t = Sector ; extern "C" { # [ link_name = "\u{1}asn_DEF_Sector" ] pub static mut asn_DEF_Sector : asn_TYPE_descriptor_t ; } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct Sectors { pub list : Sectors__bindgen_ty_1 , pub _asn_ctx : asn_struct_ctx_t , } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct Sectors__bindgen_ty_1 { pub array : * mut * mut Sector , pub count : :: std :: os :: raw :: c_int , pub size : :: std :: os :: raw :: c_int , pub free : :: std :: option :: Option < unsafe extern "C" fn ( arg1 : * mut Sector ) > , } # [ test ] fn bindgen_test_layout_Sectors__bindgen_ty_1 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < Sectors__bindgen_ty_1 > ( ) , 24usize , concat ! ( "Size of: " , stringify ! ( Sectors__bindgen_ty_1 ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < Sectors__bindgen_ty_1 > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( Sectors__bindgen_ty_1 ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < Sectors__bindgen_ty_1 > ( ) ) ) . array as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( Sectors__bindgen_ty_1 ) , "::" , stringify ! ( array ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < Sectors__bindgen_ty_1 > ( ) ) ) . count as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( Sectors__bindgen_ty_1 ) , "::" , stringify ! ( count ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < Sectors__bindgen_ty_1 > ( ) ) ) . size as * const _ as usize } , 12usize , concat ! ( "Offset of field: " , stringify ! ( Sectors__bindgen_ty_1 ) , "::" , stringify ! ( size ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < Sectors__bindgen_ty_1 > ( ) ) ) . free as * const _ as usize } , 16usize , concat ! ( "Offset of field: " , stringify ! ( Sectors__bindgen_ty_1 ) , "::" , stringify ! ( free ) ) ) ; } # [ test ] fn bindgen_test_layout_Sectors ( ) { assert_eq ! ( :: std :: mem :: size_of :: < Sectors > ( ) , 48usize , concat ! ( "Size of: " , stringify ! ( Sectors ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < Sectors > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( Sectors ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < Sectors > ( ) ) ) . list as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( Sectors ) , "::" , stringify ! ( list ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < Sectors > ( ) ) ) . _asn_ctx as * const _ as usize } , 24usize , concat ! ( "Offset of field: " , stringify ! ( Sectors ) , "::" , stringify ! ( _asn_ctx ) ) ) ; } pub type Sectors_t = Sectors ; extern "C" { # [ link_name = "\u{1}asn_DEF_Sectors" ] pub static mut asn_DEF_Sectors : asn_TYPE_descriptor_t ; } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct InitMessage { pub header : Header_t , pub envelope : EnvironmentEnvelope_t , pub sectors : Sectors_t , pub _asn_ctx : asn_struct_ctx_t , } # [ test ] fn bindgen_test_layout_InitMessage ( ) { assert_eq ! ( :: std :: mem :: size_of :: < InitMessage > ( ) , 240usize , concat ! ( "Size of: " , stringify ! ( InitMessage ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < InitMessage > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( InitMessage ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < InitMessage > ( ) ) ) . header as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( InitMessage ) , "::" , stringify ! ( header ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < InitMessage > ( ) ) ) . envelope as * const _ as usize } , 32usize , concat ! ( "Offset of field: " , stringify ! ( InitMessage ) , "::" , stringify ! ( envelope ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < InitMessage > ( ) ) ) . sectors as * const _ as usize } , 168usize , concat ! ( "Offset of field: " , stringify ! ( InitMessage ) , "::" , stringify ! ( sectors ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < InitMessage > ( ) ) ) . _asn_ctx as * const _ as usize } , 216usize , concat ! ( "Offset of field: " , stringify ! ( InitMessage ) , "::" , stringify ! ( _asn_ctx ) ) ) ; } pub type InitMessage_t = InitMessage ; extern "C" { # [ link_name = "\u{1}asn_DEF_InitMessage" ] pub static mut asn_DEF_InitMessage : asn_TYPE_descriptor_t ; } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct RoadClearanceEnvelope { pub version : :: std :: os :: raw :: c_long , pub server_id : :: std :: os :: raw :: c_long , pub reference_point : ReferencePoint_t , pub _asn_ctx : asn_struct_ctx_t , } # [ test ] fn bindgen_test_layout_RoadClearanceEnvelope ( ) { assert_eq ! ( :: std :: mem :: size_of :: < RoadClearanceEnvelope > ( ) , 88usize , concat ! ( "Size of: " , stringify ! ( RoadClearanceEnvelope ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < RoadClearanceEnvelope > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( RoadClearanceEnvelope ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < RoadClearanceEnvelope > ( ) ) ) . version as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( RoadClearanceEnvelope ) , "::" , stringify ! ( version ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < RoadClearanceEnvelope > ( ) ) ) . server_id as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( RoadClearanceEnvelope ) , "::" , stringify ! ( server_id ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < RoadClearanceEnvelope > ( ) ) ) . reference_point as * const _ as usize } , 16usize , concat ! ( "Offset of field: " , stringify ! ( RoadClearanceEnvelope ) , "::" , stringify ! ( reference_point ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < RoadClearanceEnvelope > ( ) ) ) . _asn_ctx as * const _ as usize } , 64usize , concat ! ( "Offset of field: " , stringify ! ( RoadClearanceEnvelope ) , "::" , stringify ! ( _asn_ctx ) ) ) ; } pub type RoadClearanceEnvelope_t = RoadClearanceEnvelope ; extern "C" { # [ link_name = "\u{1}asn_DEF_RoadClearanceEnvelope" ] pub static mut asn_DEF_RoadClearanceEnvelope : asn_TYPE_descriptor_t ; } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct OCTET_STRING { pub buf : * mut u8 , pub size : :: std :: os :: raw :: c_int , pub _asn_ctx : asn_struct_ctx_t , } # [ test ] fn bindgen_test_layout_OCTET_STRING ( ) { assert_eq ! ( :: std :: mem :: size_of :: < OCTET_STRING > ( ) , 40usize , concat ! ( "Size of: " , stringify ! ( OCTET_STRING ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < OCTET_STRING > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( OCTET_STRING ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < OCTET_STRING > ( ) ) ) . buf as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( OCTET_STRING ) , "::" , stringify ! ( buf ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < OCTET_STRING > ( ) ) ) . size as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( OCTET_STRING ) , "::" , stringify ! ( size ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < OCTET_STRING > ( ) ) ) . _asn_ctx as * const _ as usize } , 16usize , concat ! ( "Offset of field: " , stringify ! ( OCTET_STRING ) , "::" , stringify ! ( _asn_ctx ) ) ) ; } pub type OCTET_STRING_t = OCTET_STRING ; extern "C" { # [ link_name = "\u{1}asn_DEF_OCTET_STRING" ] pub static mut asn_DEF_OCTET_STRING : asn_TYPE_descriptor_t ; } extern "C" { pub fn OCTET_STRING_free ( type_descriptor : * mut asn_TYPE_descriptor_s , struct_ptr : * mut :: std :: os :: raw :: c_void , free_contents_only : :: std :: os :: raw :: c_int ) ; } extern "C" { pub fn OCTET_STRING_print ( type_descriptor : * mut asn_TYPE_descriptor_s , struct_ptr : * const :: std :: os :: raw :: c_void , level : :: std :: os :: raw :: c_int , callback : asn_app_consume_bytes_f , app_key : * mut :: std :: os :: raw :: c_void ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn OCTET_STRING_print_utf8 ( type_descriptor : * mut asn_TYPE_descriptor_s , struct_ptr : * const :: std :: os :: raw :: c_void , level : :: std :: os :: raw :: c_int , callback : asn_app_consume_bytes_f , app_key : * mut :: std :: os :: raw :: c_void ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn OCTET_STRING_decode_ber ( opt_codec_ctx : * mut asn_codec_ctx_s , type_descriptor : * mut asn_TYPE_descriptor_s , struct_ptr : * mut * mut :: std :: os :: raw :: c_void , buf_ptr : * const :: std :: os :: raw :: c_void , size : usize , tag_mode : :: std :: os :: raw :: c_int ) -> asn_dec_rval_t ; } extern "C" { pub fn OCTET_STRING_encode_der ( type_descriptor : * mut asn_TYPE_descriptor_s , struct_ptr : * mut :: std :: os :: raw :: c_void , tag_mode : :: std :: os :: raw :: c_int , tag : ber_tlv_tag_t , consume_bytes_cb : asn_app_consume_bytes_f , app_key : * mut :: std :: os :: raw :: c_void ) -> asn_enc_rval_t ; } extern "C" { pub fn OCTET_STRING_decode_xer_hex ( opt_codec_ctx : * mut asn_codec_ctx_t , type_descriptor : * mut asn_TYPE_descriptor_s , struct_ptr : * mut * mut :: std :: os :: raw :: c_void , opt_mname : * const :: std :: os :: raw :: c_char , buf_ptr : * const :: std :: os :: raw :: c_void , size : usize ) -> asn_dec_rval_t ; } extern "C" { pub fn OCTET_STRING_decode_xer_binary ( opt_codec_ctx : * mut asn_codec_ctx_t , type_descriptor : * mut asn_TYPE_descriptor_s , struct_ptr : * mut * mut :: std :: os :: raw :: c_void , opt_mname : * const :: std :: os :: raw :: c_char , buf_ptr : * const :: std :: os :: raw :: c_void , size : usize ) -> asn_dec_rval_t ; } extern "C" { pub fn OCTET_STRING_decode_xer_utf8 ( opt_codec_ctx : * mut asn_codec_ctx_t , type_descriptor : * mut asn_TYPE_descriptor_s , struct_ptr : * mut * mut :: std :: os :: raw :: c_void , opt_mname : * const :: std :: os :: raw :: c_char , buf_ptr : * const :: std :: os :: raw :: c_void , size : usize ) -> asn_dec_rval_t ; } extern "C" { pub fn OCTET_STRING_encode_xer ( type_descriptor : * mut asn_TYPE_descriptor_s , struct_ptr : * mut :: std :: os :: raw :: c_void , ilevel : :: std :: os :: raw :: c_int , xer_flags : xer_encoder_flags_e , consume_bytes_cb : asn_app_consume_bytes_f , app_key : * mut :: std :: os :: raw :: c_void ) -> asn_enc_rval_t ; } extern "C" { pub fn OCTET_STRING_encode_xer_utf8 ( type_descriptor : * mut asn_TYPE_descriptor_s , struct_ptr : * mut :: std :: os :: raw :: c_void , ilevel : :: std :: os :: raw :: c_int , xer_flags : xer_encoder_flags_e , consume_bytes_cb : asn_app_consume_bytes_f , app_key : * mut :: std :: os :: raw :: c_void ) -> asn_enc_rval_t ; } extern "C" { pub fn OCTET_STRING_decode_uper ( opt_codec_ctx : * mut asn_codec_ctx_t , type_descriptor : * mut asn_TYPE_descriptor_s , constraints : * mut asn_per_constraints_t , struct_ptr : * mut * mut :: std :: os :: raw :: c_void , per_data : * mut asn_per_data_t ) -> asn_dec_rval_t ; } extern "C" { pub fn OCTET_STRING_encode_uper ( type_descriptor : * mut asn_TYPE_descriptor_s , constraints : * mut asn_per_constraints_t , struct_ptr : * mut :: std :: os :: raw :: c_void , per_output : * mut asn_per_outp_t ) -> asn_enc_rval_t ; } extern "C" { 
 /// Handy conversion routines. * 
 pub fn OCTET_STRING_fromBuf ( s : * mut OCTET_STRING_t , str : * const :: std :: os :: raw :: c_char , size : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn OCTET_STRING_new_fromBuf ( td : * mut asn_TYPE_descriptor_t , str : * const :: std :: os :: raw :: c_char , size : :: std :: os :: raw :: c_int ) -> * mut OCTET_STRING_t ; } 
 /// Internally useful stuff. * 
 # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct asn_OCTET_STRING_specifics_s { pub struct_size : :: std :: os :: raw :: c_int , pub ctx_offset : :: std :: os :: raw :: c_int , pub subvariant : asn_OCTET_STRING_specifics_s_asn_OS_Subvariant , } pub const asn_OCTET_STRING_specifics_s_asn_OS_Subvariant_ASN_OSUBV_ANY : asn_OCTET_STRING_specifics_s_asn_OS_Subvariant = 0 ; pub const asn_OCTET_STRING_specifics_s_asn_OS_Subvariant_ASN_OSUBV_BIT : asn_OCTET_STRING_specifics_s_asn_OS_Subvariant = 1 ; pub const asn_OCTET_STRING_specifics_s_asn_OS_Subvariant_ASN_OSUBV_STR : asn_OCTET_STRING_specifics_s_asn_OS_Subvariant = 2 ; pub const asn_OCTET_STRING_specifics_s_asn_OS_Subvariant_ASN_OSUBV_U16 : asn_OCTET_STRING_specifics_s_asn_OS_Subvariant = 3 ; pub const asn_OCTET_STRING_specifics_s_asn_OS_Subvariant_ASN_OSUBV_U32 : asn_OCTET_STRING_specifics_s_asn_OS_Subvariant = 4 ; pub type asn_OCTET_STRING_specifics_s_asn_OS_Subvariant = u32 ; # [ test ] fn bindgen_test_layout_asn_OCTET_STRING_specifics_s ( ) { assert_eq ! ( :: std :: mem :: size_of :: < asn_OCTET_STRING_specifics_s > ( ) , 12usize , concat ! ( "Size of: " , stringify ! ( asn_OCTET_STRING_specifics_s ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < asn_OCTET_STRING_specifics_s > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( asn_OCTET_STRING_specifics_s ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < asn_OCTET_STRING_specifics_s > ( ) ) ) . struct_size as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( asn_OCTET_STRING_specifics_s ) , "::" , stringify ! ( struct_size ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < asn_OCTET_STRING_specifics_s > ( ) ) ) . ctx_offset as * const _ as usize } , 4usize , concat ! ( "Offset of field: " , stringify ! ( asn_OCTET_STRING_specifics_s ) , "::" , stringify ! ( ctx_offset ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < asn_OCTET_STRING_specifics_s > ( ) ) ) . subvariant as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( asn_OCTET_STRING_specifics_s ) , "::" , stringify ! ( subvariant ) ) ) ; } pub type asn_OCTET_STRING_specifics_t = asn_OCTET_STRING_specifics_s ; pub type UTF8String_t = OCTET_STRING_t ; extern "C" { # [ link_name = "\u{1}asn_DEF_UTF8String" ] pub static mut asn_DEF_UTF8String : asn_TYPE_descriptor_t ; } extern "C" { pub fn UTF8String_print ( type_descriptor : * mut asn_TYPE_descriptor_s , struct_ptr : * const :: std :: os :: raw :: c_void , level : :: std :: os :: raw :: c_int , callback : asn_app_consume_bytes_f , app_key : * mut :: std :: os :: raw :: c_void ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn UTF8String_constraint ( type_descriptor : * mut asn_TYPE_descriptor_s , struct_ptr : * const :: std :: os :: raw :: c_void , optional_callback : asn_app_constraint_failed_f , optional_app_key : * mut :: std :: os :: raw :: c_void ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn UTF8String_length ( st : * const UTF8String_t ) -> isize ; } extern "C" { pub fn UTF8String_to_wcs ( st : * const UTF8String_t , dst : * mut u32 , dstlen : usize ) -> usize ; } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct Parameter { pub id : :: std :: os :: raw :: c_long , pub name : UTF8String_t , pub value : :: std :: os :: raw :: c_long , pub position : * mut ReferencePoint , pub _asn_ctx : asn_struct_ctx_t , } # [ test ] fn bindgen_test_layout_Parameter ( ) { assert_eq ! ( :: std :: mem :: size_of :: < Parameter > ( ) , 88usize , concat ! ( "Size of: " , stringify ! ( Parameter ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < Parameter > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( Parameter ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < Parameter > ( ) ) ) . id as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( Parameter ) , "::" , stringify ! ( id ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < Parameter > ( ) ) ) . name as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( Parameter ) , "::" , stringify ! ( name ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < Parameter > ( ) ) ) . value as * const _ as usize } , 48usize , concat ! ( "Offset of field: " , stringify ! ( Parameter ) , "::" , stringify ! ( value ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < Parameter > ( ) ) ) . position as * const _ as usize } , 56usize , concat ! ( "Offset of field: " , stringify ! ( Parameter ) , "::" , stringify ! ( position ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < Parameter > ( ) ) ) . _asn_ctx as * const _ as usize } , 64usize , concat ! ( "Offset of field: " , stringify ! ( Parameter ) , "::" , stringify ! ( _asn_ctx ) ) ) ; } pub type Parameter_t = Parameter ; extern "C" { # [ link_name = "\u{1}asn_DEF_Parameter" ] pub static mut asn_DEF_Parameter : asn_TYPE_descriptor_t ; } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct Parameters { pub list : Parameters__bindgen_ty_1 , pub _asn_ctx : asn_struct_ctx_t , } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct Parameters__bindgen_ty_1 { pub array : * mut * mut Parameter , pub count : :: std :: os :: raw :: c_int , pub size : :: std :: os :: raw :: c_int , pub free : :: std :: option :: Option < unsafe extern "C" fn ( arg1 : * mut Parameter ) > , } # [ test ] fn bindgen_test_layout_Parameters__bindgen_ty_1 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < Parameters__bindgen_ty_1 > ( ) , 24usize , concat ! ( "Size of: " , stringify ! ( Parameters__bindgen_ty_1 ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < Parameters__bindgen_ty_1 > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( Parameters__bindgen_ty_1 ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < Parameters__bindgen_ty_1 > ( ) ) ) . array as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( Parameters__bindgen_ty_1 ) , "::" , stringify ! ( array ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < Parameters__bindgen_ty_1 > ( ) ) ) . count as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( Parameters__bindgen_ty_1 ) , "::" , stringify ! ( count ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < Parameters__bindgen_ty_1 > ( ) ) ) . size as * const _ as usize } , 12usize , concat ! ( "Offset of field: " , stringify ! ( Parameters__bindgen_ty_1 ) , "::" , stringify ! ( size ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < Parameters__bindgen_ty_1 > ( ) ) ) . free as * const _ as usize } , 16usize , concat ! ( "Offset of field: " , stringify ! ( Parameters__bindgen_ty_1 ) , "::" , stringify ! ( free ) ) ) ; } # [ test ] fn bindgen_test_layout_Parameters ( ) { assert_eq ! ( :: std :: mem :: size_of :: < Parameters > ( ) , 48usize , concat ! ( "Size of: " , stringify ! ( Parameters ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < Parameters > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( Parameters ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < Parameters > ( ) ) ) . list as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( Parameters ) , "::" , stringify ! ( list ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < Parameters > ( ) ) ) . _asn_ctx as * const _ as usize } , 24usize , concat ! ( "Offset of field: " , stringify ! ( Parameters ) , "::" , stringify ! ( _asn_ctx ) ) ) ; } pub type Parameters_t = Parameters ; extern "C" { # [ link_name = "\u{1}asn_DEF_Parameters" ] pub static mut asn_DEF_Parameters : asn_TYPE_descriptor_t ; } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct RoadSection { pub geo_fence_id : :: std :: os :: raw :: c_long , pub parameters : Parameters_t , pub _asn_ctx : asn_struct_ctx_t , } # [ test ] fn bindgen_test_layout_RoadSection ( ) { assert_eq ! ( :: std :: mem :: size_of :: < RoadSection > ( ) , 80usize , concat ! ( "Size of: " , stringify ! ( RoadSection ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < RoadSection > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( RoadSection ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < RoadSection > ( ) ) ) . geo_fence_id as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( RoadSection ) , "::" , stringify ! ( geo_fence_id ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < RoadSection > ( ) ) ) . parameters as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( RoadSection ) , "::" , stringify ! ( parameters ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < RoadSection > ( ) ) ) . _asn_ctx as * const _ as usize } , 56usize , concat ! ( "Offset of field: " , stringify ! ( RoadSection ) , "::" , stringify ! ( _asn_ctx ) ) ) ; } pub type RoadSection_t = RoadSection ; extern "C" { # [ link_name = "\u{1}asn_DEF_RoadSection" ] pub static mut asn_DEF_RoadSection : asn_TYPE_descriptor_t ; } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct RoadSections { pub list : RoadSections__bindgen_ty_1 , pub _asn_ctx : asn_struct_ctx_t , } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct RoadSections__bindgen_ty_1 { pub array : * mut * mut RoadSection , pub count : :: std :: os :: raw :: c_int , pub size : :: std :: os :: raw :: c_int , pub free : :: std :: option :: Option < unsafe extern "C" fn ( arg1 : * mut RoadSection ) > , } # [ test ] fn bindgen_test_layout_RoadSections__bindgen_ty_1 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < RoadSections__bindgen_ty_1 > ( ) , 24usize , concat ! ( "Size of: " , stringify ! ( RoadSections__bindgen_ty_1 ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < RoadSections__bindgen_ty_1 > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( RoadSections__bindgen_ty_1 ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < RoadSections__bindgen_ty_1 > ( ) ) ) . array as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( RoadSections__bindgen_ty_1 ) , "::" , stringify ! ( array ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < RoadSections__bindgen_ty_1 > ( ) ) ) . count as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( RoadSections__bindgen_ty_1 ) , "::" , stringify ! ( count ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < RoadSections__bindgen_ty_1 > ( ) ) ) . size as * const _ as usize } , 12usize , concat ! ( "Offset of field: " , stringify ! ( RoadSections__bindgen_ty_1 ) , "::" , stringify ! ( size ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < RoadSections__bindgen_ty_1 > ( ) ) ) . free as * const _ as usize } , 16usize , concat ! ( "Offset of field: " , stringify ! ( RoadSections__bindgen_ty_1 ) , "::" , stringify ! ( free ) ) ) ; } # [ test ] fn bindgen_test_layout_RoadSections ( ) { assert_eq ! ( :: std :: mem :: size_of :: < RoadSections > ( ) , 48usize , concat ! ( "Size of: " , stringify ! ( RoadSections ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < RoadSections > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( RoadSections ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < RoadSections > ( ) ) ) . list as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( RoadSections ) , "::" , stringify ! ( list ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < RoadSections > ( ) ) ) . _asn_ctx as * const _ as usize } , 24usize , concat ! ( "Offset of field: " , stringify ! ( RoadSections ) , "::" , stringify ! ( _asn_ctx ) ) ) ; } pub type RoadSections_t = RoadSections ; extern "C" { # [ link_name = "\u{1}asn_DEF_RoadSections" ] pub static mut asn_DEF_RoadSections : asn_TYPE_descriptor_t ; } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct RoadClearanceFrame { pub header : Header_t , pub envelope : RoadClearanceEnvelope_t , pub road_sections : RoadSections_t , pub _asn_ctx : asn_struct_ctx_t , } # [ test ] fn bindgen_test_layout_RoadClearanceFrame ( ) { assert_eq ! ( :: std :: mem :: size_of :: < RoadClearanceFrame > ( ) , 192usize , concat ! ( "Size of: " , stringify ! ( RoadClearanceFrame ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < RoadClearanceFrame > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( RoadClearanceFrame ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < RoadClearanceFrame > ( ) ) ) . header as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( RoadClearanceFrame ) , "::" , stringify ! ( header ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < RoadClearanceFrame > ( ) ) ) . envelope as * const _ as usize } , 32usize , concat ! ( "Offset of field: " , stringify ! ( RoadClearanceFrame ) , "::" , stringify ! ( envelope ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < RoadClearanceFrame > ( ) ) ) . road_sections as * const _ as usize } , 120usize , concat ! ( "Offset of field: " , stringify ! ( RoadClearanceFrame ) , "::" , stringify ! ( road_sections ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < RoadClearanceFrame > ( ) ) ) . _asn_ctx as * const _ as usize } , 168usize , concat ! ( "Offset of field: " , stringify ! ( RoadClearanceFrame ) , "::" , stringify ! ( _asn_ctx ) ) ) ; } pub type RoadClearanceFrame_t = RoadClearanceFrame ; extern "C" { # [ link_name = "\u{1}asn_DEF_RoadClearanceFrame" ] pub static mut asn_DEF_RoadClearanceFrame : asn_TYPE_descriptor_t ; } pub const ClientType_ClientType_sensor : ClientType = 0 ; pub const ClientType_ClientType_vehicle : ClientType = 1 ; pub type ClientType = u32 ; pub use self :: ClientType as e_ClientType ; pub type ClientType_t = :: std :: os :: raw :: c_long ; extern "C" { # [ link_name = "\u{1}asn_DEF_ClientType" ] pub static mut asn_DEF_ClientType : asn_TYPE_descriptor_t ; } extern "C" { pub fn ClientType_free ( type_descriptor : * mut asn_TYPE_descriptor_s , struct_ptr : * mut :: std :: os :: raw :: c_void , free_contents_only : :: std :: os :: raw :: c_int ) ; } extern "C" { pub fn ClientType_print ( type_descriptor : * mut asn_TYPE_descriptor_s , struct_ptr : * const :: std :: os :: raw :: c_void , level : :: std :: os :: raw :: c_int , callback : asn_app_consume_bytes_f , app_key : * mut :: std :: os :: raw :: c_void ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn ClientType_constraint ( type_descriptor : * mut asn_TYPE_descriptor_s , struct_ptr : * const :: std :: os :: raw :: c_void , optional_callback : asn_app_constraint_failed_f , optional_app_key : * mut :: std :: os :: raw :: c_void ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn ClientType_decode_ber ( opt_codec_ctx : * mut asn_codec_ctx_s , type_descriptor : * mut asn_TYPE_descriptor_s , struct_ptr : * mut * mut :: std :: os :: raw :: c_void , buf_ptr : * const :: std :: os :: raw :: c_void , size : usize , tag_mode : :: std :: os :: raw :: c_int ) -> asn_dec_rval_t ; } extern "C" { pub fn ClientType_encode_der ( type_descriptor : * mut asn_TYPE_descriptor_s , struct_ptr : * mut :: std :: os :: raw :: c_void , tag_mode : :: std :: os :: raw :: c_int , tag : ber_tlv_tag_t , consume_bytes_cb : asn_app_consume_bytes_f , app_key : * mut :: std :: os :: raw :: c_void ) -> asn_enc_rval_t ; } extern "C" { pub fn ClientType_decode_xer ( opt_codec_ctx : * mut asn_codec_ctx_t , type_descriptor : * mut asn_TYPE_descriptor_s , struct_ptr : * mut * mut :: std :: os :: raw :: c_void , opt_mname : * const :: std :: os :: raw :: c_char , buf_ptr : * const :: std :: os :: raw :: c_void , size : usize ) -> asn_dec_rval_t ; } extern "C" { pub fn ClientType_encode_xer ( type_descriptor : * mut asn_TYPE_descriptor_s , struct_ptr : * mut :: std :: os :: raw :: c_void , ilevel : :: std :: os :: raw :: c_int , xer_flags : xer_encoder_flags_e , consume_bytes_cb : asn_app_consume_bytes_f , app_key : * mut :: std :: os :: raw :: c_void ) -> asn_enc_rval_t ; } extern "C" { pub fn ClientType_decode_uper ( opt_codec_ctx : * mut asn_codec_ctx_t , type_descriptor : * mut asn_TYPE_descriptor_s , constraints : * mut asn_per_constraints_t , struct_ptr : * mut * mut :: std :: os :: raw :: c_void , per_data : * mut asn_per_data_t ) -> asn_dec_rval_t ; } extern "C" { pub fn ClientType_encode_uper ( type_descriptor : * mut asn_TYPE_descriptor_s , constraints : * mut asn_per_constraints_t , struct_ptr : * mut :: std :: os :: raw :: c_void , per_output : * mut asn_per_outp_t ) -> asn_enc_rval_t ; } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct CoveredArea { pub list : CoveredArea__bindgen_ty_1 , pub _asn_ctx : asn_struct_ctx_t , } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct CoveredArea__bindgen_ty_1 { pub array : * mut * mut ReferencePoint , pub count : :: std :: os :: raw :: c_int , pub size : :: std :: os :: raw :: c_int , pub free : :: std :: option :: Option < unsafe extern "C" fn ( arg1 : * mut ReferencePoint ) > , } # [ test ] fn bindgen_test_layout_CoveredArea__bindgen_ty_1 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < CoveredArea__bindgen_ty_1 > ( ) , 24usize , concat ! ( "Size of: " , stringify ! ( CoveredArea__bindgen_ty_1 ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < CoveredArea__bindgen_ty_1 > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( CoveredArea__bindgen_ty_1 ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < CoveredArea__bindgen_ty_1 > ( ) ) ) . array as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( CoveredArea__bindgen_ty_1 ) , "::" , stringify ! ( array ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < CoveredArea__bindgen_ty_1 > ( ) ) ) . count as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( CoveredArea__bindgen_ty_1 ) , "::" , stringify ! ( count ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < CoveredArea__bindgen_ty_1 > ( ) ) ) . size as * const _ as usize } , 12usize , concat ! ( "Offset of field: " , stringify ! ( CoveredArea__bindgen_ty_1 ) , "::" , stringify ! ( size ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < CoveredArea__bindgen_ty_1 > ( ) ) ) . free as * const _ as usize } , 16usize , concat ! ( "Offset of field: " , stringify ! ( CoveredArea__bindgen_ty_1 ) , "::" , stringify ! ( free ) ) ) ; } # [ test ] fn bindgen_test_layout_CoveredArea ( ) { assert_eq ! ( :: std :: mem :: size_of :: < CoveredArea > ( ) , 48usize , concat ! ( "Size of: " , stringify ! ( CoveredArea ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < CoveredArea > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( CoveredArea ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < CoveredArea > ( ) ) ) . list as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( CoveredArea ) , "::" , stringify ! ( list ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < CoveredArea > ( ) ) ) . _asn_ctx as * const _ as usize } , 24usize , concat ! ( "Offset of field: " , stringify ! ( CoveredArea ) , "::" , stringify ! ( _asn_ctx ) ) ) ; } pub type CoveredArea_t = CoveredArea ; extern "C" { # [ link_name = "\u{1}asn_DEF_CoveredArea" ] pub static mut asn_DEF_CoveredArea : asn_TYPE_descriptor_t ; } pub const SubscriptionStatus_SubscriptionStatus_unsubscribed : SubscriptionStatus = 0 ; pub const SubscriptionStatus_SubscriptionStatus_subscribed : SubscriptionStatus = 1 ; pub type SubscriptionStatus = u32 ; pub use self :: SubscriptionStatus as e_SubscriptionStatus ; pub type SubscriptionStatus_t = :: std :: os :: raw :: c_long ; extern "C" { # [ link_name = "\u{1}asn_DEF_SubscriptionStatus" ] pub static mut asn_DEF_SubscriptionStatus : asn_TYPE_descriptor_t ; } extern "C" { pub fn SubscriptionStatus_free ( type_descriptor : * mut asn_TYPE_descriptor_s , struct_ptr : * mut :: std :: os :: raw :: c_void , free_contents_only : :: std :: os :: raw :: c_int ) ; } extern "C" { pub fn SubscriptionStatus_print ( type_descriptor : * mut asn_TYPE_descriptor_s , struct_ptr : * const :: std :: os :: raw :: c_void , level : :: std :: os :: raw :: c_int , callback : asn_app_consume_bytes_f , app_key : * mut :: std :: os :: raw :: c_void ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn SubscriptionStatus_constraint ( type_descriptor : * mut asn_TYPE_descriptor_s , struct_ptr : * const :: std :: os :: raw :: c_void , optional_callback : asn_app_constraint_failed_f , optional_app_key : * mut :: std :: os :: raw :: c_void ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn SubscriptionStatus_decode_ber ( opt_codec_ctx : * mut asn_codec_ctx_s , type_descriptor : * mut asn_TYPE_descriptor_s , struct_ptr : * mut * mut :: std :: os :: raw :: c_void , buf_ptr : * const :: std :: os :: raw :: c_void , size : usize , tag_mode : :: std :: os :: raw :: c_int ) -> asn_dec_rval_t ; } extern "C" { pub fn SubscriptionStatus_encode_der ( type_descriptor : * mut asn_TYPE_descriptor_s , struct_ptr : * mut :: std :: os :: raw :: c_void , tag_mode : :: std :: os :: raw :: c_int , tag : ber_tlv_tag_t , consume_bytes_cb : asn_app_consume_bytes_f , app_key : * mut :: std :: os :: raw :: c_void ) -> asn_enc_rval_t ; } extern "C" { pub fn SubscriptionStatus_decode_xer ( opt_codec_ctx : * mut asn_codec_ctx_t , type_descriptor : * mut asn_TYPE_descriptor_s , struct_ptr : * mut * mut :: std :: os :: raw :: c_void , opt_mname : * const :: std :: os :: raw :: c_char , buf_ptr : * const :: std :: os :: raw :: c_void , size : usize ) -> asn_dec_rval_t ; } extern "C" { pub fn SubscriptionStatus_encode_xer ( type_descriptor : * mut asn_TYPE_descriptor_s , struct_ptr : * mut :: std :: os :: raw :: c_void , ilevel : :: std :: os :: raw :: c_int , xer_flags : xer_encoder_flags_e , consume_bytes_cb : asn_app_consume_bytes_f , app_key : * mut :: std :: os :: raw :: c_void ) -> asn_enc_rval_t ; } extern "C" { pub fn SubscriptionStatus_decode_uper ( opt_codec_ctx : * mut asn_codec_ctx_t , type_descriptor : * mut asn_TYPE_descriptor_s , constraints : * mut asn_per_constraints_t , struct_ptr : * mut * mut :: std :: os :: raw :: c_void , per_data : * mut asn_per_data_t ) -> asn_dec_rval_t ; } extern "C" { pub fn SubscriptionStatus_encode_uper ( type_descriptor : * mut asn_TYPE_descriptor_s , constraints : * mut asn_per_constraints_t , struct_ptr : * mut :: std :: os :: raw :: c_void , per_output : * mut asn_per_outp_t ) -> asn_enc_rval_t ; } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct ClientRegistration { pub type_ : ClientType_t , pub covered_area : * mut CoveredArea , pub minimum_message_period : * mut :: std :: os :: raw :: c_long , pub _asn_ctx : asn_struct_ctx_t , } # [ test ] fn bindgen_test_layout_ClientRegistration ( ) { assert_eq ! ( :: std :: mem :: size_of :: < ClientRegistration > ( ) , 48usize , concat ! ( "Size of: " , stringify ! ( ClientRegistration ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < ClientRegistration > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( ClientRegistration ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < ClientRegistration > ( ) ) ) . type_ as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( ClientRegistration ) , "::" , stringify ! ( type_ ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < ClientRegistration > ( ) ) ) . covered_area as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( ClientRegistration ) , "::" , stringify ! ( covered_area ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < ClientRegistration > ( ) ) ) . minimum_message_period as * const _ as usize } , 16usize , concat ! ( "Offset of field: " , stringify ! ( ClientRegistration ) , "::" , stringify ! ( minimum_message_period ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < ClientRegistration > ( ) ) ) . _asn_ctx as * const _ as usize } , 24usize , concat ! ( "Offset of field: " , stringify ! ( ClientRegistration ) , "::" , stringify ! ( _asn_ctx ) ) ) ; } pub type ClientRegistration_t = ClientRegistration ; extern "C" { # [ link_name = "\u{1}asn_DEF_ClientRegistration" ] pub static mut asn_DEF_ClientRegistration : asn_TYPE_descriptor_t ; } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct UpdateSubscription { pub subscription_status : SubscriptionStatus_t , pub message_period : * mut :: std :: os :: raw :: c_long , pub _asn_ctx : asn_struct_ctx_t , } # [ test ] fn bindgen_test_layout_UpdateSubscription ( ) { assert_eq ! ( :: std :: mem :: size_of :: < UpdateSubscription > ( ) , 40usize , concat ! ( "Size of: " , stringify ! ( UpdateSubscription ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < UpdateSubscription > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( UpdateSubscription ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < UpdateSubscription > ( ) ) ) . subscription_status as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( UpdateSubscription ) , "::" , stringify ! ( subscription_status ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < UpdateSubscription > ( ) ) ) . message_period as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( UpdateSubscription ) , "::" , stringify ! ( message_period ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < UpdateSubscription > ( ) ) ) . _asn_ctx as * const _ as usize } , 16usize , concat ! ( "Offset of field: " , stringify ! ( UpdateSubscription ) , "::" , stringify ! ( _asn_ctx ) ) ) ; } pub type UpdateSubscription_t = UpdateSubscription ; extern "C" { # [ link_name = "\u{1}asn_DEF_UpdateSubscription" ] pub static mut asn_DEF_UpdateSubscription : asn_TYPE_descriptor_t ; } pub const ConnectionStatus_ConnectionStatus_connected : ConnectionStatus = 0 ; pub const ConnectionStatus_ConnectionStatus_disconnected : ConnectionStatus = 1 ; pub const ConnectionStatus_ConnectionStatus_faulty : ConnectionStatus = 2 ; pub type ConnectionStatus = u32 ; pub use self :: ConnectionStatus as e_ConnectionStatus ; pub type ConnectionStatus_t = :: std :: os :: raw :: c_long ; extern "C" { # [ link_name = "\u{1}asn_DEF_ConnectionStatus" ] pub static mut asn_DEF_ConnectionStatus : asn_TYPE_descriptor_t ; } extern "C" { pub fn ConnectionStatus_free ( type_descriptor : * mut asn_TYPE_descriptor_s , struct_ptr : * mut :: std :: os :: raw :: c_void , free_contents_only : :: std :: os :: raw :: c_int ) ; } extern "C" { pub fn ConnectionStatus_print ( type_descriptor : * mut asn_TYPE_descriptor_s , struct_ptr : * const :: std :: os :: raw :: c_void , level : :: std :: os :: raw :: c_int , callback : asn_app_consume_bytes_f , app_key : * mut :: std :: os :: raw :: c_void ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn ConnectionStatus_constraint ( type_descriptor : * mut asn_TYPE_descriptor_s , struct_ptr : * const :: std :: os :: raw :: c_void , optional_callback : asn_app_constraint_failed_f , optional_app_key : * mut :: std :: os :: raw :: c_void ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn ConnectionStatus_decode_ber ( opt_codec_ctx : * mut asn_codec_ctx_s , type_descriptor : * mut asn_TYPE_descriptor_s , struct_ptr : * mut * mut :: std :: os :: raw :: c_void , buf_ptr : * const :: std :: os :: raw :: c_void , size : usize , tag_mode : :: std :: os :: raw :: c_int ) -> asn_dec_rval_t ; } extern "C" { pub fn ConnectionStatus_encode_der ( type_descriptor : * mut asn_TYPE_descriptor_s , struct_ptr : * mut :: std :: os :: raw :: c_void , tag_mode : :: std :: os :: raw :: c_int , tag : ber_tlv_tag_t , consume_bytes_cb : asn_app_consume_bytes_f , app_key : * mut :: std :: os :: raw :: c_void ) -> asn_enc_rval_t ; } extern "C" { pub fn ConnectionStatus_decode_xer ( opt_codec_ctx : * mut asn_codec_ctx_t , type_descriptor : * mut asn_TYPE_descriptor_s , struct_ptr : * mut * mut :: std :: os :: raw :: c_void , opt_mname : * const :: std :: os :: raw :: c_char , buf_ptr : * const :: std :: os :: raw :: c_void , size : usize ) -> asn_dec_rval_t ; } extern "C" { pub fn ConnectionStatus_encode_xer ( type_descriptor : * mut asn_TYPE_descriptor_s , struct_ptr : * mut :: std :: os :: raw :: c_void , ilevel : :: std :: os :: raw :: c_int , xer_flags : xer_encoder_flags_e , consume_bytes_cb : asn_app_consume_bytes_f , app_key : * mut :: std :: os :: raw :: c_void ) -> asn_enc_rval_t ; } extern "C" { pub fn ConnectionStatus_decode_uper ( opt_codec_ctx : * mut asn_codec_ctx_t , type_descriptor : * mut asn_TYPE_descriptor_s , constraints : * mut asn_per_constraints_t , struct_ptr : * mut * mut :: std :: os :: raw :: c_void , per_data : * mut asn_per_data_t ) -> asn_dec_rval_t ; } extern "C" { pub fn ConnectionStatus_encode_uper ( type_descriptor : * mut asn_TYPE_descriptor_s , constraints : * mut asn_per_constraints_t , struct_ptr : * mut :: std :: os :: raw :: c_void , per_output : * mut asn_per_outp_t ) -> asn_enc_rval_t ; } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct UpdateStatus { pub sensor_status : ConnectionStatus_t , pub ip_address : UTF8String_t , pub sensor_id : :: std :: os :: raw :: c_long , pub _asn_ctx : asn_struct_ctx_t , } # [ test ] fn bindgen_test_layout_UpdateStatus ( ) { assert_eq ! ( :: std :: mem :: size_of :: < UpdateStatus > ( ) , 80usize , concat ! ( "Size of: " , stringify ! ( UpdateStatus ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < UpdateStatus > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( UpdateStatus ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < UpdateStatus > ( ) ) ) . sensor_status as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( UpdateStatus ) , "::" , stringify ! ( sensor_status ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < UpdateStatus > ( ) ) ) . ip_address as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( UpdateStatus ) , "::" , stringify ! ( ip_address ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < UpdateStatus > ( ) ) ) . sensor_id as * const _ as usize } , 48usize , concat ! ( "Offset of field: " , stringify ! ( UpdateStatus ) , "::" , stringify ! ( sensor_id ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < UpdateStatus > ( ) ) ) . _asn_ctx as * const _ as usize } , 56usize , concat ! ( "Offset of field: " , stringify ! ( UpdateStatus ) , "::" , stringify ! ( _asn_ctx ) ) ) ; } pub type UpdateStatus_t = UpdateStatus ; extern "C" { # [ link_name = "\u{1}asn_DEF_UpdateStatus" ] pub static mut asn_DEF_UpdateStatus : asn_TYPE_descriptor_t ; } pub const SensorType_SensorType_server : SensorType = 0 ; pub const SensorType_SensorType_cam : SensorType = 1 ; pub const SensorType_SensorType_lidar : SensorType = 2 ; pub type SensorType = u32 ; pub use self :: SensorType as e_SensorType ; pub type SensorType_t = :: std :: os :: raw :: c_long ; extern "C" { # [ link_name = "\u{1}asn_DEF_SensorType" ] pub static mut asn_DEF_SensorType : asn_TYPE_descriptor_t ; } extern "C" { pub fn SensorType_free ( type_descriptor : * mut asn_TYPE_descriptor_s , struct_ptr : * mut :: std :: os :: raw :: c_void , free_contents_only : :: std :: os :: raw :: c_int ) ; } extern "C" { pub fn SensorType_print ( type_descriptor : * mut asn_TYPE_descriptor_s , struct_ptr : * const :: std :: os :: raw :: c_void , level : :: std :: os :: raw :: c_int , callback : asn_app_consume_bytes_f , app_key : * mut :: std :: os :: raw :: c_void ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn SensorType_constraint ( type_descriptor : * mut asn_TYPE_descriptor_s , struct_ptr : * const :: std :: os :: raw :: c_void , optional_callback : asn_app_constraint_failed_f , optional_app_key : * mut :: std :: os :: raw :: c_void ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn SensorType_decode_ber ( opt_codec_ctx : * mut asn_codec_ctx_s , type_descriptor : * mut asn_TYPE_descriptor_s , struct_ptr : * mut * mut :: std :: os :: raw :: c_void , buf_ptr : * const :: std :: os :: raw :: c_void , size : usize , tag_mode : :: std :: os :: raw :: c_int ) -> asn_dec_rval_t ; } extern "C" { pub fn SensorType_encode_der ( type_descriptor : * mut asn_TYPE_descriptor_s , struct_ptr : * mut :: std :: os :: raw :: c_void , tag_mode : :: std :: os :: raw :: c_int , tag : ber_tlv_tag_t , consume_bytes_cb : asn_app_consume_bytes_f , app_key : * mut :: std :: os :: raw :: c_void ) -> asn_enc_rval_t ; } extern "C" { pub fn SensorType_decode_xer ( opt_codec_ctx : * mut asn_codec_ctx_t , type_descriptor : * mut asn_TYPE_descriptor_s , struct_ptr : * mut * mut :: std :: os :: raw :: c_void , opt_mname : * const :: std :: os :: raw :: c_char , buf_ptr : * const :: std :: os :: raw :: c_void , size : usize ) -> asn_dec_rval_t ; } extern "C" { pub fn SensorType_encode_xer ( type_descriptor : * mut asn_TYPE_descriptor_s , struct_ptr : * mut :: std :: os :: raw :: c_void , ilevel : :: std :: os :: raw :: c_int , xer_flags : xer_encoder_flags_e , consume_bytes_cb : asn_app_consume_bytes_f , app_key : * mut :: std :: os :: raw :: c_void ) -> asn_enc_rval_t ; } extern "C" { pub fn SensorType_decode_uper ( opt_codec_ctx : * mut asn_codec_ctx_t , type_descriptor : * mut asn_TYPE_descriptor_s , constraints : * mut asn_per_constraints_t , struct_ptr : * mut * mut :: std :: os :: raw :: c_void , per_data : * mut asn_per_data_t ) -> asn_dec_rval_t ; } extern "C" { pub fn SensorType_encode_uper ( type_descriptor : * mut asn_TYPE_descriptor_s , constraints : * mut asn_per_constraints_t , struct_ptr : * mut :: std :: os :: raw :: c_void , per_output : * mut asn_per_outp_t ) -> asn_enc_rval_t ; } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct SensorEnvelope { pub version : :: std :: os :: raw :: c_long , pub sensor_type : SensorType_t , pub sender_id : :: std :: os :: raw :: c_long , pub pole_id : :: std :: os :: raw :: c_long , pub reference_point : ReferencePoint_t , pub error_code : :: std :: os :: raw :: c_long , pub _asn_ctx : asn_struct_ctx_t , } # [ test ] fn bindgen_test_layout_SensorEnvelope ( ) { assert_eq ! ( :: std :: mem :: size_of :: < SensorEnvelope > ( ) , 112usize , concat ! ( "Size of: " , stringify ! ( SensorEnvelope ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < SensorEnvelope > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( SensorEnvelope ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < SensorEnvelope > ( ) ) ) . version as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( SensorEnvelope ) , "::" , stringify ! ( version ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < SensorEnvelope > ( ) ) ) . sensor_type as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( SensorEnvelope ) , "::" , stringify ! ( sensor_type ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < SensorEnvelope > ( ) ) ) . sender_id as * const _ as usize } , 16usize , concat ! ( "Offset of field: " , stringify ! ( SensorEnvelope ) , "::" , stringify ! ( sender_id ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < SensorEnvelope > ( ) ) ) . pole_id as * const _ as usize } , 24usize , concat ! ( "Offset of field: " , stringify ! ( SensorEnvelope ) , "::" , stringify ! ( pole_id ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < SensorEnvelope > ( ) ) ) . reference_point as * const _ as usize } , 32usize , concat ! ( "Offset of field: " , stringify ! ( SensorEnvelope ) , "::" , stringify ! ( reference_point ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < SensorEnvelope > ( ) ) ) . error_code as * const _ as usize } , 80usize , concat ! ( "Offset of field: " , stringify ! ( SensorEnvelope ) , "::" , stringify ! ( error_code ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < SensorEnvelope > ( ) ) ) . _asn_ctx as * const _ as usize } , 88usize , concat ! ( "Offset of field: " , stringify ! ( SensorEnvelope ) , "::" , stringify ! ( _asn_ctx ) ) ) ; } pub type SensorEnvelope_t = SensorEnvelope ; extern "C" { # [ link_name = "\u{1}asn_DEF_SensorEnvelope" ] pub static mut asn_DEF_SensorEnvelope : asn_TYPE_descriptor_t ; } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct SensorObjectDetection { pub local_id : :: std :: os :: raw :: c_long , pub probability_of_existence : :: std :: os :: raw :: c_long , pub position_offset : PositionOffset_t , pub moving_vector : * mut MovingVector , pub type_ : ObjectType_t , pub type_probability : :: std :: os :: raw :: c_long , pub size : ObjectSize_t , pub orientation : * mut :: std :: os :: raw :: c_long , pub std_dev_orientation : * mut :: std :: os :: raw :: c_long , pub measured : * mut BOOLEAN_t , pub _asn_ctx : asn_struct_ctx_t , } # [ test ] fn bindgen_test_layout_SensorObjectDetection ( ) { assert_eq ! ( :: std :: mem :: size_of :: < SensorObjectDetection > ( ) , 216usize , concat ! ( "Size of: " , stringify ! ( SensorObjectDetection ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < SensorObjectDetection > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( SensorObjectDetection ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < SensorObjectDetection > ( ) ) ) . local_id as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( SensorObjectDetection ) , "::" , stringify ! ( local_id ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < SensorObjectDetection > ( ) ) ) . probability_of_existence as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( SensorObjectDetection ) , "::" , stringify ! ( probability_of_existence ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < SensorObjectDetection > ( ) ) ) . position_offset as * const _ as usize } , 16usize , concat ! ( "Offset of field: " , stringify ! ( SensorObjectDetection ) , "::" , stringify ! ( position_offset ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < SensorObjectDetection > ( ) ) ) . moving_vector as * const _ as usize } , 72usize , concat ! ( "Offset of field: " , stringify ! ( SensorObjectDetection ) , "::" , stringify ! ( moving_vector ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < SensorObjectDetection > ( ) ) ) . type_ as * const _ as usize } , 80usize , concat ! ( "Offset of field: " , stringify ! ( SensorObjectDetection ) , "::" , stringify ! ( type_ ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < SensorObjectDetection > ( ) ) ) . type_probability as * const _ as usize } , 88usize , concat ! ( "Offset of field: " , stringify ! ( SensorObjectDetection ) , "::" , stringify ! ( type_probability ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < SensorObjectDetection > ( ) ) ) . size as * const _ as usize } , 96usize , concat ! ( "Offset of field: " , stringify ! ( SensorObjectDetection ) , "::" , stringify ! ( size ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < SensorObjectDetection > ( ) ) ) . orientation as * const _ as usize } , 168usize , concat ! ( "Offset of field: " , stringify ! ( SensorObjectDetection ) , "::" , stringify ! ( orientation ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < SensorObjectDetection > ( ) ) ) . std_dev_orientation as * const _ as usize } , 176usize , concat ! ( "Offset of field: " , stringify ! ( SensorObjectDetection ) , "::" , stringify ! ( std_dev_orientation ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < SensorObjectDetection > ( ) ) ) . measured as * const _ as usize } , 184usize , concat ! ( "Offset of field: " , stringify ! ( SensorObjectDetection ) , "::" , stringify ! ( measured ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < SensorObjectDetection > ( ) ) ) . _asn_ctx as * const _ as usize } , 192usize , concat ! ( "Offset of field: " , stringify ! ( SensorObjectDetection ) , "::" , stringify ! ( _asn_ctx ) ) ) ; } pub type SensorObjectDetection_t = SensorObjectDetection ; extern "C" { # [ link_name = "\u{1}asn_DEF_SensorObjectDetection" ] pub static mut asn_DEF_SensorObjectDetection : asn_TYPE_descriptor_t ; } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct SensorObjectDetections { pub list : SensorObjectDetections__bindgen_ty_1 , pub _asn_ctx : asn_struct_ctx_t , } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct SensorObjectDetections__bindgen_ty_1 { pub array : * mut * mut SensorObjectDetection , pub count : :: std :: os :: raw :: c_int , pub size : :: std :: os :: raw :: c_int , pub free : :: std :: option :: Option < unsafe extern "C" fn ( arg1 : * mut SensorObjectDetection ) > , } # [ test ] fn bindgen_test_layout_SensorObjectDetections__bindgen_ty_1 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < SensorObjectDetections__bindgen_ty_1 > ( ) , 24usize , concat ! ( "Size of: " , stringify ! ( SensorObjectDetections__bindgen_ty_1 ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < SensorObjectDetections__bindgen_ty_1 > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( SensorObjectDetections__bindgen_ty_1 ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < SensorObjectDetections__bindgen_ty_1 > ( ) ) ) . array as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( SensorObjectDetections__bindgen_ty_1 ) , "::" , stringify ! ( array ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < SensorObjectDetections__bindgen_ty_1 > ( ) ) ) . count as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( SensorObjectDetections__bindgen_ty_1 ) , "::" , stringify ! ( count ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < SensorObjectDetections__bindgen_ty_1 > ( ) ) ) . size as * const _ as usize } , 12usize , concat ! ( "Offset of field: " , stringify ! ( SensorObjectDetections__bindgen_ty_1 ) , "::" , stringify ! ( size ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < SensorObjectDetections__bindgen_ty_1 > ( ) ) ) . free as * const _ as usize } , 16usize , concat ! ( "Offset of field: " , stringify ! ( SensorObjectDetections__bindgen_ty_1 ) , "::" , stringify ! ( free ) ) ) ; } # [ test ] fn bindgen_test_layout_SensorObjectDetections ( ) { assert_eq ! ( :: std :: mem :: size_of :: < SensorObjectDetections > ( ) , 48usize , concat ! ( "Size of: " , stringify ! ( SensorObjectDetections ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < SensorObjectDetections > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( SensorObjectDetections ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < SensorObjectDetections > ( ) ) ) . list as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( SensorObjectDetections ) , "::" , stringify ! ( list ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < SensorObjectDetections > ( ) ) ) . _asn_ctx as * const _ as usize } , 24usize , concat ! ( "Offset of field: " , stringify ! ( SensorObjectDetections ) , "::" , stringify ! ( _asn_ctx ) ) ) ; } pub type SensorObjectDetections_t = SensorObjectDetections ; extern "C" { # [ link_name = "\u{1}asn_DEF_SensorObjectDetections" ] pub static mut asn_DEF_SensorObjectDetections : asn_TYPE_descriptor_t ; } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct SensorFrame { pub header : Header_t , pub envelope : SensorEnvelope_t , pub object_detections : SensorObjectDetections_t , pub _asn_ctx : asn_struct_ctx_t , } # [ test ] fn bindgen_test_layout_SensorFrame ( ) { assert_eq ! ( :: std :: mem :: size_of :: < SensorFrame > ( ) , 216usize , concat ! ( "Size of: " , stringify ! ( SensorFrame ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < SensorFrame > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( SensorFrame ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < SensorFrame > ( ) ) ) . header as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( SensorFrame ) , "::" , stringify ! ( header ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < SensorFrame > ( ) ) ) . envelope as * const _ as usize } , 32usize , concat ! ( "Offset of field: " , stringify ! ( SensorFrame ) , "::" , stringify ! ( envelope ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < SensorFrame > ( ) ) ) . object_detections as * const _ as usize } , 144usize , concat ! ( "Offset of field: " , stringify ! ( SensorFrame ) , "::" , stringify ! ( object_detections ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < SensorFrame > ( ) ) ) . _asn_ctx as * const _ as usize } , 192usize , concat ! ( "Offset of field: " , stringify ! ( SensorFrame ) , "::" , stringify ! ( _asn_ctx ) ) ) ; } pub type SensorFrame_t = SensorFrame ; extern "C" { # [ link_name = "\u{1}asn_DEF_SensorFrame" ] pub static mut asn_DEF_SensorFrame : asn_TYPE_descriptor_t ; } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct SensorIdleFrame { pub version : :: std :: os :: raw :: c_long , pub sender_id : :: std :: os :: raw :: c_long , pub pole_id : :: std :: os :: raw :: c_long , pub _asn_ctx : asn_struct_ctx_t , } # [ test ] fn bindgen_test_layout_SensorIdleFrame ( ) { assert_eq ! ( :: std :: mem :: size_of :: < SensorIdleFrame > ( ) , 48usize , concat ! ( "Size of: " , stringify ! ( SensorIdleFrame ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < SensorIdleFrame > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( SensorIdleFrame ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < SensorIdleFrame > ( ) ) ) . version as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( SensorIdleFrame ) , "::" , stringify ! ( version ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < SensorIdleFrame > ( ) ) ) . sender_id as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( SensorIdleFrame ) , "::" , stringify ! ( sender_id ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < SensorIdleFrame > ( ) ) ) . pole_id as * const _ as usize } , 16usize , concat ! ( "Offset of field: " , stringify ! ( SensorIdleFrame ) , "::" , stringify ! ( pole_id ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < SensorIdleFrame > ( ) ) ) . _asn_ctx as * const _ as usize } , 24usize , concat ! ( "Offset of field: " , stringify ! ( SensorIdleFrame ) , "::" , stringify ! ( _asn_ctx ) ) ) ; } pub type SensorIdleFrame_t = SensorIdleFrame ; extern "C" { # [ link_name = "\u{1}asn_DEF_SensorIdleFrame" ] pub static mut asn_DEF_SensorIdleFrame : asn_TYPE_descriptor_t ; } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct BIT_STRING_s { pub buf : * mut u8 , pub size : :: std :: os :: raw :: c_int , pub bits_unused : :: std :: os :: raw :: c_int , pub _asn_ctx : asn_struct_ctx_t , } # [ test ] fn bindgen_test_layout_BIT_STRING_s ( ) { assert_eq ! ( :: std :: mem :: size_of :: < BIT_STRING_s > ( ) , 40usize , concat ! ( "Size of: " , stringify ! ( BIT_STRING_s ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < BIT_STRING_s > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( BIT_STRING_s ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < BIT_STRING_s > ( ) ) ) . buf as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( BIT_STRING_s ) , "::" , stringify ! ( buf ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < BIT_STRING_s > ( ) ) ) . size as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( BIT_STRING_s ) , "::" , stringify ! ( size ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < BIT_STRING_s > ( ) ) ) . bits_unused as * const _ as usize } , 12usize , concat ! ( "Offset of field: " , stringify ! ( BIT_STRING_s ) , "::" , stringify ! ( bits_unused ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < BIT_STRING_s > ( ) ) ) . _asn_ctx as * const _ as usize } , 16usize , concat ! ( "Offset of field: " , stringify ! ( BIT_STRING_s ) , "::" , stringify ! ( _asn_ctx ) ) ) ; } pub type BIT_STRING_t = BIT_STRING_s ; extern "C" { # [ link_name = "\u{1}asn_DEF_BIT_STRING" ] pub static mut asn_DEF_BIT_STRING : asn_TYPE_descriptor_t ; } extern "C" { pub fn BIT_STRING_print ( type_descriptor : * mut asn_TYPE_descriptor_s , struct_ptr : * const :: std :: os :: raw :: c_void , level : :: std :: os :: raw :: c_int , callback : asn_app_consume_bytes_f , app_key : * mut :: std :: os :: raw :: c_void ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn BIT_STRING_constraint ( type_descriptor : * mut asn_TYPE_descriptor_s , struct_ptr : * const :: std :: os :: raw :: c_void , optional_callback : asn_app_constraint_failed_f , optional_app_key : * mut :: std :: os :: raw :: c_void ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn BIT_STRING_encode_xer ( type_descriptor : * mut asn_TYPE_descriptor_s , struct_ptr : * mut :: std :: os :: raw :: c_void , ilevel : :: std :: os :: raw :: c_int , xer_flags : xer_encoder_flags_e , consume_bytes_cb : asn_app_consume_bytes_f , app_key : * mut :: std :: os :: raw :: c_void ) -> asn_enc_rval_t ; } pub const pxml_chunk_type_e_PXML_TEXT : pxml_chunk_type_e = 0 ; pub const pxml_chunk_type_e_PXML_TAG : pxml_chunk_type_e = 1 ; pub const pxml_chunk_type_e_PXML_COMMENT : pxml_chunk_type_e = 2 ; pub const pxml_chunk_type_e_PXML_TAG_END : pxml_chunk_type_e = 3 ; pub const pxml_chunk_type_e_PXML_COMMENT_END : pxml_chunk_type_e = 4 ; pub type pxml_chunk_type_e = u32 ; pub type pxml_callback_f = :: std :: option :: Option < unsafe extern "C" fn ( _type : pxml_chunk_type_e , _chunk_data : * const :: std :: os :: raw :: c_void , _chunk_size : usize , _key : * mut :: std :: os :: raw :: c_void ) -> :: std :: os :: raw :: c_int > ; extern "C" { pub fn pxml_parse ( _stateContext : * mut :: std :: os :: raw :: c_int , _buf : * const :: std :: os :: raw :: c_void , _size : usize , cb : pxml_callback_f , _key : * mut :: std :: os :: raw :: c_void ) -> isize ; } extern "C" { pub fn uper_open_type_get ( opt_codec_ctx : * mut asn_codec_ctx_t , td : * mut asn_TYPE_descriptor_t , constraints : * mut asn_per_constraints_t , sptr : * mut * mut :: std :: os :: raw :: c_void , pd : * mut asn_per_data_t ) -> asn_dec_rval_t ; } extern "C" { pub fn uper_open_type_skip ( opt_codec_ctx : * mut asn_codec_ctx_t , pd : * mut asn_per_data_t ) -> :: std :: os :: raw :: c_int ; } extern "C" { pub fn uper_open_type_put ( td : * mut asn_TYPE_descriptor_t , constraints : * mut asn_per_constraints_t , sptr : * mut :: std :: os :: raw :: c_void , po : * mut asn_per_outp_t ) -> :: std :: os :: raw :: c_int ; } pub type __builtin_va_list = [ __va_list_tag ; 1usize ] ; # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct __va_list_tag { pub gp_offset : :: std :: os :: raw :: c_uint , pub fp_offset : :: std :: os :: raw :: c_uint , pub overflow_arg_area : * mut :: std :: os :: raw :: c_void , pub reg_save_area : * mut :: std :: os :: raw :: c_void , } # [ test ] fn bindgen_test_layout___va_list_tag ( ) { assert_eq ! ( :: std :: mem :: size_of :: < __va_list_tag > ( ) , 24usize , concat ! ( "Size of: " , stringify ! ( __va_list_tag ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < __va_list_tag > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( __va_list_tag ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < __va_list_tag > ( ) ) ) . gp_offset as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( __va_list_tag ) , "::" , stringify ! ( gp_offset ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < __va_list_tag > ( ) ) ) . fp_offset as * const _ as usize } , 4usize , concat ! ( "Offset of field: " , stringify ! ( __va_list_tag ) , "::" , stringify ! ( fp_offset ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < __va_list_tag > ( ) ) ) . overflow_arg_area as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( __va_list_tag ) , "::" , stringify ! ( overflow_arg_area ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < __va_list_tag > ( ) ) ) . reg_save_area as * const _ as usize } , 16usize , concat ! ( "Offset of field: " , stringify ! ( __va_list_tag ) , "::" , stringify ! ( reg_save_area ) ) ) ; } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct __locale_data { pub _address : u8 , }