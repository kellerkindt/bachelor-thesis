
\chapter{Hochperformante, serverbasierte Kommunikationsplattform}
\label{com_plattform}

Dieses Kapitel erläutert den Begriff \enquote{hochperformante, serverbasierte Kommunikationsplattform} und vermittelt Basiswissen hierzu.

\section{Echtzeitsysteme}
Echtzeitsysteme zeichnen sich im allgemeinen dadurch aus, eine Aufgabe in einem zuvor vorgegebenen Zeitraum bearbeiten zu können.
Es existiert zu einer Aufgabe also immer eine Frist.
Bei der Bewertung der Richtigkeit eines Systems, wird die Fähigkeit, eine Frist einhalten zu können, auch bewertet \cite[2]{perf:buttazzo2006soft}.
Je nach Art des Echtzeitsystems, wird diese First jedoch unterschiedlich gewichtet:

\begin{itemize}
	\item Bei einem harten Echtzeitsystem kann eine Überschreitung der Frist einen katastrophalen Ausgang haben.
	Selbst im schlimmsten Fall darf diese Frist nicht überschritten werden.
	Deswegen wird in einem harten Echtzeitsystem die im maximale Reaktionszeit dem Zeitraum bis zur Frist gegenübergestellt \cite[75]{douglass2003real}.
	Ein Ergebnis nach Ablauf der Frist wird als nutzlos gewertet \cite[2]{perf:wang2017real}.
	
	Zum Beispiel könnte eine zu späte Auswertung von Beschleunigungsdaten in einem Flugzeug zu einer verzögerten und mittlerweile falschen Reaktion und daraufhin zu einem Absturz führen \cite[5]{perf:laplante2004real}.
	
	\item Bei einem weichen Echtzeitsystem resultiert die Überschreitung des vorgegebenes Zeitraums nicht in eine Katastrophe.
	Es wird die durchschnittliche Reaktionszeit dem Zeitraum bis zur Frist gegenübergestellt, eine seltene und unter last auftretende Überschreitung wird in kauf genommen \cite[76]{douglass2003real}.
	Das System führt in so einem Fall weiterhin seine Aufgaben aus, die Performance wird aber \todo{abgewertet} eingestuft.
	Weiche Echtzeitsysteme können sogar überhaupt keine Frist haben, sondern die Aufgabe, die Antwortzeit so gering wie möglich zu gehalten \cite[4]{perf:buttazzo2006soft}.
\end{itemize}

\section{Mobile Edge Computing}

Mobile Edge Computing bezeichnet Recheneinheiten, die außerhalb der Cloudinfrastruktur für das Mobilfunknetz eingesetzt werden \todo{eu norm etsi dings da}.
Wenn in dieser Arbeit auf MEC Bezug genommen wird, sind damit explizit nahe Funkmasten montierte Recheneinheiten gemeint.
Dadurch, dass die Recheneinheiten direkt an eine Antenne angeschlossen sind, können sie die Anfragen deutlich schneller beantworten (Latenz kleiner 20ms) als Cloudlösungen (Latenz ca 100ms) \cite[2]{perf:mec:fraunhofer}.

\todo{direkt am Funkmast, TCP, nichts erst via Internet -> niedrige Latenz, VMs}

\section{GeoFence}


\section{Architekturmuster? oder erst während der Implementation?}



			
			
		\subsection{Was ist dann ein hochperformantes System}
		\subsection{Low-Latency + Entwurfsmuster + Patterns? + Algorithmen?}
			\todo{Hochperformant -> parallel?}
			
			\todo{Design Pattern, Gamma et al, four important aspects}
			
			\todo{Real Time Design Patterns Buch: Ab Seite 141, verschiedene Systempatterns, microkernel \cite[151]{douglass2003real}? channel architektur pattern \cite[167]{douglass2003real}?}
			
			\todo{Message Queuing Pattern \cite[207]{douglass2003real}}
			
			\todo{Clean Architecture / Clean Code}
			
	\section{Serverbasierte Kommunikationsplattform: MEC}
	
		
		
	\input{sections/asn}
	
	
\section{Funktionale Sicherheit}
\label{com:safety}
\todo{tdd hilft}
	
\section{Test-Driven Development}

\begin{quotation}
	\textit{\enquote{Failure is progress.}}
	\cite[5]{tdd}
\end{quotation}
\begin{quotation}
	\textit{\enquote{Make it run, make it good.}}
	\cite[24]{tdd}
\end{quotation}

Bei der Test-getriebenen Entwicklung werden Tests in den Vordergrund gestellt.
Die Implementierung einer neuen Funktionalität wird durch neue Tests, die die Anforderung repräsentieren, eingeleitet.
Erst nachdem ein Test erfolgreich feststellt, dass die geforderte Funktionalität noch nicht vorhanden ist, wird mit der Implementierung begonnen.
Eine schnelle Implementierung hat hierbei die höchste Priorität und erlaubt temporär auch eine limitierende, stinkende und naïve Vorgehensweise \cite[7]{tdd}.
%Der neue Code, der den Test zufriedenstellt, darf hierbei kurzzeitig \enquote{stinken} \todo{cite} und Qualitätsstandards verletzten.
Direkt im Anschluss wird ein Refactoring\footnote{Verbesserung des Codes und der Struktur ohne Änderung der Funktionalität} durchgeführt, um die Qualitätsstandards wieder einzuhalten.
Diese drei Phasen werden \enquote{red/green/refactor} bezeichnet:

\begin{itemize}
	\item \textbf{red}: Ein neuer Test wird erstellt, dieser stellt erfolgreich die Abwesenheit der Funktionalität fest, eine rote Fehlermeldung ist zu sehen.
	\item \textbf{green}: Der Test wird durch neuen Code zufriedengestellt; eine positive Ausgabe bestätigt dies. Eine schnelle Implementierung wird hierbei temporär einer hochwertigen bevorzugt \cite[24]{tdd}, da ein erfolgreicher Test das Selbstvertrauen beim Refactorn stärke und helfen würde, Fehlerhafte Tests zu finden \cite[152]{tdd}.
	\item \textbf{refactor}: Der neue Code wird aufgeräumt und verbessert um den Qualitätsstandards gerecht zu werden. Ein andauernder Testdurchlauf versichert dabei keine Regression der Funktionalität.
\end{itemize}

Die Testgröße und der daraus resultierende Umfang der neuen Funktionalität, wird durch die Zuversichtlichkeit des Entwicklers gesteuert \cite[42]{tdd}.
Eine hohe Zuversichtlichkeit führt zu größeren Tests, während eine hohe Unsicherheit zu vielen kleinen Tests führt.
Dementsprechend sind komplexe Anforderungen mit vielen Tests abgesichert.
Bei Änderungen kann man sich deshalb auf das Sicherheitsnetz aus Tests verlassen, die einen Defekt umgehend detektieren.

%\todo{manchmal stellt man beim erstellen des tests fest, dass die Anforderung blöd ist}
Test-getriebene Entwicklung verändert auch die Vorgehensweise bei der Implementation von Anforderungen. Anstatt zu fragen \enquote{Wie würde ich das Implementieren?}, wird überlegt \enquote{Wie würde ich das Testen?} \cite[39]{tdd}, womit auch implizit gefragt wird, wie die äußeren Schnittstelle idealerweise aussehen sollen \cite[4]{tdd}.


%\todo{p.11, shift of practice in p.13, \enquote{Make it run, make it good} p.24, no changes unless enough motivation p.34, tests run -> not broken anything p.37, never interrupt an interruption p.41, TDD is a steering process, unsure -> smaller steps, sure -> bigger steps p.42, Test First can reduce stress p.127}

%\todo{mention stress reduction?}
	
	\section{Sensordaten?}
	
	\section{TCP?}
	
	\todo{Kommunikation als Socket, FiFo, Fehlerkorrektur, erneutes senden bei Fehlern, richtige Reiehenfolge...}