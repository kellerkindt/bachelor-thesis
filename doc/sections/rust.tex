
\chapter{Die Programmiersprache Rust}

Rust ist eine Programmiersprache, die versucht performant -- und daher durch Abstraktionen mit keinem zusätzlichen \enquote{Kosten} \todo{ref zero cost abstractions} -- sichere Programmierung zu ermöglichen.
Ziel ist eine \todo{Systemprogrammiersprache}, die sowohl sicher \todo{cite chapter} als auch performant ist und ohne eine Laufzeit ausgeführt werden kann.
Verschiedene Fehlerquellen -- wie \enquote{dangling pointers}, \enquote{double free} oder \enquote{memory leaks} \todo{ref} --  werden durch Abstraktionen und mit Hilfe des Kompilers verhindert.
Anders als Programmiersprachen, die dies mit Hilfe einer Laufzeit ermöglichen (zbsp. Java oder C\#), wird dies in Rust durch eine statische Analyse und einem Eigentümerprinzip bei der Kompilation gewährleistet.


\section{Geschichte}
\label{rust:history}

In 2006 \cite{rust:faq} begann Graydon Hoare die Programmiersprache Rust in seiner Freizeit als Hobbyprojekt zu entwickeln.
Als Grund nannte er seine Unzufriedenheit mit der Programmiersprache C++, in der es sehr schwierig sei, fehlerfreien, speichersicheren und nebenläufigen Code zu schreiben.
Zudem beschrieb er C++ als \enquote{ziemlich fehlerträchtig}. \cite{rust:heise_interview_graydon}

Ab 2009 begann Mozilla die Weiterentwicklung finanziell zu fördern, da einfache Tests und die Kernprinzipien demonstriert werden konnten.
Die Entwicklung findet dabei öffentlich einsehbar auf GitHub unter \url{https://github.com/rust-lang/rust} statt und wird dabei nicht ausschließlich von Mozilla Angestellten koordiniert.
Die Stabilität des Kompilers trotz Flexibilität während der Entwicklung wird dabei durch Unterscheidung von drei Veröffentlichungskanälen -- release, stable und nightly -- in Kombination mit automatisierten Tests \todo{ref?} gewährleistet. \cite{rust:faq}



\todo{hobbyprojekt, mozilla, open-source, Entwicklung auf GitHub - jeder kann sich beteiligen, test(coverage), automatisierte builds, stable/beta/nightly}



\section{type safety langauge}
\section{no undefined behavior, oreilly}
\section{Zero Cost Abstraction}

\section{Was ist Rust?}


\section{nichts wird dem Zufall überlassen}

\todo{no undefined}
\todo{official format/naming convetion}

\begin{wrapfigure}{r}{.5\textwidth}
	\begin{rustc}
		fn main() {
			println!("Hello World");
		}
	\end{rustc}
	\caption{\enquote{Hello World} in Rust}
	\label{fig:rust:hello_world}
\end{wrapfigure}


\todo{functional programming -> no global state, no exceptions, find literature}

Rust ist...
% \lipsum

\todo{Rust -> MIR -> assembler} \\
\todo{MIR/assemblerbeispiele?} \\
\cite{rust:orly_programming}

\FloatBarrier
\section{Sprachfeatures}
\subsection{Option}
\subsection{Result}

\section{Warum Rust?}

\begin{quotation}
	\textit{\enquote{[..]Leute, die [..] sichere Programmierung haben wollen, [..] können das bei Rust haben, ohne die [von D] undeterministischen Laufzeiten oder Abstraktionskosten schlucken zu müssen. }}
	\cite{rust:fefe}
\end{quotation}




\begin{quotation}
	\textit{\enquote{It’s not bad programmers, it’s that C is a hostile language}} 
	(Seite 54, \cite{rust:c_is_hostile_mena})
\end{quotation}

\begin{quotation}
	\textit{\enquote{I’m thinking that C is actively hostile to writing and maintaining reliable code}} 
	(Seite 129, \cite{rust:c_is_hostile_mena})
\end{quotation}

\begin{quotation}
	\textit{\enquote{[..] Rust makes it safe, and  provides nice tools}} 
	(Seite 130, \cite{rust:c_is_hostile_mena})
\end{quotation}


\begin{quotation}
	\textit{\enquote{Rust hilft beim Fehlervermeiden}} 
	\cite{rust:c_is_hostile_golem}
\end{quotation}


\begin{quotation}
	\textit{\enquote{Rust is [..] a language that cares about very tight control}}
	\cite{rust:tight_control}
\end{quotation}

\todo{unused orly rust} \cite{rust:orly_y_rust}

\section{Kernfeatures}

https://www.youtube.com/watch?v=d1uraoHM8Gg \\
\todo{no dangling pointers} \\
\todo{no need for a runtime, all static analytics} \\
\todo{memory safety} \\
\todo{data-race freedom} \\
\todo{active community} \\
\todo{concurrency: no undefined behavior} \\
\todo{ffi binding} \gls{ffi} \\
\todo{zero cost abstraction} \\
\todo{package manager: cargo} \\

https://www.youtube.com/watch?v=-Tj8Q12DaEQ \\
\todo{static type system with local type inference } \\
\todo{explicit notion of mutability } \\
\todo{zero-cost abstraction *(do not introduce new cost through implementation of abstraction)} \\
\todo{errors are values not exceptions}
\todo{no null} \\
\todo{"static automatic memory management" - no garbage collection } \\
\todo{often compared to GO and D (~44min)} \\


\section{Schwächen}

https://www.youtube.com/watch?v=-Tj8Q12DaEQ \\
\todo{compile-times} \\
\todo{Rust is a vampire language, it does not reflect at all!} \\
\todo{depending on the field -> majority of libraries?} \\


\section{Performance Fallstricke}

\todo{\cite{rust:performance_pitfalls}}

\section{Beispiele von Verwendung von Rust}

\todo{firefox} \\

https://www.youtube.com/watch?v=-Tj8Q12DaEQ \\
\todo{GTK binding heavily to rust} \\
