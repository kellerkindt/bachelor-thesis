<!DOCTYPE html>
<html class="sidebar-visible light" lang="en"><head>
        <meta charset="UTF-8">
        <title>Primitive Types - The Rust Programming Language</title>
        <meta content="text/html; charset=UTF-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="rgb(255, 255, 255)">

        <!-- base href="https://doc.rust-lang.org/book/first-edition/primitive-types.html" -->

        <link rel="stylesheet" href="Rusg-Dateien/book.css">
        <link href="Rusg-Dateien/css.css" rel="stylesheet" type="text/css">
        <link href="Rusg-Dateien/css_002.css" rel="stylesheet" type="text/css">

        <link rel="shortcut icon" href="https://doc.rust-lang.org/book/first-edition/favicon.png">

        <!-- Font Awesome -->
        <link rel="stylesheet" href="Rusg-Dateien/font-awesome.css">

        <link rel="stylesheet" href="Rusg-Dateien/highlight.css">
        <link rel="stylesheet" href="Rusg-Dateien/tomorrow-night.css">
        <link rel="stylesheet" href="Rusg-Dateien/ayu-highlight.css">

        <!-- Custom theme -->
        
        <link rel="stylesheet" href="Rusg-Dateien/first-edition.css">
        

        

        <!-- Fetch Clipboard.js from CDN but have a local fallback -->
        <script src="Rusg-Dateien/clipboard_002.js"></script>
        <script>
            if (typeof Clipboard == 'undefined') {
                document.write(unescape("%3Cscript src='clipboard.min.js'%3E%3C/script%3E"));
            }
        </script><script src="Rusg-Dateien/clipboard.js"></script>

    </head>
    <body class="light">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { } 
            if (theme === null || theme === undefined) { theme = 'light'; }
            document.body.className = theme;
            document.querySelector('html').className = theme;
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            document.querySelector('html').classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents" aria-hidden="false">
            <ol class="chapter"><li class="affix"><a href="https://doc.rust-lang.org/book/first-edition/README.html" tabindex="0">Introduction</a></li><li><a href="https://doc.rust-lang.org/book/first-edition/getting-started.html" tabindex="0"><strong aria-hidden="true">1.</strong> Getting Started</a></li><li><a href="https://doc.rust-lang.org/book/first-edition/guessing-game.html" tabindex="0"><strong aria-hidden="true">2.</strong> Tutorial: Guessing Game</a></li><li><a href="https://doc.rust-lang.org/book/first-edition/syntax-and-semantics.html" tabindex="0"><strong aria-hidden="true">3.</strong> Syntax and Semantics</a></li><li><ol class="section"><li><a href="https://doc.rust-lang.org/book/first-edition/variable-bindings.html" tabindex="0"><strong aria-hidden="true">3.1.</strong> Variable Bindings</a></li><li><a href="https://doc.rust-lang.org/book/first-edition/functions.html" tabindex="0"><strong aria-hidden="true">3.2.</strong> Functions</a></li><li><a href="https://doc.rust-lang.org/book/first-edition/primitive-types.html" class="active" tabindex="0"><strong aria-hidden="true">3.3.</strong> Primitive Types</a></li><li><a href="https://doc.rust-lang.org/book/first-edition/comments.html" tabindex="0"><strong aria-hidden="true">3.4.</strong> Comments</a></li><li><a href="https://doc.rust-lang.org/book/first-edition/if.html" tabindex="0"><strong aria-hidden="true">3.5.</strong> if</a></li><li><a href="https://doc.rust-lang.org/book/first-edition/loops.html" tabindex="0"><strong aria-hidden="true">3.6.</strong> Loops</a></li><li><a href="https://doc.rust-lang.org/book/first-edition/vectors.html" tabindex="0"><strong aria-hidden="true">3.7.</strong> Vectors</a></li><li><a href="https://doc.rust-lang.org/book/first-edition/ownership.html" tabindex="0"><strong aria-hidden="true">3.8.</strong> Ownership</a></li><li><a href="https://doc.rust-lang.org/book/first-edition/references-and-borrowing.html" tabindex="0"><strong aria-hidden="true">3.9.</strong> References and Borrowing</a></li><li><a href="https://doc.rust-lang.org/book/first-edition/lifetimes.html" tabindex="0"><strong aria-hidden="true">3.10.</strong> Lifetimes</a></li><li><a href="https://doc.rust-lang.org/book/first-edition/mutability.html" tabindex="0"><strong aria-hidden="true">3.11.</strong> Mutability</a></li><li><a href="https://doc.rust-lang.org/book/first-edition/structs.html" tabindex="0"><strong aria-hidden="true">3.12.</strong> Structs</a></li><li><a href="https://doc.rust-lang.org/book/first-edition/enums.html" tabindex="0"><strong aria-hidden="true">3.13.</strong> Enums</a></li><li><a href="https://doc.rust-lang.org/book/first-edition/match.html" tabindex="0"><strong aria-hidden="true">3.14.</strong> Match</a></li><li><a href="https://doc.rust-lang.org/book/first-edition/patterns.html" tabindex="0"><strong aria-hidden="true">3.15.</strong> Patterns</a></li><li><a href="https://doc.rust-lang.org/book/first-edition/method-syntax.html" tabindex="0"><strong aria-hidden="true">3.16.</strong> Method Syntax</a></li><li><a href="https://doc.rust-lang.org/book/first-edition/strings.html" tabindex="0"><strong aria-hidden="true">3.17.</strong> Strings</a></li><li><a href="https://doc.rust-lang.org/book/first-edition/generics.html" tabindex="0"><strong aria-hidden="true">3.18.</strong> Generics</a></li><li><a href="https://doc.rust-lang.org/book/first-edition/traits.html" tabindex="0"><strong aria-hidden="true">3.19.</strong> Traits</a></li><li><a href="https://doc.rust-lang.org/book/first-edition/drop.html" tabindex="0"><strong aria-hidden="true">3.20.</strong> Drop</a></li><li><a href="https://doc.rust-lang.org/book/first-edition/if-let.html" tabindex="0"><strong aria-hidden="true">3.21.</strong> if let</a></li><li><a href="https://doc.rust-lang.org/book/first-edition/trait-objects.html" tabindex="0"><strong aria-hidden="true">3.22.</strong> Trait Objects</a></li><li><a href="https://doc.rust-lang.org/book/first-edition/closures.html" tabindex="0"><strong aria-hidden="true">3.23.</strong> Closures</a></li><li><a href="https://doc.rust-lang.org/book/first-edition/ufcs.html" tabindex="0"><strong aria-hidden="true">3.24.</strong> Universal Function Call Syntax</a></li><li><a href="https://doc.rust-lang.org/book/first-edition/crates-and-modules.html" tabindex="0"><strong aria-hidden="true">3.25.</strong> Crates and Modules</a></li><li><a href="https://doc.rust-lang.org/book/first-edition/const-and-static.html" tabindex="0"><strong aria-hidden="true">3.26.</strong> const and static</a></li><li><a href="https://doc.rust-lang.org/book/first-edition/attributes.html" tabindex="0"><strong aria-hidden="true">3.27.</strong> Attributes</a></li><li><a href="https://doc.rust-lang.org/book/first-edition/type-aliases.html" tabindex="0"><strong aria-hidden="true">3.28.</strong> type aliases</a></li><li><a href="https://doc.rust-lang.org/book/first-edition/casting-between-types.html" tabindex="0"><strong aria-hidden="true">3.29.</strong> Casting between types</a></li><li><a href="https://doc.rust-lang.org/book/first-edition/associated-types.html" tabindex="0"><strong aria-hidden="true">3.30.</strong> Associated Types</a></li><li><a href="https://doc.rust-lang.org/book/first-edition/unsized-types.html" tabindex="0"><strong aria-hidden="true">3.31.</strong> Unsized Types</a></li><li><a href="https://doc.rust-lang.org/book/first-edition/operators-and-overloading.html" tabindex="0"><strong aria-hidden="true">3.32.</strong> Operators and Overloading</a></li><li><a href="https://doc.rust-lang.org/book/first-edition/deref-coercions.html" tabindex="0"><strong aria-hidden="true">3.33.</strong> Deref coercions</a></li><li><a href="https://doc.rust-lang.org/book/first-edition/macros.html" tabindex="0"><strong aria-hidden="true">3.34.</strong> Macros</a></li><li><a href="https://doc.rust-lang.org/book/first-edition/raw-pointers.html" tabindex="0"><strong aria-hidden="true">3.35.</strong> Raw Pointers</a></li><li><a href="https://doc.rust-lang.org/book/first-edition/unsafe.html" tabindex="0"><strong aria-hidden="true">3.36.</strong> unsafe</a></li></ol></li><li><a href="https://doc.rust-lang.org/book/first-edition/effective-rust.html" tabindex="0"><strong aria-hidden="true">4.</strong> Effective Rust</a></li><li><ol class="section"><li><a href="https://doc.rust-lang.org/book/first-edition/the-stack-and-the-heap.html" tabindex="0"><strong aria-hidden="true">4.1.</strong> The Stack and the Heap</a></li><li><a href="https://doc.rust-lang.org/book/first-edition/testing.html" tabindex="0"><strong aria-hidden="true">4.2.</strong> Testing</a></li><li><a href="https://doc.rust-lang.org/book/first-edition/conditional-compilation.html" tabindex="0"><strong aria-hidden="true">4.3.</strong> Conditional Compilation</a></li><li><a href="https://doc.rust-lang.org/book/first-edition/documentation.html" tabindex="0"><strong aria-hidden="true">4.4.</strong> Documentation</a></li><li><a href="https://doc.rust-lang.org/book/first-edition/iterators.html" tabindex="0"><strong aria-hidden="true">4.5.</strong> Iterators</a></li><li><a href="https://doc.rust-lang.org/book/first-edition/concurrency.html" tabindex="0"><strong aria-hidden="true">4.6.</strong> Concurrency</a></li><li><a href="https://doc.rust-lang.org/book/first-edition/error-handling.html" tabindex="0"><strong aria-hidden="true">4.7.</strong> Error Handling</a></li><li><a href="https://doc.rust-lang.org/book/first-edition/choosing-your-guarantees.html" tabindex="0"><strong aria-hidden="true">4.8.</strong> Choosing your Guarantees</a></li><li><a href="https://doc.rust-lang.org/book/first-edition/ffi.html" tabindex="0"><strong aria-hidden="true">4.9.</strong> FFI</a></li><li><a href="https://doc.rust-lang.org/book/first-edition/borrow-and-asref.html" tabindex="0"><strong aria-hidden="true">4.10.</strong> Borrow and AsRef</a></li><li><a href="https://doc.rust-lang.org/book/first-edition/release-channels.html" tabindex="0"><strong aria-hidden="true">4.11.</strong> Release Channels</a></li><li><a href="https://doc.rust-lang.org/book/first-edition/using-rust-without-the-standard-library.html" tabindex="0"><strong aria-hidden="true">4.12.</strong> Using Rust without the standard library</a></li><li><a href="https://doc.rust-lang.org/book/first-edition/procedural-macros.html" tabindex="0"><strong aria-hidden="true">4.13.</strong> Procedural Macros (and custom derive)</a></li></ol></li><li><a href="https://doc.rust-lang.org/book/first-edition/glossary.html" tabindex="0"><strong aria-hidden="true">5.</strong> Glossary</a></li><li><a href="https://doc.rust-lang.org/book/first-edition/syntax-index.html" tabindex="0"><strong aria-hidden="true">6.</strong> Syntax Index</a></li><li><a href="https://doc.rust-lang.org/book/first-edition/bibliography.html" tabindex="0"><strong aria-hidden="true">7.</strong> Bibliography</a></li></ol>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="draft-warning" class="warning">
    <span class="message">You are reading an <strong>outdated</strong> edition of TRPL. For more, go <a href="https://doc.rust-lang.org/book/index.html">here</a>.</span>
    <button type="button" id="hide-draft-warning" title="Hide draft warning" class="button">
        <i class="fa fa-times"></i>
    </button>
</div>
<!-- Hide / unhide warning before it is displayed -->
<script type="text/javascript">
var warning = localStorage.getItem('trpl-first-edition-draft-warning');

if (warning === 'hidden') {
    Array
    .from(document.querySelectorAll('#page-wrapper'))
    .forEach(function(block) { block.classList.remove('has-warning'); });
    var elem = document.getElementById("draft-warning");
    elem.parentNode.removeChild(elem);
}

document.addEventListener("DOMContentLoaded", function(event) { 
    document.getElementById("hide-draft-warning").addEventListener("click", function(e) {
        var elem = document.getElementById("draft-warning");
        elem.parentNode.removeChild(elem);

        localStorage.setItem('trpl-first-edition-draft-warning', 'hidden');
    });
});
</script>

                <div id="menu-bar" class="menu-bar">
                    <div id="menu-bar-sticky-container">
                        <div class="left-buttons">
                            <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar" aria-expanded="true">
                                <i class="fa fa-bars"></i>
                            </button>
                            <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                                <i class="fa fa-paint-brush"></i>
                            </button>
                            <ul id="theme-list" class="theme-popup" aria-label="submenu">
                                <li><button class="theme" id="light">Light <span class="default">(default)</span></button></li>
                                <li><button class="theme" id="rust">Rust</button></li>
                                <li><button class="theme" id="coal">Coal</button></li>
                                <li><button class="theme" id="navy">Navy</button></li>
                                <li><button class="theme" id="ayu">Ayu</button></li>
                            </ul>
                        </div>

                        <h1 class="menu-title">The Rust Programming Language</h1>

                        <div class="right-buttons">
                            <a href="https://doc.rust-lang.org/book/first-edition/print.html" title="Print this book" aria-label="Print this book">
                                <i id="print-button" class="fa fa-print"></i>
                            </a>
                        </div>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <a class="header" href="https://doc.rust-lang.org/book/first-edition/primitive-types.html#primitive-types" id="primitive-types"><h1>Primitive Types</h1></a>
<p>The Rust language has a number of types that are considered ‘primitive’. This
means that they’re built-in to the language. Rust is structured in such a way
that the standard library also provides a number of useful types built on top
of these ones, as well, but these are the most primitive.</p>
<a class="header" href="https://doc.rust-lang.org/book/first-edition/primitive-types.html#booleans" id="booleans"><h1>Booleans</h1></a>
<p>Rust has a built-in boolean type, named <code class="hljs">bool</code>. It has two values, <code class="hljs">true</code> and <code class="hljs">false</code>:</p>
<pre><pre class="playpen"><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button><button class="fa fa-play play-button" title="Run this code" aria-label="Run this code" hidden=""></button><button class="fa fa-expand" title="Show hidden lines" aria-label="Show hidden lines"></button></div><code class="language-rust hljs"><span class="hidden">
<span class="hljs-meta">#![allow(unused_variables)]</span></span><span class="hidden">
<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() {</span>
<span class="hljs-keyword">let</span> x = <span class="hljs-literal">true</span>;

<span class="hljs-keyword">let</span> y: <span class="hljs-built_in">bool</span> = <span class="hljs-literal">false</span>;<span class="hidden">
}</span></code></pre></pre>
<p>A common use of booleans is in <a href="https://doc.rust-lang.org/book/first-edition/if.html"><code class="hljs">if</code> conditionals</a>.</p>
<p>You can find more documentation for <code class="hljs">bool</code>s <a href="https://doc.rust-lang.org/std/primitive.bool.html">in the standard library
documentation</a>.</p>
<a class="header" href="https://doc.rust-lang.org/book/first-edition/primitive-types.html#char" id="char"><h1><code class="hljs">char</code></h1></a>
<p>The <code class="hljs">char</code> type represents a single Unicode scalar value. You can create <code class="hljs">char</code>s
with a single tick: (<code class="hljs">'</code>)</p>
<pre><pre class="playpen"><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button><button class="fa fa-play play-button" title="Run this code" aria-label="Run this code" hidden=""></button><button class="fa fa-expand" title="Show hidden lines" aria-label="Show hidden lines"></button></div><code class="language-rust hljs"><span class="hidden">
<span class="hljs-meta">#![allow(unused_variables)]</span></span><span class="hidden">
<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() {</span>
<span class="hljs-keyword">let</span> x = <span class="hljs-string">'x'</span>;
<span class="hljs-keyword">let</span> two_hearts = '💕';<span class="hidden">
}</span></code></pre></pre>
<p>Unlike some other languages, this means that Rust’s <code class="hljs">char</code> is not a single byte,
but four.</p>
<p>You can find more documentation for <code class="hljs">char</code>s <a href="https://doc.rust-lang.org/std/primitive.char.html">in the standard library
documentation</a>.</p>
<a class="header" href="https://doc.rust-lang.org/book/first-edition/primitive-types.html#numeric-types" id="numeric-types"><h1>Numeric types</h1></a>
<p>Rust has a variety of numeric types in a few categories: signed and unsigned,
fixed and variable, floating-point and integer.</p>
<p>These types consist of two parts: the category, and the size. For example,
<code class="hljs">u16</code> is an unsigned type with sixteen bits of size. More bits lets you have
bigger numbers.</p>
<p>If a number literal has nothing to cause its type to be inferred, it defaults:</p>
<pre><pre class="playpen"><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button><button class="fa fa-play play-button" title="Run this code" aria-label="Run this code" hidden=""></button><button class="fa fa-expand" title="Show hidden lines" aria-label="Show hidden lines"></button></div><code class="language-rust hljs"><span class="hidden">
<span class="hljs-meta">#![allow(unused_variables)]</span></span><span class="hidden">
<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() {</span>
<span class="hljs-keyword">let</span> x = <span class="hljs-number">42</span>; <span class="hljs-comment">// `x` has type `i32`.</span>

<span class="hljs-keyword">let</span> y = <span class="hljs-number">1.0</span>; <span class="hljs-comment">// `y` has type `f64`.</span><span class="hidden">
}</span></code></pre></pre>
<p>Here’s a list of the different numeric types, with links to their documentation
in the standard library:</p>
<ul>
<li><a href="https://doc.rust-lang.org/std/primitive.i8.html">i8</a></li>
<li><a href="https://doc.rust-lang.org/std/primitive.i16.html">i16</a></li>
<li><a href="https://doc.rust-lang.org/std/primitive.i32.html">i32</a></li>
<li><a href="https://doc.rust-lang.org/std/primitive.i64.html">i64</a></li>
<li><a href="https://doc.rust-lang.org/std/primitive.u8.html">u8</a></li>
<li><a href="https://doc.rust-lang.org/std/primitive.u16.html">u16</a></li>
<li><a href="https://doc.rust-lang.org/std/primitive.u32.html">u32</a></li>
<li><a href="https://doc.rust-lang.org/std/primitive.u64.html">u64</a></li>
<li><a href="https://doc.rust-lang.org/std/primitive.isize.html">isize</a></li>
<li><a href="https://doc.rust-lang.org/std/primitive.usize.html">usize</a></li>
<li><a href="https://doc.rust-lang.org/std/primitive.f32.html">f32</a></li>
<li><a href="https://doc.rust-lang.org/std/primitive.f64.html">f64</a></li>
</ul>
<p>Let’s go over them by category:</p>
<a class="header" href="https://doc.rust-lang.org/book/first-edition/primitive-types.html#signed-and-unsigned" id="signed-and-unsigned"><h2>Signed and Unsigned</h2></a>
<p>Integer types come in two varieties: signed and unsigned. To understand the
difference, let’s consider a number with four bits of size. A signed, four-bit
number would let you store numbers from <code class="hljs">-8</code> to <code class="hljs">+7</code>. Signed numbers use
“two’s complement representation”. An unsigned four bit number, since it does
not need to store negatives, can store values from <code class="hljs">0</code> to <code class="hljs">+15</code>.</p>
<p>Unsigned types use a <code class="hljs">u</code> for their category, and signed types use <code class="hljs">i</code>. The <code class="hljs">i</code>
is for ‘integer’. So <code class="hljs">u8</code> is an eight-bit unsigned number, and <code class="hljs">i8</code> is an
eight-bit signed number.</p>
<a class="header" href="https://doc.rust-lang.org/book/first-edition/primitive-types.html#fixed-size-types" id="fixed-size-types"><h2>Fixed-size types</h2></a>
<p>Fixed-size types have a specific number of bits in their representation. Valid
bit sizes are <code class="hljs">8</code>, <code class="hljs">16</code>, <code class="hljs">32</code>, and <code class="hljs">64</code>. So, <code class="hljs">u32</code> is an unsigned, 32-bit integer,
and <code class="hljs">i64</code> is a signed, 64-bit integer.</p>
<a class="header" href="https://doc.rust-lang.org/book/first-edition/primitive-types.html#variable-size-types" id="variable-size-types"><h2>Variable-size types</h2></a>
<p>Rust also provides types whose particular size depends on the underlying machine
architecture. Their range is sufficient to express the size of any collection, so
these types have ‘size’ as the category. They come in signed and unsigned varieties
which account for two types: <code class="hljs">isize</code> and <code class="hljs">usize</code>.</p>
<a class="header" href="https://doc.rust-lang.org/book/first-edition/primitive-types.html#floating-point-types" id="floating-point-types"><h2>Floating-point types</h2></a>
<p>Rust also has two floating point types: <code class="hljs">f32</code> and <code class="hljs">f64</code>. These correspond to
IEEE-754 single and double precision numbers.</p>
<a class="header" href="https://doc.rust-lang.org/book/first-edition/primitive-types.html#arrays" id="arrays"><h1>Arrays</h1></a>
<p>Like many programming languages, Rust has list types to represent a sequence of
things. The most basic is the <em>array</em>, a fixed-size list of elements of the
same type. By default, arrays are immutable.</p>
<pre><pre class="playpen"><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button><button class="fa fa-play play-button" title="Run this code" aria-label="Run this code" hidden=""></button><button class="fa fa-expand" title="Show hidden lines" aria-label="Show hidden lines"></button></div><code class="language-rust hljs"><span class="hidden">
<span class="hljs-meta">#![allow(unused_variables)]</span></span><span class="hidden">
<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() {</span>
<span class="hljs-keyword">let</span> a = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]; <span class="hljs-comment">// a: [i32; 3]</span>
<span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> m = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]; <span class="hljs-comment">// m: [i32; 3]</span><span class="hidden">
}</span></code></pre></pre>
<p>Arrays have type <code class="hljs">[T; N]</code>. We’ll talk about this <code class="hljs">T</code> notation <a href="https://doc.rust-lang.org/book/first-edition/generics.html">in the generics
section</a>. The <code class="hljs">N</code> is a compile-time constant, for the length of the
array.</p>
<p>There’s a shorthand for initializing each element of an array to the same
value. In this example, each element of <code class="hljs">a</code> will be initialized to <code class="hljs">0</code>:</p>
<pre><pre class="playpen"><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button><button class="fa fa-play play-button" title="Run this code" aria-label="Run this code" hidden=""></button><button class="fa fa-expand" title="Show hidden lines" aria-label="Show hidden lines"></button></div><code class="language-rust hljs"><span class="hidden">
<span class="hljs-meta">#![allow(unused_variables)]</span></span><span class="hidden">
<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() {</span>
<span class="hljs-keyword">let</span> a = [<span class="hljs-number">0</span>; <span class="hljs-number">20</span>]; <span class="hljs-comment">// a: [i32; 20]</span><span class="hidden">
}</span></code></pre></pre>
<p>You can get the number of elements in an array <code class="hljs">a</code> with <code class="hljs">a.len()</code>:</p>
<pre><pre class="playpen"><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button><button class="fa fa-play play-button" title="Run this code" aria-label="Run this code" hidden=""></button><button class="fa fa-expand" title="Show hidden lines" aria-label="Show hidden lines"></button></div><code class="language-rust hljs"><span class="hidden">
<span class="hljs-meta">#![allow(unused_variables)]</span></span><span class="hidden">
<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() {</span>
<span class="hljs-keyword">let</span> a = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];

<span class="hljs-built_in">println!</span>(<span class="hljs-string">"a has {} elements"</span>, a.len());<span class="hidden">
}</span></code></pre></pre>
<p>You can access a particular element of an array with <em>subscript notation</em>:</p>
<pre><pre class="playpen"><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button><button class="fa fa-play play-button" title="Run this code" aria-label="Run this code" hidden=""></button><button class="fa fa-expand" title="Show hidden lines" aria-label="Show hidden lines"></button></div><code class="language-rust hljs"><span class="hidden">
<span class="hljs-meta">#![allow(unused_variables)]</span></span><span class="hidden">
<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() {</span>
<span class="hljs-keyword">let</span> names = [<span class="hljs-string">"Graydon"</span>, <span class="hljs-string">"Brian"</span>, <span class="hljs-string">"Niko"</span>]; <span class="hljs-comment">// names: [&amp;str; 3]</span>

<span class="hljs-built_in">println!</span>(<span class="hljs-string">"The second name is: {}"</span>, names[<span class="hljs-number">1</span>]);<span class="hidden">
}</span></code></pre></pre>
<p>Subscripts start at zero, like in most programming languages, so the first name
is <code class="hljs">names[0]</code> and the second name is <code class="hljs">names[1]</code>. The above example prints
<code class="hljs">The second name is: Brian</code>. If you try to use a subscript that is not in the
array, you will get an error: array access is bounds-checked at run-time. Such
errant access is the source of many bugs in other systems programming
languages.</p>
<p>You can find more documentation for <code class="hljs">array</code>s <a href="https://doc.rust-lang.org/std/primitive.array.html">in the standard library
documentation</a>.</p>
<a class="header" href="https://doc.rust-lang.org/book/first-edition/primitive-types.html#slices" id="slices"><h1>Slices</h1></a>
<p>A ‘slice’ is a reference to (or “view” into) another data structure. They are
useful for allowing safe, efficient access to a portion of an array without
copying. For example, you might want to reference only one line of a file read
into memory. By nature, a slice is not created directly, but from an existing
variable binding. Slices have a defined length, and can be mutable or immutable.</p>
<p>Internally, slices are represented as a pointer to the beginning of the data
and a length.</p>
<a class="header" href="https://doc.rust-lang.org/book/first-edition/primitive-types.html#slicing-syntax" id="slicing-syntax"><h2>Slicing syntax</h2></a>
<p>You can use a combo of <code class="hljs">&amp;</code> and <code class="hljs">[]</code> to create a slice from various things. The
<code class="hljs">&amp;</code> indicates that slices are similar to <a href="https://doc.rust-lang.org/book/first-edition/references-and-borrowing.html">references</a>, which we will cover in
detail later in this section. The <code class="hljs">[]</code>s, with a range, let you define the
length of the slice:</p>
<pre><pre class="playpen"><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button><button class="fa fa-play play-button" title="Run this code" aria-label="Run this code" hidden=""></button><button class="fa fa-expand" title="Show hidden lines" aria-label="Show hidden lines"></button></div><code class="language-rust hljs"><span class="hidden">
<span class="hljs-meta">#![allow(unused_variables)]</span></span><span class="hidden">
<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() {</span>
<span class="hljs-keyword">let</span> a = [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>];
<span class="hljs-keyword">let</span> complete = &amp;a[..]; <span class="hljs-comment">// A slice containing all of the elements in `a`.</span>
<span class="hljs-keyword">let</span> middle = &amp;a[<span class="hljs-number">1</span>..<span class="hljs-number">4</span>]; <span class="hljs-comment">// A slice of `a`: only the elements `1`, `2`, and `3`.</span><span class="hidden">
}</span></code></pre></pre>
<p>Slices have type <code class="hljs">&amp;[T]</code>. We’ll talk about that <code class="hljs">T</code> when we cover
<a href="https://doc.rust-lang.org/book/first-edition/generics.html">generics</a>.</p>
<p>You can find more documentation for slices <a href="https://doc.rust-lang.org/std/primitive.slice.html">in the standard library
documentation</a>.</p>
<a class="header" href="https://doc.rust-lang.org/book/first-edition/primitive-types.html#str" id="str"><h1><code class="hljs">str</code></h1></a>
<p>Rust’s <code class="hljs">str</code> type is the most primitive string type. As an <a href="https://doc.rust-lang.org/book/first-edition/unsized-types.html">unsized type</a>,
it’s not very useful by itself, but becomes useful when placed behind a
reference, like <code class="hljs">&amp;str</code>. We'll elaborate further when we cover
<a href="https://doc.rust-lang.org/book/first-edition/strings.html">Strings</a> and <a href="https://doc.rust-lang.org/book/first-edition/references-and-borrowing.html">references</a>.</p>
<p>You can find more documentation for <code class="hljs">str</code> <a href="https://doc.rust-lang.org/std/primitive.str.html">in the standard library
documentation</a>.</p>
<a class="header" href="https://doc.rust-lang.org/book/first-edition/primitive-types.html#tuples" id="tuples"><h1>Tuples</h1></a>
<p>A tuple is an ordered list of fixed size. Like this:</p>
<pre><pre class="playpen"><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button><button class="fa fa-play play-button" title="Run this code" aria-label="Run this code" hidden=""></button><button class="fa fa-expand" title="Show hidden lines" aria-label="Show hidden lines"></button></div><code class="language-rust hljs"><span class="hidden">
<span class="hljs-meta">#![allow(unused_variables)]</span></span><span class="hidden">
<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() {</span>
<span class="hljs-keyword">let</span> x = (<span class="hljs-number">1</span>, <span class="hljs-string">"hello"</span>);<span class="hidden">
}</span></code></pre></pre>
<p>The parentheses and commas form this two-length tuple. Here’s the same code, but
with the type annotated:</p>
<pre><pre class="playpen"><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button><button class="fa fa-play play-button" title="Run this code" aria-label="Run this code" hidden=""></button><button class="fa fa-expand" title="Show hidden lines" aria-label="Show hidden lines"></button></div><code class="language-rust hljs"><span class="hidden">
<span class="hljs-meta">#![allow(unused_variables)]</span></span><span class="hidden">
<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() {</span>
<span class="hljs-keyword">let</span> x: (<span class="hljs-built_in">i32</span>, &amp;<span class="hljs-built_in">str</span>) = (<span class="hljs-number">1</span>, <span class="hljs-string">"hello"</span>);<span class="hidden">
}</span></code></pre></pre>
<p>As you can see, the type of a tuple looks like the tuple, but with each
position having a type name rather than the value. Careful readers will also
note that tuples are heterogeneous: we have an <code class="hljs">i32</code> and a <code class="hljs">&amp;str</code> in this tuple.
In systems programming languages, strings are a bit more complex than in other
languages. For now, read <code class="hljs">&amp;str</code> as a <em>string slice</em>, and we’ll learn more
soon.</p>
<p>You can assign one tuple into another, if they have the same contained types
and <a href="https://doc.rust-lang.org/book/first-edition/glossary.html#arity">arity</a>. Tuples have the same arity when they have the same length.</p>
<pre><pre class="playpen"><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button><button class="fa fa-play play-button" title="Run this code" aria-label="Run this code" hidden=""></button><button class="fa fa-expand" title="Show hidden lines" aria-label="Show hidden lines"></button></div><code class="language-rust hljs"><span class="hidden">
<span class="hljs-meta">#![allow(unused_variables)]</span></span><span class="hidden">
<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() {</span>
<span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> x = (<span class="hljs-number">1</span>, <span class="hljs-number">2</span>); <span class="hljs-comment">// x: (i32, i32)</span>
<span class="hljs-keyword">let</span> y = (<span class="hljs-number">2</span>, <span class="hljs-number">3</span>); <span class="hljs-comment">// y: (i32, i32)</span>

x = y;<span class="hidden">
}</span></code></pre></pre>
<p>You can access the fields in a tuple through a <em>destructuring let</em>. Here’s
an example:</p>
<pre><pre class="playpen"><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button><button class="fa fa-play play-button" title="Run this code" aria-label="Run this code" hidden=""></button><button class="fa fa-expand" title="Show hidden lines" aria-label="Show hidden lines"></button></div><code class="language-rust hljs"><span class="hidden">
<span class="hljs-meta">#![allow(unused_variables)]</span></span><span class="hidden">
<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() {</span>
<span class="hljs-keyword">let</span> (x, y, z) = (<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>);

<span class="hljs-built_in">println!</span>(<span class="hljs-string">"x is {}"</span>, x);<span class="hidden">
}</span></code></pre></pre>
<p>Remember <a href="https://doc.rust-lang.org/book/first-edition/variable-bindings.html">before</a> when I said the left-hand side of a <code class="hljs">let</code> statement was more
powerful than assigning a binding? Here we are. We can put a pattern on
the left-hand side of the <code class="hljs">let</code>, and if it matches up to the right-hand side,
we can assign multiple bindings at once. In this case, <code class="hljs">let</code> “destructures”
or “breaks up” the tuple, and assigns the bits to three bindings.</p>
<p>This pattern is very powerful, and we’ll see it repeated more later.</p>
<p>You can disambiguate a single-element tuple from a value in parentheses with a
comma:</p>
<pre><pre class="playpen"><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button><button class="fa fa-play play-button" title="Run this code" aria-label="Run this code" hidden=""></button><button class="fa fa-expand" title="Show hidden lines" aria-label="Show hidden lines"></button></div><code class="language-rust hljs"><span class="hidden">
<span class="hljs-meta">#![allow(unused_variables)]</span></span><span class="hidden">
<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() {</span>
(<span class="hljs-number">0</span>,); <span class="hljs-comment">// A single-element tuple.</span>
(<span class="hljs-number">0</span>); <span class="hljs-comment">// A zero in parentheses.</span><span class="hidden">
}</span></code></pre></pre>
<a class="header" href="https://doc.rust-lang.org/book/first-edition/primitive-types.html#tuple-indexing" id="tuple-indexing"><h2>Tuple Indexing</h2></a>
<p>You can also access fields of a tuple with indexing syntax:</p>
<pre><pre class="playpen"><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button><button class="fa fa-play play-button" title="Run this code" aria-label="Run this code" hidden=""></button><button class="fa fa-expand" title="Show hidden lines" aria-label="Show hidden lines"></button></div><code class="language-rust hljs"><span class="hidden">
<span class="hljs-meta">#![allow(unused_variables)]</span></span><span class="hidden">
<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() {</span>
<span class="hljs-keyword">let</span> tuple = (<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>);

<span class="hljs-keyword">let</span> x = tuple.<span class="hljs-number">0</span>;
<span class="hljs-keyword">let</span> y = tuple.<span class="hljs-number">1</span>;
<span class="hljs-keyword">let</span> z = tuple.<span class="hljs-number">2</span>;

<span class="hljs-built_in">println!</span>(<span class="hljs-string">"x is {}"</span>, x);<span class="hidden">
}</span></code></pre></pre>
<p>Like array indexing, it starts at zero, but unlike array indexing, it uses a
<code class="hljs">.</code>, rather than <code class="hljs">[]</code>s.</p>
<p>You can find more documentation for tuples <a href="https://doc.rust-lang.org/std/primitive.tuple.html">in the standard library
documentation</a>.</p>
<a class="header" href="https://doc.rust-lang.org/book/first-edition/primitive-types.html#functions" id="functions"><h1>Functions</h1></a>
<p>Functions also have a type! They look like this:</p>
<pre><pre class="playpen"><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button><button class="fa fa-play play-button" title="Run this code" aria-label="Run this code" hidden=""></button><button class="fa fa-expand" title="Show hidden lines" aria-label="Show hidden lines"></button></div><code class="language-rust hljs"><span class="hidden">
<span class="hljs-meta">#![allow(unused_variables)]</span></span><span class="hidden">
<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() {</span>
<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">foo</span></span>(x: <span class="hljs-built_in">i32</span>) -&gt; <span class="hljs-built_in">i32</span> { x }

<span class="hljs-keyword">let</span> x: <span class="hljs-function"><span class="hljs-keyword">fn</span></span>(<span class="hljs-built_in">i32</span>) -&gt; <span class="hljs-built_in">i32</span> = foo;<span class="hidden">
}</span></code></pre></pre>
<p>In this case, <code class="hljs">x</code> is a ‘function pointer’ to a function that takes an <code class="hljs">i32</code> and
returns an <code class="hljs">i32</code>.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        
                            <a rel="prev" href="https://doc.rust-lang.org/book/first-edition/functions.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                        

                        
                            <a rel="next" href="https://doc.rust-lang.org/book/first-edition/comments.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                
                    <a href="https://doc.rust-lang.org/book/first-edition/functions.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                

                
                    <a href="https://doc.rust-lang.org/book/first-edition/comments.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
                
            </nav>

        </div>


        <!-- Local fallback for Font Awesome -->
        <script>
            if (getComputedStyle(document.querySelector(".fa")).fontFamily !== "FontAwesome") {
                var link = document.createElement('link');
                link.rel = 'stylesheet';
                link.type = 'text/css';
                link.href = '_FontAwesome/css/font-awesome.css';
                document.head.insertBefore(link, document.head.firstChild)
            }
        </script>

        

        

        

        

        <script src="Rusg-Dateien/highlight.js"></script>
        <script src="Rusg-Dateien/book.js"></script>

        <!-- Custom JS script -->
        

    

</body></html>