
\chapter{Systementwurf}

In diesem Kapitel wird eine Entwurf für die Implementation des Systems aufgezeigt.
Die Struktur des Systems wird durch einen Architekturentwurf visualisiert und die zu verwendeten Technologien erläutert.

\section{Kein ASN.1 Compiler für Rust}

Eine frühe Recherche hat ergeben, dass kein ASN.1 Compiler für Rust verfügbar ist.
Mit \textit{yasna}, \textit{raisin} und \textit{rust-asn1} sind ASN.1 Crates für Rust vorhanden, aber keine kann die benötigte UPER Codierung.
Auch kann keine der genannten Crates die in ASN.1 Notation definierten Nachrichten in native Rust Datenstrukturen übersetzten.
Die von der ITU genannten Compiler\footnote{\url{https://www.itu.int/en/ITU-T/asn1/Pages/Tools.aspx}} unterstützen Rust auch nicht.
Dieser Umstand erzwingt die Nutzung der C-Datenstrukturen, wie die Referenzimplementierung, mittels \gls{ffi} (siehe \autoref{rust:ffi}).
Zur besseren Kapselung ist die Einbindung der ASN.1 Nachrichten deswegen in mehreren Schritten in zwei Crates ausgelagert.

\section{Framework Tokio}
\label{design:tokio}

Das Framework Tokio wird als Grundlage für die Umsetzung der Architektur genutzt.
Tokio\footnote{\url{https://crates.io/crates/tokio}} bietet eine \enquote{Laufzeit zum schreiben von zuverlässigen, asynchrone und schlanke Anwendungen in Rust} \cite{rust:crate:tokio}.

Tokio nutzt die Crates \textit{mio} und \textit{Future} um eine ereignisorientierte, asynchrone und daher nicht blockierende Ein-/Ausgabeplattform zu bieten.
Bearbeitungsschritte sind in \enquote{Futures} (dt. Zukunft, hier in etwa: \enquote{ein zukünftiger Wert}) aneinandergereiht und verpackt.

Neben den genannten technischen Funktionen ist hervorzuheben, dass das Framework von vielen Entwicklern aus dem Rust-Entwicklerteam mindestens mitentwickelt wird\footnote{u.a. Alex Crichton, Carl Lerche, Aaron Turon: \url{https://github.com/tokio-rs/tokio/graphs/contributors}}.
Aufgrund dessen ist ein hoher Grad an Qualität und Aktualität des Frameworks zu erwarten.
%Daher ist ein höherer Grad an Vertrauen in Qualität, Funktionstüchtigkeit und Aktualität gegeben.

%\section{Rust Version 1.26}
%\todo{nötig? impl ..., }


\section{Architektur}
		
In \autoref{draft:architecture} ist der Entwurf der Architektur visualisiert.
Blau markierte Objekte haben als Aufgabengebiet die Kommunikation, grün markierte Objekte bilden die Geschäftslogik ab und rot markierte Objekte sind Spezialisierungen für ASN.1.


\begin{figure}[H]
	\centering
	\includegraphics[width=2.0\textwidth]{dia/architecture}
	\caption{Architekturentwurf}
	\label{draft:architecture}
\end{figure}

Die Implementation ist in drei Crates aufgeteilt:
\begin{itemize}
	\item \textbf{libmessages-sys}: Enthält bindings für die ASN.1 Datenstrukturen und Funktionen der C-Bibliothek (siehe \autoref{rust:ffi}).
	Unsichere Funktionsaufrufe nach C, wie zur Serialisierung und Deserialisierung, sind durch sichere Rust Funktionen gekapselt.
	Eine ordnungsgemäße Allokation und Deallokation der Nachrichten wird hier sichergestellt.
	
	\item \textbf{libmessages}: Stellt Datenstrukturen und Implementationen bereit um unabhängig von der eingesetzten Nachrichtentechnologie eine Nachricht abbilden zu können.
	Hierzu wird in \textit{RawMessage} der Kopf (siehe \autoref{analysis:messages}) und der binären Inhalt einer Nachricht dargestellt.
	
	Zusätzlich ist in dieser Crate für jede Verwendete Technologie (in dieser Bachelorarbeit nur ASN.1) die Wandlung zwischen einer \textit{RawMessage} und einer entsprechenden Datenstruktur implementiert sein.
	
	\item \textbf{MECViewServer}: Enthält die Logik für den Sensor, das Fahrzeug und den Algorithmus und bündelt sie mit der Kommunikationslogik zu einem ausführbaren Kompilat.
\end{itemize}

\subsubsection{Erklärung Server}

Der Server lädt zu beginn eine Algorithmus Implementation, öffnet einen TCP-Port und wartet auf dem daraus resultierenden \textit{TcpListener} auf neue Clients.
Jedem neuen Client wird eine Referenz auf den Algorithmus mitgegeben.

\subsubsection{Erklärung Client, Sensor und Vehicle}

Der Client hält eine Referenz auf einen Algorithmus und einen Adapter.
Im Falle eines \textit{Vehicle}s kann ein \textit{EnvironmentListener} am Algorithmus registriert werden um neue Umgebungsmodelle zu erhalten.
Im Falle eines \textit{Sensor}s kann ein \textit{CountListener} am Algorithmus registriert werden um über Änderungen bei der Anzahl der registrierten Fahrzeuge informiert zu werden.

\subsubsection{Erklärung Adapter}

Der Adapter bietet  Schnittstelle, damit eine Clientinstanz Nachrichten versenden kann, ohne die eingesetzte Nachrichtentechnologie zu kennen.
Hierzu wird der Clientinstanz Funktionen bereitgestellt, die von der Adapterimplementation in entsprechende Nachrichten übersetzt werden.

\subsubsection{Erklärung Mapper}

Der Mapper ruft für Empfangene Nachrichten der eingesetzten Nachrichtentechnologie Funktionen der Clientinstanz auf und agiert somit als Gegenstück zum Adapter.

\subsubsection{Erklärung Encoder / Decoder}

Der Encoder schreibt \textit{RawMessage}s auf den TCP-Datenstrom, während der Encoder \textit{RawMessage}s vom TCP-Datenstrom liest.
Hierzu wird eine Wandlung, wie in \autoref{analysis:messages} beschrieben, vorgenommen.

\subsubsection{Nachrichtentechnologie kapseln}

Innerhalb der MECViewServer Crate sollen möglichst wenige Klassen die eingesetzt Nachrichtentechnologie kennen.
Hierzu zählen die Algorithmus- (\textit{SampleAlgorithmus}), Mapper- und Adapterimplementationen (\textit{AsnAdapter}).
Dies ist unumgänglich, weil sowohl der eingesetzte Algorithmus, der Mapper und der Adapter Felder einer Nachricht sowohl lesen als auch schreiben muss.
Zudem muss der Server mindestens indirekt die eingesetzte Technologie kennen, um die richtigen und zueinander kompatiblen Algorithmus-, Mapper- und Adapterimplementation zu instantiieren.
Weitere Klassen agieren dagegen unabhängig von der eingesetzten Nachrichtentechnologie.

\subsection{Asynchrone Kommunikation}

Um ein Mehrkernsystem effizient zu nutzen, arbeiten einige Klassen asynchron zueinander.
Hierzu zählt der Server, der asynchron neue Verbindungen annimmt.
Die daraus resultierenden Clientinstanzen bearbeiteten asynchron eingehende Anfragen.
Letztendlich aktualisiert auch der Algorithmus asynchron zu den Clients und dem Server das Umfeldmodell.

Das \enquote{Channel Architektur Pattern} \cite[167]{douglass2003real}, welches bereits von \textit{Tokio} (siehe \autoref{design:tokio}) verwendet wird, wird dies ermöglichen.

\todo{channel system dings da}



\begin{figure}[H]
	\centering
	\includegraphics[width=1.0\textwidth]{dia/design_decode_state}
	\caption{Channel physikalischer Client zu Clientinstanz}
	\label{design:channel}
\end{figure}


~\\ ~\\ ~\\






Ausgliederung von libmessages weil ASN-Bindings + weil von Protokolländerungen unabhängig sein soll

Prüfen tokio, queues, async + proxy pattern

Abbildung vereinfacht, Kommunikation via Queues im tokio context


\cite[446]{goll2012methoden}, example \cite[457]{goll2012methoden}

\todo{Component diagrams tikz-uml: server, algorithm, encoder/...}		

\section{Sequenzdiagramme}

\subsection{Low-Latency + Entwurfsmuster + Patterns? + Algorithmen?}
\todo{Hochperformant -> parallel?}

\todo{Design Pattern, Gamma et al, four important aspects}

\todo{Real Time Design Patterns Buch: Ab Seite 141, verschiedene Systempatterns, microkernel \cite[151]{douglass2003real}? channel architektur pattern \cite[167]{douglass2003real}?}

\todo{Message Queuing Pattern \cite[207]{douglass2003real}}

\todo{kein hartes Echtzeitsystem, gerade mal weiches Echtzeitsystem \autoref{real_time_system}}

\todo{Clean Architecture / Clean Code}