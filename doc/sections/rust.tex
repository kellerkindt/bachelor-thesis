
\chapter{Die Programmiersprache Rust}

Rust ist eine Programmiersprache, die versucht performant -- und daher durch Abstraktionen mit keinem zusätzlichen \enquote{Kosten} \todo{ref zero cost abstractions} -- sichere Programmierung zu ermöglichen.
Ziel ist eine \todo{Systemprogrammiersprache}, die sowohl sicher \todo{cite chapter} als auch performant ist und ohne eine Laufzeit ausgeführt werden kann.
Verschiedene Fehlerquellen -- wie \enquote{dangling pointers}, \enquote{double free} oder \enquote{memory leaks} \todo{ref} --  werden durch Abstraktionen und mit Hilfe des Kompilers verhindert.
Anders als Programmiersprachen, die dies mit Hilfe einer Laufzeit ermöglichen (zbsp. Java oder C\#), wird dies in Rust durch eine statische Analyse und einem Eigentümerprinzip bei der Kompilation gewährleistet.


\section{Geschichte}
\label{rust:history}

In 2006 \cite{rust:faq} begann Graydon Hoare die Programmiersprache Rust in seiner Freizeit als Hobbyprojekt zu entwickeln.
Als Grund nannte er seine Unzufriedenheit mit der Programmiersprache C++, in der es sehr schwierig sei, fehlerfreien, speichersicheren und nebenläufigen Code zu schreiben.
Zudem beschrieb er C++ als \enquote{ziemlich fehlerträchtig}. \cite{rust:heise_interview_graydon}

Auch Federico Mena-Quintero -- Mitbegründer des Gnome projekts \todo{cite \url{https://people.gnome.org/~federico/} or so} --
äußerte in einem Interview mit Golem im Juli 2017 seine Bedenken an der Verwendung der \enquote{feindseligen} Sprache C \cite{rust:c_is_hostile_golem}.
In Vorträgen \todo{nix mehrzahl?} vermittelt er seither, wie Bibliotheken durch Implementierungen in Rust ersetzt werden können \cite{rust:c_is_hostile_mena}.

Ab 2009 begann Mozilla die Weiterentwicklung finanziell zu fördern, da einfache Tests und die Kernprinzipien demonstriert werden konnten.
Die Entwicklung findet dabei öffentlich einsehbar auf GitHub unter \url{https://github.com/rust-lang/rust} statt und wird dabei nicht ausschließlich von Mozilla Angestellten koordiniert.
Die Stabilität des Kompilers trotz hoher Flexibilität während der Entwicklung wird dabei durch Unterscheidung von drei Veröffentlichungskanälen -- release, stable und nightly -- in Kombination mit automatisierten Tests \todo{ref?} gewährleistet. \cite{rust:faq}



\todo{hobbyprojekt, mozilla, open-source, Entwicklung auf GitHub - jeder kann sich beteiligen, test(coverage), automatisierte builds, stable/beta/nightly}

\section{Anwendungsgebiet}

Das Ziel von Rust ist es, das designen und implementieren sicheren, nebenläufig und auch praktisch tauglichen blubber zu machen \cite{rust:faq}.
\todo{intro paragraph}

Rust nutzt den \gls{llvm}-Kompiler und erbt daher auch eine große Anzahl an Zielplattformen für die Rust kompiliert werden kann.
Es wird aber zwischen drei Stufen unterschieden, bei denen verschieden stark ausgeprägte Garantien vergeben sind.
Es wird zwischen \enquote{Stufe 1: Funktioniert garantiert} (u.a. X86, X86-64), \enquote{Stufe 2: Kompiliert garantiert} (u.a. ARM, PowerPC, PowerPC-64) und \enquote{Stufe 3} (u. a. Thumb) unterschieden \cite{rust:platform_support}.
Diese Unterscheidung wirkt sich auch auf die Stabilisierungsphase und Implementation neuer Funktionen aus (Beispiel \enquote{128-bit Integer Support} \cite{rust:github:128bit_integer}).

\section{Aufbau eines Projektverzeichnisses}

\subsection{Klassisch}
\label{rust:structure:classic}
\begin{wrapfigure}{l}[-1em]{.4\textwidth}
	\begin{rustc}
		src/
		|-- main.rs
		|-- functionality.rs
		|-- module/
		    |-- mod.rs
		    |-- functionality.rs
		    |-- submodule/
		        |-- mod.rs
		        |-- functionality.rs
	\end{rustc}
	\caption{Verzeichnisstruktur des Quelltext-Verzeichnisses}
\end{wrapfigure}

\todo{files.rs, (nested)modules, compiler, use, function, macro}

Das Quelldatei-Verzeichnis sollte entweder eine \textit{main.rs} für Ausführbare Programme oder eine \textit{lib.rs} für Bibliotheken enthalten.
Während der Paketmanager Cargo (\autoref{rust:structure:cargo}) eine solche Benennung so als Standardkonvention erwartet, kann bei manueller Nutzung des Kompilers auch ein anderer Name für die Quelldatei vergeben werden.

Die Kompilierung nutzt \todo{diese} Datei als Wurzel, in der Module durch \rustcinline{mod module;} und Quelldateien durch \rustcinline{mod functionality;} \enquote{inkludiert} werden können.
Eine Datei \textit{mod.rs} ist die Wurzeldatei eines Moduls.


\subsection{Mit Cargo}
\label{rust:structure:cargo}

\begin{wrapfigure}{r}[-1em]{.4\textwidth}
	\hspace{1em}
	\begin{rustc}
		crate/
		|-- Cargo.toml
		|-- src/
		    |-- ...
	\end{rustc}
	\caption{Vereinfachte Verzeichnisstruktur einer \enquote{crate}}
\end{wrapfigure}

\todo{text is shit}
Im Gegensatz zu einem klassischen Aufbau (\autoref{rust:structure:classic}) wird von der Rust Gemeinschaft das Werkzeug \enquote{Cargo} (dt. Fracht/Ladung\todo{.}) angeboten.
Mit Cargo können ähnlich wie zum Beispiel mit Maven \todo{cite?} in Java, Abhängigkeiten zu anderen Bibliotheken verwaltet werden.
Ein Cargo Projekt wird dabei als \enquote{Crate} (dt. Kiste/Kasten\todo{.}) bezeichnet.
Eine offizielles Verzeichnis befindet sich auf \url{https://crates.io/}.
Von \url{https://crates.io/} werden standardmäßig Abhängigkeiten nachgeladen.
Jeder kann neue Bibliotheken hochladen/veröffentlichen, für den Namen gilt dabei \enquote{first come, first serve}.

\todo{dependencies}
\todo{Cargo init --bin <name>}
\todo{missing .gitignore / .git mention / git alltogether}
\todo{Cargo.toml}
\todo{[crates.io]}

\section{Hello World}


\begin{wrapfigure}{l}{.5\textwidth}
	\begin{rustc}
		fn main() {
			println!("Hello World");
		}
	\end{rustc}
	\caption{\enquote{Hello World} in Rust}
	\label{fig:rust:hello_world}
\end{wrapfigure}

\todo{official format/naming convetion}

\section{Rust als funktionale Programmiersprache}
\todo{functional programming -> no global state, no exceptions, find literature}
\todo{prove via code}

\section{Rust als Objekt-Orientierte Programmiersprache}
\todo{trait}
\todo{prove via design patterns, a few? from faq::  Is Rust object oriented? It is multi-paradigm. Many things you can do in OO languages you can do in Rust, but not everything, and not always using the same abstraction you’re accustomed to.}


\section{Versprechen von Rust}
\label{rust:guarantees}
\subsection{Sichere Nebenläufigkeit}
\todo{Send, Sync}
\subsection{Zero Cost Abstraction}
\subsection{Kein undefiniertes Verhalten}
\todo{ref oreilly}
\subsection{Kein Null-Pointer}
\todo{explain option}
\subsection{Kein vergessene Fehlerprüfung}
\todo{explain result}
\subsection{No dangling pointer}
\todo{src https://www.youtube.com/watch?v=d1uraoHM8Gg}
\subsection{Statische Speicher- und Lebenszeitanalyse}
\todo{while compiling, does not compile on error / unprovable code, trait Drop}
\subsection{type safety langauge}





Rust ist...
% \lipsum

\todo{Rust -> MIR -> assembler} \\
\todo{MIR/assemblerbeispiele?} \\
\cite{rust:orly_programming}


\section{Warum Rust?}

\begin{quotation}
	\textit{\enquote{[..]Leute, die [..] sichere Programmierung haben wollen, [..] können das bei Rust haben, ohne die [von D] undeterministischen Laufzeiten oder Abstraktionskosten schlucken zu müssen. }}
	\cite{rust:fefe}
\end{quotation}




\begin{quotation}
	\textit{\enquote{It’s not bad programmers, it’s that C is a hostile language}} 
	(Seite 54, \cite{rust:c_is_hostile_mena})
\end{quotation}

\begin{quotation}
	\textit{\enquote{I’m thinking that C is actively hostile to writing and maintaining reliable code}} 
	(Seite 129, \cite{rust:c_is_hostile_mena})
\end{quotation}

\begin{quotation}
	\textit{\enquote{[..] Rust makes it safe, and  provides nice tools}} 
	(Seite 130, \cite{rust:c_is_hostile_mena})
\end{quotation}


\begin{quotation}
	\textit{\enquote{Rust hilft beim Fehlervermeiden}} 
	\cite{rust:c_is_hostile_golem}
\end{quotation}


\begin{quotation}
	\textit{\enquote{Rust is [..] a language that cares about very tight control}}
	\cite{rust:tight_control}
\end{quotation}

\todo{unused orly rust} \cite{rust:orly_y_rust}

\section{Kernfeatures}

https://www.youtube.com/watch?v=d1uraoHM8Gg \\
\todo{no need for a runtime, all static analytics} \\
\todo{memory safety} \\
\todo{data-race freedom} \\
\todo{active community} \\
\todo{concurrency: no undefined behavior} \\
\todo{ffi binding} \gls{ffi} \\
\todo{zero cost abstraction} \\
\todo{package manager: cargo} \\

https://www.youtube.com/watch?v=-Tj8Q12DaEQ \\
\todo{static type system with local type inference } \\
\todo{explicit notion of mutability } \\
\todo{zero-cost abstraction *(do not introduce new cost through implementation of abstraction)} \\
\todo{errors are values not exceptions}
\todo{no null} \\
\todo{"static automatic memory management" - no garbage collection } \\
\todo{often compared to GO and D (~44min)} \\


\section{Schwächen}

https://www.youtube.com/watch?v=-Tj8Q12DaEQ \\
\todo{compile-times} \\
\todo{Rust is a vampire language, it does not reflect at all!} \\
\todo{depending on the field -> majority of libraries?} \\


\section{Performance Fallstricke}

\todo{\cite{rust:performance_pitfalls}}

\section{Beispiele von Verwendung von Rust}

\todo{firefox} \\

https://www.youtube.com/watch?v=-Tj8Q12DaEQ \\
\todo{GTK binding heavily to rust} \\

\todo{unstable}
\todo{ffi}
