
\chapter{Die Programmiersprache Rust}

\todo{quotation besser verpacken}
\begin{quotation}
	\textit{\enquote{[..]Leute, die [..] sichere Programmierung haben wollen, [..] können das bei Rust haben, ohne die [von D] undeterministischen Laufzeiten oder Abstraktionskosten schlucken zu müssen. }}
	\cite{rust:fefe}
\end{quotation}

\begin{quotation}
	\textit{\enquote{It’s not bad programmers, it’s that C is a hostile language}} 
	\cite[54]{rust:c_is_hostile_mena}
\end{quotation}

\begin{quotation}
	\textit{\enquote{I’m thinking that C is actively hostile to writing and maintaining reliable code}} 
	\cite[129]{rust:c_is_hostile_mena}
\end{quotation}

\begin{quotation}
	\textit{\enquote{[..] Rust makes it safe, and  provides nice tools}} 
	\cite[130]{rust:c_is_hostile_mena}
\end{quotation}


\begin{quotation}
	\textit{\enquote{Rust hilft beim Fehlervermeiden}} 
	\cite{rust:c_is_hostile_golem}
\end{quotation}

\begin{quotation}
	\textit{\enquote{Rust is [..] a language that cares about very tight control}}
	\cite{rust:tight_control}
\end{quotation}

%Rust ist eine Programmiersprache, die versucht performante -- und daher durch Abstraktionen mit keinem zusätzlichen \enquote{Kosten} \todo{ref zero cost abstractions} -- und sichere Programmierung zu ermöglichen.
Rust hat als Ziel, eine sichere \todo{cite chapter} und performante \todo{Systemprogrammiersprache} zu sein, die ohne eine Laufzeit ausgeführt werden kann und \todo{ergonomisch nutzbar} ist.
Abstraktionen sollen die Ergonomie verbessern, aber keine unnötigen Performanceeinbußen verursachen (siehe \todo{ref zero cost abstractions}).

Aus anderen Programmiersprachen bekannte Fehlerquellen -- wie \enquote{dangling pointers}, \enquote{double free} oder \enquote{memory leaks} \todo{ref} --  werden durch strikte Regeln und mit Hilfe des Compilers verhindert.
Im Gegensatz zu Programmiersprachen, die dies mit Hilfe einer Laufzeit ermöglichen (zbsp. Java oder C\#), werden diese Regeln in Rust durch eine statische Lebenszeitanalyse (\ref{rust:static_analysis}) und mit dem Eigentümerprinzip (\ref{rust:ownership}) bei der Compilation überprüft und erzwungen.

\todo{unused orly rust} \cite{rust:orly_y_rust}


\section{Geschichte}
\label{rust:history}

In 2006 begann Graydon Hoare die Programmiersprache Rust in seiner Freizeit als Hobbyprojekt zu entwickeln \cite{rust:faq}.
Als Grund nannte er seine Unzufriedenheit mit der Programmiersprache C++, in der es sehr schwierig sei, fehlerfreien, speichersicheren und nebenläufigen Programmcode zu entwickeln.
Zudem beschrieb er C++ als \enquote{ziemlich fehlerträchtig} \cite{rust:heise_interview_graydon}.

Auch Federico Mena-Quintero -- Mitbegründer des GNOME-Projekts \todo{cite \url{https://people.gnome.org/~federico/} or so} --
äußerte in einem Interview mit Golem im Juli 2017 seine Bedenken an der Verwendung der \enquote{feindseligen} Sprache C \cite{rust:c_is_hostile_golem}.
In Vorträgen \todo{nix mehrzahl?} vermittelt er seither, wie Bibliotheken durch Implementationen in Rust ersetzt werden können \cite{rust:c_is_hostile_mena}.

Ab 2009 begann Mozilla die Weiterentwicklung finanziell zu fördern, als einfache Tests und die Kernprinzipien demonstriert werden konnten.
Die Entwicklung findet dabei öffentlich einsehbar unter \url{https://github.com/rust-lang/rust} statt und wird dabei nicht ausschließlich von Mozilla Angestellten koordiniert.

Durch automatisierte Tests \todo{ref} in Kombination mit drei Veröffentlichungskanälen (relese, stable und nightly) wird die Stabilität des Compilers und die der Standardbibliothek (\autoref{rust:stdlib}) gewährleistet.
Auf eine andere Art und Weise wäre eine öffentliche Entwicklung auf \gls{github} nicht möglich, an der sich jeder -- sowohl an Diskussionen als auch an Implementationen -- beteiligen kann.
%Die Stabilität des Compilers trotz hoher Flexibilität während der Entwicklung wird durch Unterscheidung von drei Veröffentlichungskanälen -- release, stable und nightly -- in Kombination mit automatisierten Tests \todo{ref?} gewährleistet. \cite{rust:faq}


\todo{wo anders? make more text, make better text}
Bei Rust geht es in vielerlei Hinsicht darum, bekannte Fehlerquellen aus anderen Programmiersprachen zu unterbinden, aber gleichzeitig eine mindestens genau so gute Performance zu erreichen.
\todo{hobbyprojekt, mozilla, open-source, Entwicklung auf GitHub - jeder kann sich beteiligen, test(coverage), automatisierte builds, stable/beta/nightly}

\section{Anwendungsgebiet}

Das Ziel von Rust ist es, das Designen und Implementieren von sicheren, nebenläufig und auch praktisch tauglichen Systemen möglich zu machen \cite{rust:faq}.
\todo{intro paragraph}

Da Rust den \gls{llvm}-Compiler nutzt, erbt Rust auch eine große Anzahl der Zielplattformen die \gls{llvm} unterstützt.
Die Zielplattformen sind in drei Stufen unterteilt, bei denen verschieden stark ausgeprägte Garantien vergeben sind. Es wird zwischen
\begin{itemize}
	\item \enquote{Stufe 1: Funktioniert garantiert} (u.a. X86, X86-64),
	\item \enquote{Stufe 2: Compiliert garantiert} (u.a. ARM, PowerPC, PowerPC-64) und
	\item \enquote{Stufe 3} (u. a. Thumb (Cortex-Microcontroller))
\end{itemize}
unterschieden \cite{rust:platform_support}.
Diese Unterscheidung wirkt sich auch auf die Stabilisierungsphase und Implementation neuer Funktionen aus (Beispiel \enquote{128-bit Integer Support} \cite{rust:github:128bit_integer}).

\section{Aufbau eines Projektverzeichnisses}

Der Aufbau eines Rust Projektverzeichnis kann zwischen zwei verschiedenen Arten differenziert werden.
Zum einen gibt es den klassische Aufbau, in dem lediglich der Programmcode liegt und der Compiler direkt aufgerufen wird.
Zum anderen wird der Aufbau als Crate empfohlen \todo{cite}, bei dem automatisch Abhängigkeiten aufgelöst aber auch Metainformationen bezüglich des Autors und der Version gehalten werden.
Ein klassischer Aufbau ist nur selten zu anzutreffen.

\subsection{Klassisch}
\label{rust:structure:classic}
\begin{wrapfigure}{l}[-1em]{.5\textwidth}
	\rustcinclude
		{fig:rust:structure:classi}
		{Verzeichnisstruktur des Quelltext-Verzeichnisses}
		{sections/rust.classic.txt}
\end{wrapfigure}

Das Quelldatei-Verzeichnis sollte entweder eine \textit{main.rs} für Ausführbare Programme oder eine \textit{lib.rs} für Bibliotheken enthalten.
Während der Paketmanager Cargo (\autoref{rust:structure:cargo}) eine solche Benennung als Standardkonvention erwartet, kann bei manueller Nutzung des Compilers auch ein anderer Name für die Quelldatei vergeben werden.

Der Compiler startet in der Wurzeldatei und lädt weitere Module, die durch \rustcinline{mod module;} gekennzeichnet sind (ähnlich \ccinline{# include "module.h"} in C/C++).
Ein Modul kann dabei eine weitere Quelldatei oder ein ganzes Verzeichnis sein.
Ein Verzeichnis wird aber nur als gültiges Modul interpretiert, wenn sich eine \textit{mod.rs} Datei darin befindet.

Wie bereits angedeutet, wird in Rust nicht eine \enquote{Klasse}, Datenstruktur oder Aufzählung pro Datei erwartet (\todo{wie das bei Java der Fall ist}), sondern eine Quelldatei entspricht einem Modul.
Dies Umfasst in vielen fällen wenige aber mehrere Datenstrukturen, zugehörige Aufzählung und Fehlertypen.
%Module (Verzeichnisse oder Quelldateien) gesucht wird. , in der Module durch \rustcinline{mod module;} und Quelldateien durch \rustcinline{mod functionality;} \enquote{inkludiert} werden können.
%Eine Datei \textit{mod.rs} ist die Wurzeldatei eines Moduls.

\subsection{Als Crate}
\label{rust:structure:cargo}

\begin{wrapfigure}{r}{.4\textwidth}
	\rustcincludeml
		{fig:rust:structure:cargo}
		{Vereinfachte Verzeichnisstruktur einer \enquote{crate}}
		{sections/rust.cargo.txt}
\end{wrapfigure}



Eine \enquote{Crate} (dt. Kiste/Kasten\todo{.}) erweitert den klassischen Aufbau um eine \textit{Cargo.toml} Datei, in der Metainformationen zum Projekt hinterlegt werden.
Durch die Benutzung des Werkzeugs \enquote{Cargo} (dt. Fracht/Ladung\todo{.}, entwickelt und angeboten von der Rust \todo{Gemeinschaft}) können Abhängigkeiten automatisch aufgelöst, heruntergeladen und compiliert werden.

\todo{text is shit}
Eine offizielles Verzeichnis mit über 14.000 Crates (Stand \today) ist unter \url{https://crates.io/} erreichbar.
Cargo lädt standardmäßig Abhängigkeiten von dort nach.
Jeder kann neue Bibliotheken veröffentlichen.
Für den Namen gilt dabei \enquote{first come, first serve}.

Eine Crate kann entweder ein ausführbares Programm oder eine Bibliothek sein.
Davon abhängig is die Wurzeldatei \textit{src/main.rs} (für ein ausführbares Programm) oder \textit{src/lib.rs} (für eine Bibliothek).
Mit dem erzeuge einer Crate (\rustcinline{cargo --bin meineCrate} bzw. \rustcinline{cargo --lib meineBib}) wird auch gleichzeitig \gls{git} für das Verzeichnis initialisiert.

Es wird allgemein empfohlen, ein Projekt als Crate zu betreiben \todo{cite}.

\todo{Cargo.toml example?}

\section{Hello World}


\begin{wrapfigure}{l}{.5\textwidth}
	\rustcinclude
		{fig:rust:hello_world}
		{\enquote{Hello World} in Rust}
		{sections/rust.hello_world.rs}
\end{wrapfigure}

Der Programmcode in \autoref{fig:rust:hello_world} gibt auf der Konsole \monospaceinline{Hello World} aus.
Das \rustcinline{fn} die Funktion \rustcinline{main} definiert und diese der Startpunkt des Programms ist, wird wenige überraschen.
Den meisten wird vermutlich eher das Ausrufezeichen in Zeile 2 auffallen, da es auf den ersten Blick dort nicht hingehören sollte.
In Rust haben Ausrufezeichen und Fragezeichen besondere Bedeutungen, weswegen die Verwendung in Zeile 2 trotzdem richtig ist.

Die Bedeutung des Fragezeichens dient zum schnelleren Auswerten von \rustcinline{Rusult<_, _>} Werten und wird in \todo{ref} genauer erklärt.
Das Ausrufezeichen kennzeichnet, dass der ansonsten augenscheinliche Funktionsaufruf tatsächlich ein Aufruf einer Makrofunktion ist.

Eine Funktion \rustcinline{println} gibt es nicht, auch keine aus C erwarteten Funktionen wie \ccinline{printf}, \ccinline{fputs}, \ccinline{sprintf}.
Eine Ausgabe erfolgt durch das \rustcinline{println!} Makro, welches die Makros \rustcinline{format!} \todo{ref} und \rustcinline{writeln!} Kombiniert und das \rustcinline{Write}-Traits \todo{ref}, welches von der Standardausgabe implementiert wird, nutzt \todo{verify, cite?}.

\todo{hmmmm}
Ein kleines Beispiel, viele versteckte Mechaniken zur Laufzeitoptimierung aber trotzdem handlich und leserlich -- Rust.

\subsection{Generic}

\todo{<T: Blubber> vs Box<T> (Speicherorganisation, performance)}

\todo{you idiot forgot an subsub-idea}


\subsection{Matches}

\rustcinline{match foo.bar() \{ \}}

Verkürzt

\rustcinline{if let Ok(line) = blubber.readline() \{ \}}

\rustcinline{if let Some(value) = foo.bar() \{ \}}


\subsection{Namens- und Formatierkonvention / Styleguide}

\cite{rust:styleguide}

\subsection{Formatierung}
\rustcinline{format!} all se things

\todo{formatierung}

\todo{let, optionaler datentyp, macros, generics, () statt void}

\todo{official format/naming convetion, use, function, macro}

\todo{Variables, Structs, Enums, Traits}

\todo{type safety langauge}

\todo{Rust -> MIR -> assembler} \\

\todo{MIR/assemblerbeispiele?} \\
\cite{rust:orly_programming}

\todo{pattern matching}

\subsection{Niemals nichts und niemals Ausnahmen \todo{se name}}

Rust kennt \ccinline{null}(-Pointer) nicht, bietet aber in \rustcinline{core} (\autoref{rust:core}) \rustcinline{Option<_>} als Ersatz an (siehe \autoref{rust:no_null}).
Für die Fehlerbehandlung wird nicht auf ein Exception-Handling zurückgegriffen, sondern ein eigener Datentyp angeboten, der entweder den Rückgabewert enthält, oder aber einen Fehler: \rustcinline{Result<_, _>} (siehe \autoref{rust:result}).


\section{Standardbibliothek}
\label{rust:stdlib}

Die Rust Community ist darum bemüht, die Standardbibliothek sehr leichtgewichtig zu halten.
Nicht eindeutig als fundamental eingestufte Funktionalität wird lieber als Crate auf \textins{crates.io} angeboten anstatt die Standardbibliothek übernommen zu werden \todo{prove via ref}. 
Sie wird selbst als eine Crate (siehe \autoref{rust:structure:cargo}) zur Verfügung gestellt, auf die standardmäßige eine Abhängigkeit besteht.
Für die Verwendung von Rust im Embedded Bereich, kann diese Abhängigkeit, die für Microcontroller sehr umfangreich ist, durch \rustcinline{#![no_std]} unterbunden werden.
Daraufhin sind nur noch die in der \rustcinline{core} Crate zur Verfügung gestellten Sprachkonstrukte verwendbar.

\subsection{core}
\label{rust:core}
Die in der \rustcinline{core} Crate zur Verfügung gestellten Sprachkonstrukte sind im wesentlichen die üblichen  Verdächtigen: \rustcinline{bool} für boolische Ausdrücke; \rustcinline{char} für ein einzelnes Unicode Zeichen; \rustcinline{str} für eine Zeichenkette; \rustcinline{u8}, \rustcinline{i8}, \rustcinline{u16}, \rustcinline{i16}, \rustcinline{u32}, \rustcinline{i32}, \rustcinline{u64}, \rustcinline{i64}, (bald \rustcinline{u128}, \rustcinline{i128} \todo{cite}) und \rustcinline{usize}, \rustcinline{isize}  für ganze Zahlen; \rustcinline{f32}, \rustcinline{f64} für Fließkommazahlen in einfacher und zweifacher Präzision; Arrays und Slices \cite{rust:book:primitives}.

Ganzzahlige primitive Datentypen mit \rustcinline{u} beginnend sind vorzeichenlos und mit \rustcinline{i} beginnend sind vorzeichenbehaftet, gefolgt mit der Anzahl der Bits  die der Datentyp groß ist.
\todo{shit sentence} Die einzige Ausnahme bildet der Datentyp \rustcinline{usize} bzw \rustcinline{isize}, da dieser immer so groß ist, wie die Architektur der Zielplattform (X86 -> 32 Bit, X86\_64 -> 64 Bit).
Ein Anwendungsfall von \rustcinline{usize} ist dabei die Indexierung eines Arrays oder einer Slice (\todo{siehe nächster paragraph?}), da der Index hierfür niemals negativ und niemals größer sein kann, wie die Architektur der Zielplattform darstellen kann \todo{erwähnen?: größer könnte man garnicht addressieren}.

Durch dieses Schema bei der Bezeichnung der Datentypen wird eine Verwirrung wie zum Beispiel in C unterbunden, wo die primitiven Datentypen (\ccinline{short}, \ccinline{int}, \ccinline{long}, ..) keine definierte Größe haben, sondern dies abhängig vom eingesetzten Compiler und der Zielplattform ist \cite[187]{deitel2013c}. Erst ab C99 wurden zusätzliche, aber optionale, ganzzahlige Datentypen mit bestimmter Größe definiert \cite[141]{goll2014c}.

Konstanten können eindeutig einem Datentyp zugewiesen werden, indem dieser angehängt wird.
\rustcinline{4711u16} ist somit vom Datentyp \rustcinline{u16}.
Des weiteren dürfen Ziffern durch beliebiges setzen von \rustcinline{_} getrennt werden, um die Lesbarkeit zu erhöhen: \rustcinline{1_000_000_f32}.
Eine Schreibweise in Binär (\rustcinline{0b0000_1000_u8}), in Hexadezimal (\rustcinline{0xFF_08_u16}) oder Oktal (\rustcinline{0o64_u8}) ist auch möglich. 
Konstante Zeichen und Zeichenketten können auch als Bytes (\rustcinline{b'b'} entspricht \rustcinline{u8} und \rustcinline{b"abc"} entsricht \rustcinline{&[u8]}) \todo{hinterlegt} werden.

Arrays haben immer eine zur Compilezeit bekannte Größe und Initialisierungswert (siehe \autoref{rust:no_unitialized_usage}).
Dynamische Arrays gibt es nicht, da diese zu oft Fehlerquellen seien \todo{cite!} (Abhilfe: \rustcinline{Vec<_>}, siehe \autoref{rust:std}).
Die Notation ist \rustcinline{[<Füllwert>; <Größe>]}.
\rustcinline{[0_u8; 128]} steht also für ein 128 Byte langes Byte Array, das mit 0-en vom Datentyp \rustcinline{u8} gefüllt ist.

\enquote{Slices} (dt. Scheibe/Stück) bezeichnet Rust Referenzen auf Arrays, die auch nur Teilbereiche umfassen können.
Die Größe einer Slice wird dabei mit der Referenz auf den Startwert gespeichert \todo{explain Fat-Pointer?} und bei Funktionsaufrufen übergeben.
Ein zusätzlicher Parameter für die Größe eines Buffers, wie in C üblich, ist somit unnötig.
Die Notation ähnelt die eines Arrays, aber ohne Größenspezifikation: \rustcinline{[<Datentyp>]}.
Eine Slice kann von einem Array oder einer anderen Slice erzeugt werden, dabei wird der Start- und Endindex des Teilbereiches angegeben.
Falls kein Start- oder Endindex angegeben wurde, wird das jeweilige Limit übernommen (0, max) \todo{shit text}: \rustcinline{let slice : &[u8] = &array[..8];}


\subsection{std}
\label{rust:std}

Die Crate \rustcinline{std} erweitert \rustcinline{core} um viele \todo{containers, collections, rc, arc, mutex, rwlock, platform abstractions: threads, tcp, udp}. \rustcinline{Vec<_>} \rustcinline{HashMap<_, _>} \rustcinline{String}  \rustcinline{Box} \todo{heap dinge}

\todo{core, datatypes, arrays slices, no null  \enquote{billion dollar mistake} }

\todo{std, Vec, str, String, no\_std für embedded}

\todo{println!, writeln! formatting}

https://www.youtube.com/watch?v=-Tj8Q12DaEQ \\
\todo{static type system with local type inference } \\



\section{Alles hat einen Rückgabewert}
\todo{() ??, Statement vs }

\section{use mod pub}


\section{Geltungsbereich / Memory Management, Lebenszeit}
\label{rust:scope}
\label{rust:static_analysis}

Rust benutzt ein \enquote{statisches, automatisches Speicher Management -- keinen Garbage Collector} \cite{rust:youtube:goto2017}.
Das bedeutet, die Lebenszeit einer Variable wird statisch während der Compilezeit anhand des Geltungsbereichs ermittelt.
Durch diese statische Analyses wird eine Variable durch eine automatisierte Anweisung, die der Compiler einfügt, freigegeben.
Dies gilt auch für Variablen auf dem Heap.
Ein Manuelles \ccinline{free(*void)} wie in C/C++ üblich entfällt.


\begin{figure}[H]
	\rustcinclude
		{rust:memory:scope}
		{Geltungsbereich von Variablen}
		{sections/rust.memory.rs}
\end{figure}

Als Alternative kann eine Variable oder Datenstruktur auch vorzeitig durch Aufruf von \rustcinline{std::mem::drop(_)} freigegeben werden.
Die optionalen Implementation von \rustcinline{std::op::Drop} \todo{trait? ref?} kommt der Implementation des Destruktors aus C++ gleich.

\enquote{static automatic memory management} - no garbage collection \cite{rust:youtube:goto2017}
\todo{"static automatic memory management" - no garbage collection } \\

\todo{while compiling, does not compile on error / unprovable code, trait Drop}

\todo{autodrop, auto file close}

\section{Eigentümer- und Verleihprinzip}
\label{rust:ownership}

Bereits 2003 beschreibt Bruce Powel Douglass im Buch \enquote{Real-Time Design Patterns}, dass \enquote{passive} Objekte ihre Arbeit nur in dem \todo{Thread-Kontext} ihres \enquote{aktiven} Eigentümers tätigen sollen \cite[204]{douglass2003real}.
In dem beschriebenen \enquote{Concurrency Pattern} wird eine klare Zuordnung getätigt, welche Objekte welchem anderen Objekt als Eigentümern zugeordnet sind, um eine sicherere Nebenläufigkeit zu schaffen \todo{shit}.

Diese Philosophie setzt Rust direkt in der Sprache um, so darf eine Variable immer nur einen Eigentümer haben. Zusätzlich zu einem immer eindeutig identifizierbaren Eigentümer für eine Variable, kann diese auch ausgeliehen werden; entweder exklusiv mit sowohl Lese- als auch Schreiberlaubnis, oder mehrfache mit nur Leseerlaubnis.

Die Philosophie \enquote{jede Variable hat einen Eigentümer} ist nicht neu 
\todo{active -> Eigentümer \cite[204]{douglass2003real}} \todo{cite!}, aber Rust setzt dies in der Sprache um.
Zusätzlich zu einem immer eindeutig identifizierbaren Eigentümer für eine Variable, kann diese auch ausgeliehen werden; einmal mit einer exklusiven Schreiberlaubnis, oder mehrfache mit nur Leserechten.
\todo{mutability fehlt}
Da eine Schreiberlaubnis immer exklusiv ist, werden \todo{Data-Races} unterbunden; da dies nur bei mehreren Parteien mit gleichzeitigem Schreib- und Leserecht auftreten kann.

Die Garantie nur einen exklusiven Schreibzugriff oder mehrere Lesezugriffe auf eine Variable zu haben, wird durch die statische Lebenszeitanalyse garantiert (\autoref{rust:scope}).

\todo{Split example, explain more}
\rustcinclude
	{rust:ownership:scope}
	{Eigentümer und Referenzen von Variablen}
	{sections/rust.ownership.rs}



\section{Rust als funktionale Programmiersprache}
\todo{functional programming -> no global state, no exceptions, find literature}
\todo{prove via code}

\section{Rust als Objekt-Orientierte Programmiersprache}
\todo{trait}
\todo{prove via design patterns, a few? from faq::  Is Rust object oriented? It is multi-paradigm. Many things you can do in OO languages you can do in Rust, but not everything, and not always using the same abstraction you’re accustomed to.}


\section{Versprechen von Rust}
\label{rust:guarantees}
\subsection{Sichere Nebenläufigkeit}
\todo{Send, Sync, No dataraces weil Ownership \autoref{rust:ownership}, Channel, Mutex, RwLock}
\subsection{Zero Cost Abstraction}
\subsection{Kein undefiniertes Verhalten}
\label{rust:no_unitialized_usage}
\todo{auch: no unitialized usage}
\todo{ref oreilly}
\subsection{Keine vergessene Null-Pointer Prüfung}
\label{rust:no_null}
\todo{explain option}

\subsection{Keine vergessene Fehlerprüfung}
\label{rust:result}

\begin{figure}[H]
	\ccinclude
	{rust:result:c_bad_fopen}
	{Negativbeispiel: Fehlende Fehlerprüfung in C}
	{sections/rust.fopen.c}
\end{figure}

In \autoref{rust:result:c_bad_fopen} sind mindestens zwei Fehler versteckt, die aber keinen Compileabbruch auslösen, sondern sich zur Laufzeit zeigen können.
Der erste Fehler ist eine fehlende Überprüfung des Rückgabewertes von \ccinline{fopen} in Zeile 4, da dieser \ccinline{null} ist, falls das Öffnen der Datei fehlgeschlagen ist.
Der Versuch in die Datei zu schreiben in Zeile 5 kann daraufhin in einen Speicherzugriffsfehler Resultieren und das Programm abstürzen lassen.
\todo{vergleich Java/C++(++) exceptions (vergessen von fehlerbehandlung in c++(++) trotzdem möglich)}

In Rust wird weder eine Ausnahme geworfen, noch ein Rückgabewert zurück gegeben, der ohne Prüfung verwendet werden kann:

\begin{figure}[H]
	\rustcinclude
		{rust:result:rust_good_fopen}
		{Positivbeispiel: Keine fehlende Fehlerprüfung in Rust}
		{sections/rust.fopen.rs}
\end{figure}

Der Rückgabewert von \rustcinline{File::open("private.key")} in Zeile 5 von \autoref{rust:result:rust_good_fopen} ist vom Typ \rustcinline{Result<File, Error>}.
Auf den eigentlichen Rückgabewert \rustcinline{File} kann nicht ohne eine Fehlerprüfung zugegriffen werden, da dies \rustcinline{Result} verhindert.
Eine Fehlerprüfung kann wie in Zeile 5 mit einem \rustcinline{match} passieren, oder auch mit anderen Funktionen wie \rustcinline{.unwrap()}, \rustcinline{.unwrap_or()} ... https://doc.rust-lang.org/std/result/enum.Result.html die dann aber eine \rustcinline{panic!} \todo{ref} auslösen, falls ein Fehler vorliegt -- somit wird ein undefiniertes Verhalten unterbunden \todo{ref}.

\todo{Der zweite Fehler...?}
Durch die Lebenszeitanalyse \todo{ref} in Rust ist der Geltungsbereich der \rustcinline{File} Variable bekannt, deshalb wird in dem Beispiel in Rust in \autoref{rust:result:rust_good_fopen} die Datei auch wieder ordnungsgemäß geschlossen, während dies im C Beispiel in \autoref{rust:result:c_bad_fopen} nicht der Fall ist.

\todo{explain result}

\subsection{No dangling pointer}
\todo{src https://www.youtube.com/watch?v=d1uraoHM8Gg}


\section{Einbinden von Bibliotheken}

\subsubsection{Externe Datentypen}
\label{rust:ffi:datatypes}

Rust bietet durch das \gls{ffi} die Möglichkeit, andere (System-)Bibliotheken einzubinden.
Entsprechende Strukturen und Funktionen werden durch einen \rustcinline{extern}-Block
oder im Falle von Strukturen stattdessen optional mit einem \rustcinline{#[repr(C)]} gekennzeichnet.

In einem Beispiel, soll die Nutzung von \gls{ffi} demonstriert werden.

\begin{figure}[H]
	\ccinclude
		{fig:rust:ffi:position_offset_c}
		{Ausschnitt von \enquote{PositionOffset} \todo{ref mecview lib} in C, autgen ASN}
		{sections/rust.position_offset.c}
	
\end{figure}

Die Struktur in \autoref{fig:rust:ffi:position_offset_c} muss zur Nutzung in Rust zuerst bekannt gemacht werden.
Dabei gibt es mehrere Möglichkeiten:
\begin{enumerate}
	\item Falls der Aufbau der Struktur nicht von Bedeutung ist, kann es ausreichen, den Datentyp lediglich bekannt zu machen: \rustcinline{#[repr(C)] struct PositionOffset;} \label{rust:ffi:example:enumerate:repr}
	
	\item Der Aufbau ist wie bei \autoref{rust:ffi:example:enumerate:repr} unbedeutend, es soll aber ausdrücklich auf einen externen Datentyp hingewiesen werden: \rustcinline{extern \{ type PositionOffset; \}} \cite{rust:github:extern_type} (\todo{nightly})
	
	\item Der Inhalt der Struktur ist von Bedeutung, da darauf zugegriffen werden soll oder in Rust eine Instanz erzeugbar sein soll. In diesem Fall muss die Struktur komplett wiedergegeben werden:
	\begin{figure}[H]
		\rustcinclude
			{fig:rust:ffi:position_offset_rust}
			{Ausschnitt von \enquote{PositionOffset} \todo{ref mecview lib} in Rust}
			{sections/rust.position_offset.rs}
	\end{figure}
	
	In \autoref{fig:rust:ffi:position_offset_rust} ist die Struktur \enquote{PositionOffset} definiert,
	die durch das Attribut \rustcinline{#repr(C)} wie eine C-Struktur im Speicher organisiert wird.
	Somit ist sie kompatibel zu der C-Struktur aus \autoref{fig:rust:ffi:position_offset_c}.
	
	Wenn auf eine C-Struktur zugegriffen wird, sollten auch, wie in \autoref{fig:rust:ffi:position_offset_rust} zu sehen, spezielle Datentypen (\rustcinline{c_long}, \rustcinline{c_void}, \rustcinline{c_char}, ...) verwendet werden, um die Kompatibilität mit verschiedenen Systemen und C-Compilern zu wahren. \todo{u32 immer 32bit, aber int nicht immer gleich (Beispiel!?) --> Probleme}
	
%	\rustcinline{*mut c_long} entspricht dabei dem C-Pointer für \rustcinline{&mut c_long}, also \ccinline{long*}, ein C-Pointer für \rustcinline{&c_long} entspricht \rustcinline{*const c_long}.
	
%	C-Pointer werden in Rust \enquote{Raw-Pointer} genannt und \rustcinline{*mut c_long} für  \rustcinline{&mut c_long} bzw. \rustcinline{*const c_long} für \rustcinline{&c_long} geschrieben.
	
	Ein C-Pointer \ccinline{*long} wird in Rust \enquote{Raw-Pointer} genannt und entweder \rustcinline{*mut c_long} oder \rustcinline{*const c_long} geschrieben. Der Unterschied ist wie zwischen \rustcinline{&mut c_long} und \rustcinline{&c_long} und dient dem \todo{Rusttypsystem!? ref!?} zur Unterscheidung \todo{Erzwinungt im Besitz von entsprechender Mutability zu sein}, während es für die C-Seite keinen Unterschied macht \cite{rust:book:raw_ptr}:
	
	\begin{figure}[H]
		\centering
		\begin{tabular}{c|c|c}
			Referenz in Rust & Raw-Pointer in Rust & C-Pointer \\
			\hline
			\rustcinline{&mut c_long}  &   \rustcinline{*mut   c_long}  &   \ccinline{long*} \\
			\rustcinline{    &c_long}  &   \rustcinline{*const c_long}  &   \ccinline{long*}
		\end{tabular}
		\caption{Vergleich Rust Raw-Pointer und Referenz zu C-Pointer}
	\end{figure}
	
\end{enumerate}

\subsubsection{Externer Funktionsaufruf}
\label{rust:ffi:functioncall}

Während eine Struktur, die eine externe Struktur wiedergibt, sich optional in einem \rustcinline{extern \{\}} Block befinden kann, ist es zwingend, eine externe Funktionen darin bekannt zu machen:

\begin{figure}[H]
	\rustcinclude
		{fig:rust:ffi:uper_encode_to_buffer}
		{Externe Funktionsdefinition der ASN.1 Funktion zum Enkodieren}
		{sections/rust.uper_encode_to_buffer.rs}
\end{figure}

Wie in \autoref{fig:rust:ffi:uper_encode_to_buffer} zu sehen ist, können auch \rustcinline{extern \{\}} Blöcke mit Attributen versehen werden. Zwingend ist bei der Verwendung eines \rustcinline{#[link(..)]} Attributes der Name der Bibliothek, auf die sich der im \rustcinline{extern \{\}} Block stehende Code bezieht. Optional kann auch wie in \autoref{fig:rust:ffi:uper_encode_to_buffer} die Art der \todo{Linkung} (dylib, static) angegeben werden.

Die Art der Definition einer externen Funktion unterscheidet sich nicht von einer normalen Funktionsdefinition. Es sollten aber, wie in \autoref{rust:ffi:datatypes} beschrieben, zu C bzw. der externen Sprache kompatiblen Datentypen verwendet werden.
 


\section{Kernfeatures}

https://www.youtube.com/watch?v=d1uraoHM8Gg \\
\todo{no need for a runtime, all static analytics} \\
\todo{memory safety} \\
\todo{data-race freedom} \\
\todo{active community} \\
\todo{concurrency: no undefined behavior} \\
\todo{ffi binding} \gls{ffi} \\
\todo{zero cost abstraction} \\
\todo{package manager: cargo} \\

https://www.youtube.com/watch?v=-Tj8Q12DaEQ \\
\todo{static type system with local type inference } \\
\todo{explicit notion of mutability } \\
\todo{zero-cost abstraction *(do not introduce new cost through implementation of abstraction)} \\
\todo{errors are values not exceptions}
\todo{no null} \\
\todo{"static automatic memory management" - no garbage collection } \\
\todo{often compared to GO and D (~44min)} \\


\section{Schwächen}

https://www.youtube.com/watch?v=-Tj8Q12DaEQ \\
\todo{compile-times} \\
\todo{Rust is a vampire language, it does not reflect at all!} \\
\todo{depending on the field -> majority of libraries?} \\


\section{Performance Fallstricke}

\todo{\cite{rust:performance_pitfalls}}

\section{Beispiele von Verwendung von Rust}

\todo{firefox} \\

https://www.youtube.com/watch?v=-Tj8Q12DaEQ \\
\todo{GTK binding heavily to rust} \\

\todo{unstable}
\todo{ffi}
