/* automatically generated by rust-bindgen */

#[repr(C)]
#[derive(Default)]
pub struct __IncompleteArrayField<T>(::std::marker::PhantomData<T>);
impl <T> __IncompleteArrayField<T> {
    #[inline]
    pub fn new() -> Self {
        __IncompleteArrayField(::std::marker::PhantomData)
    }
    #[inline]
    pub unsafe fn as_ptr(&self) -> *const T { ::std::mem::transmute(self) }
    #[inline]
    pub unsafe fn as_mut_ptr(&mut self) -> *mut T {
        ::std::mem::transmute(self)
    }
    #[inline]
    pub unsafe fn as_slice(&self, len: usize) -> &[T] {
        ::std::slice::from_raw_parts(self.as_ptr(), len)
    }
    #[inline]
    pub unsafe fn as_mut_slice(&mut self, len: usize) -> &mut [T] {
        ::std::slice::from_raw_parts_mut(self.as_mut_ptr(), len)
    }
}
impl <T> ::std::fmt::Debug for __IncompleteArrayField<T> {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        fmt.write_str("__IncompleteArrayField")
    }
}
impl <T> ::std::clone::Clone for __IncompleteArrayField<T> {
    #[inline]
    fn clone(&self) -> Self { Self::new() }
}
impl <T> ::std::marker::Copy for __IncompleteArrayField<T> { }
#[repr(C)]
pub struct __BindgenUnionField<T>(::std::marker::PhantomData<T>);
impl <T> __BindgenUnionField<T> {
    #[inline]
    pub fn new() -> Self { __BindgenUnionField(::std::marker::PhantomData) }
    #[inline]
    pub unsafe fn as_ref(&self) -> &T { ::std::mem::transmute(self) }
    #[inline]
    pub unsafe fn as_mut(&mut self) -> &mut T { ::std::mem::transmute(self) }
}
impl <T> ::std::default::Default for __BindgenUnionField<T> {
    #[inline]
    fn default() -> Self { Self::new() }
}
impl <T> ::std::clone::Clone for __BindgenUnionField<T> {
    #[inline]
    fn clone(&self) -> Self { Self::new() }
}
impl <T> ::std::marker::Copy for __BindgenUnionField<T> { }
impl <T> ::std::fmt::Debug for __BindgenUnionField<T> {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        fmt.write_str("__BindgenUnionField")
    }
}
pub const _STDIO_H: ::std::os::raw::c_uint = 1;
pub const _FEATURES_H: ::std::os::raw::c_uint = 1;
pub const _DEFAULT_SOURCE: ::std::os::raw::c_uint = 1;
pub const __USE_ISOC11: ::std::os::raw::c_uint = 1;
pub const __USE_ISOC99: ::std::os::raw::c_uint = 1;
pub const __USE_ISOC95: ::std::os::raw::c_uint = 1;
pub const __USE_POSIX_IMPLICITLY: ::std::os::raw::c_uint = 1;
pub const _POSIX_SOURCE: ::std::os::raw::c_uint = 1;
pub const _POSIX_C_SOURCE: ::std::os::raw::c_uint = 200809;
pub const __USE_POSIX: ::std::os::raw::c_uint = 1;
pub const __USE_POSIX2: ::std::os::raw::c_uint = 1;
pub const __USE_POSIX199309: ::std::os::raw::c_uint = 1;
pub const __USE_POSIX199506: ::std::os::raw::c_uint = 1;
pub const __USE_XOPEN2K: ::std::os::raw::c_uint = 1;
pub const __USE_XOPEN2K8: ::std::os::raw::c_uint = 1;
pub const _ATFILE_SOURCE: ::std::os::raw::c_uint = 1;
pub const __USE_MISC: ::std::os::raw::c_uint = 1;
pub const __USE_ATFILE: ::std::os::raw::c_uint = 1;
pub const __USE_FORTIFY_LEVEL: ::std::os::raw::c_uint = 0;
pub const _STDC_PREDEF_H: ::std::os::raw::c_uint = 1;
pub const __STDC_IEC_559__: ::std::os::raw::c_uint = 1;
pub const __STDC_IEC_559_COMPLEX__: ::std::os::raw::c_uint = 1;
pub const __STDC_ISO_10646__: ::std::os::raw::c_uint = 201505;
pub const __STDC_NO_THREADS__: ::std::os::raw::c_uint = 1;
pub const __GNU_LIBRARY__: ::std::os::raw::c_uint = 6;
pub const __GLIBC__: ::std::os::raw::c_uint = 2;
pub const __GLIBC_MINOR__: ::std::os::raw::c_uint = 23;
pub const _SYS_CDEFS_H: ::std::os::raw::c_uint = 1;
pub const __WORDSIZE: ::std::os::raw::c_uint = 64;
pub const __WORDSIZE_TIME64_COMPAT32: ::std::os::raw::c_uint = 1;
pub const __SYSCALL_WORDSIZE: ::std::os::raw::c_uint = 64;
pub const _BITS_TYPES_H: ::std::os::raw::c_uint = 1;
pub const _BITS_TYPESIZES_H: ::std::os::raw::c_uint = 1;
pub const __OFF_T_MATCHES_OFF64_T: ::std::os::raw::c_uint = 1;
pub const __INO_T_MATCHES_INO64_T: ::std::os::raw::c_uint = 1;
pub const __FD_SETSIZE: ::std::os::raw::c_uint = 1024;
pub const __FILE_defined: ::std::os::raw::c_uint = 1;
pub const ____FILE_defined: ::std::os::raw::c_uint = 1;
pub const _G_config_h: ::std::os::raw::c_uint = 1;
pub const ____mbstate_t_defined: ::std::os::raw::c_uint = 1;
pub const _G_HAVE_MMAP: ::std::os::raw::c_uint = 1;
pub const _G_HAVE_MREMAP: ::std::os::raw::c_uint = 1;
pub const _G_IO_IO_FILE_VERSION: ::std::os::raw::c_uint = 131073;
pub const _G_BUFSIZ: ::std::os::raw::c_uint = 8192;
pub const _IO_BUFSIZ: ::std::os::raw::c_uint = 8192;
pub const __GNUC_VA_LIST: ::std::os::raw::c_uint = 1;
pub const _IO_UNIFIED_JUMPTABLES: ::std::os::raw::c_uint = 1;
pub const EOF: ::std::os::raw::c_int = -1;
pub const _IOS_INPUT: ::std::os::raw::c_uint = 1;
pub const _IOS_OUTPUT: ::std::os::raw::c_uint = 2;
pub const _IOS_ATEND: ::std::os::raw::c_uint = 4;
pub const _IOS_APPEND: ::std::os::raw::c_uint = 8;
pub const _IOS_TRUNC: ::std::os::raw::c_uint = 16;
pub const _IOS_NOCREATE: ::std::os::raw::c_uint = 32;
pub const _IOS_NOREPLACE: ::std::os::raw::c_uint = 64;
pub const _IOS_BIN: ::std::os::raw::c_uint = 128;
pub const _IO_MAGIC: ::std::os::raw::c_uint = 4222418944;
pub const _OLD_STDIO_MAGIC: ::std::os::raw::c_uint = 4206624768;
pub const _IO_MAGIC_MASK: ::std::os::raw::c_uint = 4294901760;
pub const _IO_USER_BUF: ::std::os::raw::c_uint = 1;
pub const _IO_UNBUFFERED: ::std::os::raw::c_uint = 2;
pub const _IO_NO_READS: ::std::os::raw::c_uint = 4;
pub const _IO_NO_WRITES: ::std::os::raw::c_uint = 8;
pub const _IO_EOF_SEEN: ::std::os::raw::c_uint = 16;
pub const _IO_ERR_SEEN: ::std::os::raw::c_uint = 32;
pub const _IO_DELETE_DONT_CLOSE: ::std::os::raw::c_uint = 64;
pub const _IO_LINKED: ::std::os::raw::c_uint = 128;
pub const _IO_IN_BACKUP: ::std::os::raw::c_uint = 256;
pub const _IO_LINE_BUF: ::std::os::raw::c_uint = 512;
pub const _IO_TIED_PUT_GET: ::std::os::raw::c_uint = 1024;
pub const _IO_CURRENTLY_PUTTING: ::std::os::raw::c_uint = 2048;
pub const _IO_IS_APPENDING: ::std::os::raw::c_uint = 4096;
pub const _IO_IS_FILEBUF: ::std::os::raw::c_uint = 8192;
pub const _IO_BAD_SEEN: ::std::os::raw::c_uint = 16384;
pub const _IO_USER_LOCK: ::std::os::raw::c_uint = 32768;
pub const _IO_FLAGS2_MMAP: ::std::os::raw::c_uint = 1;
pub const _IO_FLAGS2_NOTCANCEL: ::std::os::raw::c_uint = 2;
pub const _IO_FLAGS2_USER_WBUF: ::std::os::raw::c_uint = 8;
pub const _IO_SKIPWS: ::std::os::raw::c_uint = 1;
pub const _IO_LEFT: ::std::os::raw::c_uint = 2;
pub const _IO_RIGHT: ::std::os::raw::c_uint = 4;
pub const _IO_INTERNAL: ::std::os::raw::c_uint = 8;
pub const _IO_DEC: ::std::os::raw::c_uint = 16;
pub const _IO_OCT: ::std::os::raw::c_uint = 32;
pub const _IO_HEX: ::std::os::raw::c_uint = 64;
pub const _IO_SHOWBASE: ::std::os::raw::c_uint = 128;
pub const _IO_SHOWPOINT: ::std::os::raw::c_uint = 256;
pub const _IO_UPPERCASE: ::std::os::raw::c_uint = 512;
pub const _IO_SHOWPOS: ::std::os::raw::c_uint = 1024;
pub const _IO_SCIENTIFIC: ::std::os::raw::c_uint = 2048;
pub const _IO_FIXED: ::std::os::raw::c_uint = 4096;
pub const _IO_UNITBUF: ::std::os::raw::c_uint = 8192;
pub const _IO_STDIO: ::std::os::raw::c_uint = 16384;
pub const _IO_DONT_CLOSE: ::std::os::raw::c_uint = 32768;
pub const _IO_BOOLALPHA: ::std::os::raw::c_uint = 65536;
pub const _IOFBF: ::std::os::raw::c_uint = 0;
pub const _IOLBF: ::std::os::raw::c_uint = 1;
pub const _IONBF: ::std::os::raw::c_uint = 2;
pub const BUFSIZ: ::std::os::raw::c_uint = 8192;
pub const SEEK_SET: ::std::os::raw::c_uint = 0;
pub const SEEK_CUR: ::std::os::raw::c_uint = 1;
pub const SEEK_END: ::std::os::raw::c_uint = 2;
pub const P_tmpdir: &'static [u8; 5usize] = b"/tmp\x00";
pub const L_tmpnam: ::std::os::raw::c_uint = 20;
pub const TMP_MAX: ::std::os::raw::c_uint = 238328;
pub const FILENAME_MAX: ::std::os::raw::c_uint = 4096;
pub const L_ctermid: ::std::os::raw::c_uint = 9;
pub const FOPEN_MAX: ::std::os::raw::c_uint = 16;
pub const _STDLIB_H: ::std::os::raw::c_uint = 1;
pub const WNOHANG: ::std::os::raw::c_uint = 1;
pub const WUNTRACED: ::std::os::raw::c_uint = 2;
pub const WSTOPPED: ::std::os::raw::c_uint = 2;
pub const WEXITED: ::std::os::raw::c_uint = 4;
pub const WCONTINUED: ::std::os::raw::c_uint = 8;
pub const WNOWAIT: ::std::os::raw::c_uint = 16777216;
pub const __WNOTHREAD: ::std::os::raw::c_uint = 536870912;
pub const __WALL: ::std::os::raw::c_uint = 1073741824;
pub const __WCLONE: ::std::os::raw::c_uint = 2147483648;
pub const __ENUM_IDTYPE_T: ::std::os::raw::c_uint = 1;
pub const __W_CONTINUED: ::std::os::raw::c_uint = 65535;
pub const __WCOREFLAG: ::std::os::raw::c_uint = 128;
pub const _ENDIAN_H: ::std::os::raw::c_uint = 1;
pub const __LITTLE_ENDIAN: ::std::os::raw::c_uint = 1234;
pub const __BIG_ENDIAN: ::std::os::raw::c_uint = 4321;
pub const __PDP_ENDIAN: ::std::os::raw::c_uint = 3412;
pub const __BYTE_ORDER: ::std::os::raw::c_uint = 1234;
pub const __FLOAT_WORD_ORDER: ::std::os::raw::c_uint = 1234;
pub const LITTLE_ENDIAN: ::std::os::raw::c_uint = 1234;
pub const BIG_ENDIAN: ::std::os::raw::c_uint = 4321;
pub const PDP_ENDIAN: ::std::os::raw::c_uint = 3412;
pub const BYTE_ORDER: ::std::os::raw::c_uint = 1234;
pub const _BITS_BYTESWAP_H: ::std::os::raw::c_uint = 1;
pub const __ldiv_t_defined: ::std::os::raw::c_uint = 1;
pub const __lldiv_t_defined: ::std::os::raw::c_uint = 1;
pub const RAND_MAX: ::std::os::raw::c_uint = 2147483647;
pub const EXIT_FAILURE: ::std::os::raw::c_uint = 1;
pub const EXIT_SUCCESS: ::std::os::raw::c_uint = 0;
pub const _SYS_TYPES_H: ::std::os::raw::c_uint = 1;
pub const __clock_t_defined: ::std::os::raw::c_uint = 1;
pub const __time_t_defined: ::std::os::raw::c_uint = 1;
pub const __clockid_t_defined: ::std::os::raw::c_uint = 1;
pub const __timer_t_defined: ::std::os::raw::c_uint = 1;
pub const __BIT_TYPES_DEFINED__: ::std::os::raw::c_uint = 1;
pub const _SYS_SELECT_H: ::std::os::raw::c_uint = 1;
pub const __FD_ZERO_STOS: &'static [u8; 6usize] = b"stosq\x00";
pub const _SIGSET_H_types: ::std::os::raw::c_uint = 1;
pub const __timespec_defined: ::std::os::raw::c_uint = 1;
pub const _STRUCT_TIMEVAL: ::std::os::raw::c_uint = 1;
pub const FD_SETSIZE: ::std::os::raw::c_uint = 1024;
pub const _SYS_SYSMACROS_H: ::std::os::raw::c_uint = 1;
pub const _BITS_PTHREADTYPES_H: ::std::os::raw::c_uint = 1;
pub const __SIZEOF_PTHREAD_ATTR_T: ::std::os::raw::c_uint = 56;
pub const __SIZEOF_PTHREAD_MUTEX_T: ::std::os::raw::c_uint = 40;
pub const __SIZEOF_PTHREAD_MUTEXATTR_T: ::std::os::raw::c_uint = 4;
pub const __SIZEOF_PTHREAD_COND_T: ::std::os::raw::c_uint = 48;
pub const __SIZEOF_PTHREAD_CONDATTR_T: ::std::os::raw::c_uint = 4;
pub const __SIZEOF_PTHREAD_RWLOCK_T: ::std::os::raw::c_uint = 56;
pub const __SIZEOF_PTHREAD_RWLOCKATTR_T: ::std::os::raw::c_uint = 8;
pub const __SIZEOF_PTHREAD_BARRIER_T: ::std::os::raw::c_uint = 32;
pub const __SIZEOF_PTHREAD_BARRIERATTR_T: ::std::os::raw::c_uint = 4;
pub const __have_pthread_attr_t: ::std::os::raw::c_uint = 1;
pub const __PTHREAD_MUTEX_HAVE_PREV: ::std::os::raw::c_uint = 1;
pub const __PTHREAD_RWLOCK_INT_FLAGS_SHARED: ::std::os::raw::c_uint = 1;
pub const _ALLOCA_H: ::std::os::raw::c_uint = 1;
pub const _STRING_H: ::std::os::raw::c_uint = 1;
pub const _XLOCALE_H: ::std::os::raw::c_uint = 1;
pub const _LIBC_LIMITS_H_: ::std::os::raw::c_uint = 1;
pub const MB_LEN_MAX: ::std::os::raw::c_uint = 16;
pub const _BITS_POSIX1_LIM_H: ::std::os::raw::c_uint = 1;
pub const _POSIX_AIO_LISTIO_MAX: ::std::os::raw::c_uint = 2;
pub const _POSIX_AIO_MAX: ::std::os::raw::c_uint = 1;
pub const _POSIX_ARG_MAX: ::std::os::raw::c_uint = 4096;
pub const _POSIX_CHILD_MAX: ::std::os::raw::c_uint = 25;
pub const _POSIX_DELAYTIMER_MAX: ::std::os::raw::c_uint = 32;
pub const _POSIX_HOST_NAME_MAX: ::std::os::raw::c_uint = 255;
pub const _POSIX_LINK_MAX: ::std::os::raw::c_uint = 8;
pub const _POSIX_LOGIN_NAME_MAX: ::std::os::raw::c_uint = 9;
pub const _POSIX_MAX_CANON: ::std::os::raw::c_uint = 255;
pub const _POSIX_MAX_INPUT: ::std::os::raw::c_uint = 255;
pub const _POSIX_MQ_OPEN_MAX: ::std::os::raw::c_uint = 8;
pub const _POSIX_MQ_PRIO_MAX: ::std::os::raw::c_uint = 32;
pub const _POSIX_NAME_MAX: ::std::os::raw::c_uint = 14;
pub const _POSIX_NGROUPS_MAX: ::std::os::raw::c_uint = 8;
pub const _POSIX_OPEN_MAX: ::std::os::raw::c_uint = 20;
pub const _POSIX_PATH_MAX: ::std::os::raw::c_uint = 256;
pub const _POSIX_PIPE_BUF: ::std::os::raw::c_uint = 512;
pub const _POSIX_RE_DUP_MAX: ::std::os::raw::c_uint = 255;
pub const _POSIX_RTSIG_MAX: ::std::os::raw::c_uint = 8;
pub const _POSIX_SEM_NSEMS_MAX: ::std::os::raw::c_uint = 256;
pub const _POSIX_SEM_VALUE_MAX: ::std::os::raw::c_uint = 32767;
pub const _POSIX_SIGQUEUE_MAX: ::std::os::raw::c_uint = 32;
pub const _POSIX_SSIZE_MAX: ::std::os::raw::c_uint = 32767;
pub const _POSIX_STREAM_MAX: ::std::os::raw::c_uint = 8;
pub const _POSIX_SYMLINK_MAX: ::std::os::raw::c_uint = 255;
pub const _POSIX_SYMLOOP_MAX: ::std::os::raw::c_uint = 8;
pub const _POSIX_TIMER_MAX: ::std::os::raw::c_uint = 32;
pub const _POSIX_TTY_NAME_MAX: ::std::os::raw::c_uint = 9;
pub const _POSIX_TZNAME_MAX: ::std::os::raw::c_uint = 6;
pub const _POSIX_CLOCKRES_MIN: ::std::os::raw::c_uint = 20000000;
pub const NR_OPEN: ::std::os::raw::c_uint = 1024;
pub const NGROUPS_MAX: ::std::os::raw::c_uint = 65536;
pub const ARG_MAX: ::std::os::raw::c_uint = 131072;
pub const LINK_MAX: ::std::os::raw::c_uint = 127;
pub const MAX_CANON: ::std::os::raw::c_uint = 255;
pub const MAX_INPUT: ::std::os::raw::c_uint = 255;
pub const NAME_MAX: ::std::os::raw::c_uint = 255;
pub const PATH_MAX: ::std::os::raw::c_uint = 4096;
pub const PIPE_BUF: ::std::os::raw::c_uint = 4096;
pub const XATTR_NAME_MAX: ::std::os::raw::c_uint = 255;
pub const XATTR_SIZE_MAX: ::std::os::raw::c_uint = 65536;
pub const XATTR_LIST_MAX: ::std::os::raw::c_uint = 65536;
pub const RTSIG_MAX: ::std::os::raw::c_uint = 32;
pub const _POSIX_THREAD_KEYS_MAX: ::std::os::raw::c_uint = 128;
pub const PTHREAD_KEYS_MAX: ::std::os::raw::c_uint = 1024;
pub const _POSIX_THREAD_DESTRUCTOR_ITERATIONS: ::std::os::raw::c_uint = 4;
pub const PTHREAD_DESTRUCTOR_ITERATIONS: ::std::os::raw::c_uint = 4;
pub const _POSIX_THREAD_THREADS_MAX: ::std::os::raw::c_uint = 64;
pub const AIO_PRIO_DELTA_MAX: ::std::os::raw::c_uint = 20;
pub const PTHREAD_STACK_MIN: ::std::os::raw::c_uint = 16384;
pub const DELAYTIMER_MAX: ::std::os::raw::c_uint = 2147483647;
pub const TTY_NAME_MAX: ::std::os::raw::c_uint = 32;
pub const LOGIN_NAME_MAX: ::std::os::raw::c_uint = 256;
pub const HOST_NAME_MAX: ::std::os::raw::c_uint = 64;
pub const MQ_PRIO_MAX: ::std::os::raw::c_uint = 32768;
pub const SEM_VALUE_MAX: ::std::os::raw::c_uint = 2147483647;
pub const _BITS_POSIX2_LIM_H: ::std::os::raw::c_uint = 1;
pub const _POSIX2_BC_BASE_MAX: ::std::os::raw::c_uint = 99;
pub const _POSIX2_BC_DIM_MAX: ::std::os::raw::c_uint = 2048;
pub const _POSIX2_BC_SCALE_MAX: ::std::os::raw::c_uint = 99;
pub const _POSIX2_BC_STRING_MAX: ::std::os::raw::c_uint = 1000;
pub const _POSIX2_COLL_WEIGHTS_MAX: ::std::os::raw::c_uint = 2;
pub const _POSIX2_EXPR_NEST_MAX: ::std::os::raw::c_uint = 32;
pub const _POSIX2_LINE_MAX: ::std::os::raw::c_uint = 2048;
pub const _POSIX2_RE_DUP_MAX: ::std::os::raw::c_uint = 255;
pub const _POSIX2_CHARCLASS_NAME_MAX: ::std::os::raw::c_uint = 14;
pub const BC_BASE_MAX: ::std::os::raw::c_uint = 99;
pub const BC_DIM_MAX: ::std::os::raw::c_uint = 2048;
pub const BC_SCALE_MAX: ::std::os::raw::c_uint = 99;
pub const BC_STRING_MAX: ::std::os::raw::c_uint = 1000;
pub const COLL_WEIGHTS_MAX: ::std::os::raw::c_uint = 255;
pub const EXPR_NEST_MAX: ::std::os::raw::c_uint = 32;
pub const LINE_MAX: ::std::os::raw::c_uint = 2048;
pub const CHARCLASS_NAME_MAX: ::std::os::raw::c_uint = 2048;
pub const RE_DUP_MAX: ::std::os::raw::c_uint = 32767;
pub const _INTTYPES_H: ::std::os::raw::c_uint = 1;
pub const _STDINT_H: ::std::os::raw::c_uint = 1;
pub const _BITS_WCHAR_H: ::std::os::raw::c_uint = 1;
pub const INT8_MIN: ::std::os::raw::c_int = -128;
pub const INT16_MIN: ::std::os::raw::c_int = -32768;
pub const INT32_MIN: ::std::os::raw::c_int = -2147483648;
pub const INT8_MAX: ::std::os::raw::c_uint = 127;
pub const INT16_MAX: ::std::os::raw::c_uint = 32767;
pub const INT32_MAX: ::std::os::raw::c_uint = 2147483647;
pub const UINT8_MAX: ::std::os::raw::c_uint = 255;
pub const UINT16_MAX: ::std::os::raw::c_uint = 65535;
pub const UINT32_MAX: ::std::os::raw::c_uint = 4294967295;
pub const INT_LEAST8_MIN: ::std::os::raw::c_int = -128;
pub const INT_LEAST16_MIN: ::std::os::raw::c_int = -32768;
pub const INT_LEAST32_MIN: ::std::os::raw::c_int = -2147483648;
pub const INT_LEAST8_MAX: ::std::os::raw::c_uint = 127;
pub const INT_LEAST16_MAX: ::std::os::raw::c_uint = 32767;
pub const INT_LEAST32_MAX: ::std::os::raw::c_uint = 2147483647;
pub const UINT_LEAST8_MAX: ::std::os::raw::c_uint = 255;
pub const UINT_LEAST16_MAX: ::std::os::raw::c_uint = 65535;
pub const UINT_LEAST32_MAX: ::std::os::raw::c_uint = 4294967295;
pub const INT_FAST8_MIN: ::std::os::raw::c_int = -128;
pub const INT_FAST16_MIN: ::std::os::raw::c_longlong = -9223372036854775808;
pub const INT_FAST32_MIN: ::std::os::raw::c_longlong = -9223372036854775808;
pub const INT_FAST8_MAX: ::std::os::raw::c_uint = 127;
pub const INT_FAST16_MAX: ::std::os::raw::c_ulonglong = 9223372036854775807;
pub const INT_FAST32_MAX: ::std::os::raw::c_ulonglong = 9223372036854775807;
pub const UINT_FAST8_MAX: ::std::os::raw::c_uint = 255;
pub const UINT_FAST16_MAX: ::std::os::raw::c_int = -1;
pub const UINT_FAST32_MAX: ::std::os::raw::c_int = -1;
pub const INTPTR_MIN: ::std::os::raw::c_longlong = -9223372036854775808;
pub const INTPTR_MAX: ::std::os::raw::c_ulonglong = 9223372036854775807;
pub const UINTPTR_MAX: ::std::os::raw::c_int = -1;
pub const PTRDIFF_MIN: ::std::os::raw::c_longlong = -9223372036854775808;
pub const PTRDIFF_MAX: ::std::os::raw::c_ulonglong = 9223372036854775807;
pub const SIG_ATOMIC_MIN: ::std::os::raw::c_int = -2147483648;
pub const SIG_ATOMIC_MAX: ::std::os::raw::c_uint = 2147483647;
pub const SIZE_MAX: ::std::os::raw::c_int = -1;
pub const WINT_MIN: ::std::os::raw::c_uint = 0;
pub const WINT_MAX: ::std::os::raw::c_uint = 4294967295;
pub const ____gwchar_t_defined: ::std::os::raw::c_uint = 1;
pub const __PRI64_PREFIX: &'static [u8; 2usize] = b"l\x00";
pub const __PRIPTR_PREFIX: &'static [u8; 2usize] = b"l\x00";
pub const PRId8: &'static [u8; 2usize] = b"d\x00";
pub const PRId16: &'static [u8; 2usize] = b"d\x00";
pub const PRId32: &'static [u8; 2usize] = b"d\x00";
pub const PRId64: &'static [u8; 3usize] = b"ld\x00";
pub const PRIdLEAST8: &'static [u8; 2usize] = b"d\x00";
pub const PRIdLEAST16: &'static [u8; 2usize] = b"d\x00";
pub const PRIdLEAST32: &'static [u8; 2usize] = b"d\x00";
pub const PRIdLEAST64: &'static [u8; 3usize] = b"ld\x00";
pub const PRIdFAST8: &'static [u8; 2usize] = b"d\x00";
pub const PRIdFAST16: &'static [u8; 3usize] = b"ld\x00";
pub const PRIdFAST32: &'static [u8; 3usize] = b"ld\x00";
pub const PRIdFAST64: &'static [u8; 3usize] = b"ld\x00";
pub const PRIi8: &'static [u8; 2usize] = b"i\x00";
pub const PRIi16: &'static [u8; 2usize] = b"i\x00";
pub const PRIi32: &'static [u8; 2usize] = b"i\x00";
pub const PRIi64: &'static [u8; 3usize] = b"li\x00";
pub const PRIiLEAST8: &'static [u8; 2usize] = b"i\x00";
pub const PRIiLEAST16: &'static [u8; 2usize] = b"i\x00";
pub const PRIiLEAST32: &'static [u8; 2usize] = b"i\x00";
pub const PRIiLEAST64: &'static [u8; 3usize] = b"li\x00";
pub const PRIiFAST8: &'static [u8; 2usize] = b"i\x00";
pub const PRIiFAST16: &'static [u8; 3usize] = b"li\x00";
pub const PRIiFAST32: &'static [u8; 3usize] = b"li\x00";
pub const PRIiFAST64: &'static [u8; 3usize] = b"li\x00";
pub const PRIo8: &'static [u8; 2usize] = b"o\x00";
pub const PRIo16: &'static [u8; 2usize] = b"o\x00";
pub const PRIo32: &'static [u8; 2usize] = b"o\x00";
pub const PRIo64: &'static [u8; 3usize] = b"lo\x00";
pub const PRIoLEAST8: &'static [u8; 2usize] = b"o\x00";
pub const PRIoLEAST16: &'static [u8; 2usize] = b"o\x00";
pub const PRIoLEAST32: &'static [u8; 2usize] = b"o\x00";
pub const PRIoLEAST64: &'static [u8; 3usize] = b"lo\x00";
pub const PRIoFAST8: &'static [u8; 2usize] = b"o\x00";
pub const PRIoFAST16: &'static [u8; 3usize] = b"lo\x00";
pub const PRIoFAST32: &'static [u8; 3usize] = b"lo\x00";
pub const PRIoFAST64: &'static [u8; 3usize] = b"lo\x00";
pub const PRIu8: &'static [u8; 2usize] = b"u\x00";
pub const PRIu16: &'static [u8; 2usize] = b"u\x00";
pub const PRIu32: &'static [u8; 2usize] = b"u\x00";
pub const PRIu64: &'static [u8; 3usize] = b"lu\x00";
pub const PRIuLEAST8: &'static [u8; 2usize] = b"u\x00";
pub const PRIuLEAST16: &'static [u8; 2usize] = b"u\x00";
pub const PRIuLEAST32: &'static [u8; 2usize] = b"u\x00";
pub const PRIuLEAST64: &'static [u8; 3usize] = b"lu\x00";
pub const PRIuFAST8: &'static [u8; 2usize] = b"u\x00";
pub const PRIuFAST16: &'static [u8; 3usize] = b"lu\x00";
pub const PRIuFAST32: &'static [u8; 3usize] = b"lu\x00";
pub const PRIuFAST64: &'static [u8; 3usize] = b"lu\x00";
pub const PRIx8: &'static [u8; 2usize] = b"x\x00";
pub const PRIx16: &'static [u8; 2usize] = b"x\x00";
pub const PRIx32: &'static [u8; 2usize] = b"x\x00";
pub const PRIx64: &'static [u8; 3usize] = b"lx\x00";
pub const PRIxLEAST8: &'static [u8; 2usize] = b"x\x00";
pub const PRIxLEAST16: &'static [u8; 2usize] = b"x\x00";
pub const PRIxLEAST32: &'static [u8; 2usize] = b"x\x00";
pub const PRIxLEAST64: &'static [u8; 3usize] = b"lx\x00";
pub const PRIxFAST8: &'static [u8; 2usize] = b"x\x00";
pub const PRIxFAST16: &'static [u8; 3usize] = b"lx\x00";
pub const PRIxFAST32: &'static [u8; 3usize] = b"lx\x00";
pub const PRIxFAST64: &'static [u8; 3usize] = b"lx\x00";
pub const PRIX8: &'static [u8; 2usize] = b"X\x00";
pub const PRIX16: &'static [u8; 2usize] = b"X\x00";
pub const PRIX32: &'static [u8; 2usize] = b"X\x00";
pub const PRIX64: &'static [u8; 3usize] = b"lX\x00";
pub const PRIXLEAST8: &'static [u8; 2usize] = b"X\x00";
pub const PRIXLEAST16: &'static [u8; 2usize] = b"X\x00";
pub const PRIXLEAST32: &'static [u8; 2usize] = b"X\x00";
pub const PRIXLEAST64: &'static [u8; 3usize] = b"lX\x00";
pub const PRIXFAST8: &'static [u8; 2usize] = b"X\x00";
pub const PRIXFAST16: &'static [u8; 3usize] = b"lX\x00";
pub const PRIXFAST32: &'static [u8; 3usize] = b"lX\x00";
pub const PRIXFAST64: &'static [u8; 3usize] = b"lX\x00";
pub const PRIdMAX: &'static [u8; 3usize] = b"ld\x00";
pub const PRIiMAX: &'static [u8; 3usize] = b"li\x00";
pub const PRIoMAX: &'static [u8; 3usize] = b"lo\x00";
pub const PRIuMAX: &'static [u8; 3usize] = b"lu\x00";
pub const PRIxMAX: &'static [u8; 3usize] = b"lx\x00";
pub const PRIXMAX: &'static [u8; 3usize] = b"lX\x00";
pub const PRIdPTR: &'static [u8; 3usize] = b"ld\x00";
pub const PRIiPTR: &'static [u8; 3usize] = b"li\x00";
pub const PRIoPTR: &'static [u8; 3usize] = b"lo\x00";
pub const PRIuPTR: &'static [u8; 3usize] = b"lu\x00";
pub const PRIxPTR: &'static [u8; 3usize] = b"lx\x00";
pub const PRIXPTR: &'static [u8; 3usize] = b"lX\x00";
pub const SCNd8: &'static [u8; 4usize] = b"hhd\x00";
pub const SCNd16: &'static [u8; 3usize] = b"hd\x00";
pub const SCNd32: &'static [u8; 2usize] = b"d\x00";
pub const SCNd64: &'static [u8; 3usize] = b"ld\x00";
pub const SCNdLEAST8: &'static [u8; 4usize] = b"hhd\x00";
pub const SCNdLEAST16: &'static [u8; 3usize] = b"hd\x00";
pub const SCNdLEAST32: &'static [u8; 2usize] = b"d\x00";
pub const SCNdLEAST64: &'static [u8; 3usize] = b"ld\x00";
pub const SCNdFAST8: &'static [u8; 4usize] = b"hhd\x00";
pub const SCNdFAST16: &'static [u8; 3usize] = b"ld\x00";
pub const SCNdFAST32: &'static [u8; 3usize] = b"ld\x00";
pub const SCNdFAST64: &'static [u8; 3usize] = b"ld\x00";
pub const SCNi8: &'static [u8; 4usize] = b"hhi\x00";
pub const SCNi16: &'static [u8; 3usize] = b"hi\x00";
pub const SCNi32: &'static [u8; 2usize] = b"i\x00";
pub const SCNi64: &'static [u8; 3usize] = b"li\x00";
pub const SCNiLEAST8: &'static [u8; 4usize] = b"hhi\x00";
pub const SCNiLEAST16: &'static [u8; 3usize] = b"hi\x00";
pub const SCNiLEAST32: &'static [u8; 2usize] = b"i\x00";
pub const SCNiLEAST64: &'static [u8; 3usize] = b"li\x00";
pub const SCNiFAST8: &'static [u8; 4usize] = b"hhi\x00";
pub const SCNiFAST16: &'static [u8; 3usize] = b"li\x00";
pub const SCNiFAST32: &'static [u8; 3usize] = b"li\x00";
pub const SCNiFAST64: &'static [u8; 3usize] = b"li\x00";
pub const SCNu8: &'static [u8; 4usize] = b"hhu\x00";
pub const SCNu16: &'static [u8; 3usize] = b"hu\x00";
pub const SCNu32: &'static [u8; 2usize] = b"u\x00";
pub const SCNu64: &'static [u8; 3usize] = b"lu\x00";
pub const SCNuLEAST8: &'static [u8; 4usize] = b"hhu\x00";
pub const SCNuLEAST16: &'static [u8; 3usize] = b"hu\x00";
pub const SCNuLEAST32: &'static [u8; 2usize] = b"u\x00";
pub const SCNuLEAST64: &'static [u8; 3usize] = b"lu\x00";
pub const SCNuFAST8: &'static [u8; 4usize] = b"hhu\x00";
pub const SCNuFAST16: &'static [u8; 3usize] = b"lu\x00";
pub const SCNuFAST32: &'static [u8; 3usize] = b"lu\x00";
pub const SCNuFAST64: &'static [u8; 3usize] = b"lu\x00";
pub const SCNo8: &'static [u8; 4usize] = b"hho\x00";
pub const SCNo16: &'static [u8; 3usize] = b"ho\x00";
pub const SCNo32: &'static [u8; 2usize] = b"o\x00";
pub const SCNo64: &'static [u8; 3usize] = b"lo\x00";
pub const SCNoLEAST8: &'static [u8; 4usize] = b"hho\x00";
pub const SCNoLEAST16: &'static [u8; 3usize] = b"ho\x00";
pub const SCNoLEAST32: &'static [u8; 2usize] = b"o\x00";
pub const SCNoLEAST64: &'static [u8; 3usize] = b"lo\x00";
pub const SCNoFAST8: &'static [u8; 4usize] = b"hho\x00";
pub const SCNoFAST16: &'static [u8; 3usize] = b"lo\x00";
pub const SCNoFAST32: &'static [u8; 3usize] = b"lo\x00";
pub const SCNoFAST64: &'static [u8; 3usize] = b"lo\x00";
pub const SCNx8: &'static [u8; 4usize] = b"hhx\x00";
pub const SCNx16: &'static [u8; 3usize] = b"hx\x00";
pub const SCNx32: &'static [u8; 2usize] = b"x\x00";
pub const SCNx64: &'static [u8; 3usize] = b"lx\x00";
pub const SCNxLEAST8: &'static [u8; 4usize] = b"hhx\x00";
pub const SCNxLEAST16: &'static [u8; 3usize] = b"hx\x00";
pub const SCNxLEAST32: &'static [u8; 2usize] = b"x\x00";
pub const SCNxLEAST64: &'static [u8; 3usize] = b"lx\x00";
pub const SCNxFAST8: &'static [u8; 4usize] = b"hhx\x00";
pub const SCNxFAST16: &'static [u8; 3usize] = b"lx\x00";
pub const SCNxFAST32: &'static [u8; 3usize] = b"lx\x00";
pub const SCNxFAST64: &'static [u8; 3usize] = b"lx\x00";
pub const SCNdMAX: &'static [u8; 3usize] = b"ld\x00";
pub const SCNiMAX: &'static [u8; 3usize] = b"li\x00";
pub const SCNoMAX: &'static [u8; 3usize] = b"lo\x00";
pub const SCNuMAX: &'static [u8; 3usize] = b"lu\x00";
pub const SCNxMAX: &'static [u8; 3usize] = b"lx\x00";
pub const SCNdPTR: &'static [u8; 3usize] = b"ld\x00";
pub const SCNiPTR: &'static [u8; 3usize] = b"li\x00";
pub const SCNoPTR: &'static [u8; 3usize] = b"lo\x00";
pub const SCNuPTR: &'static [u8; 3usize] = b"lu\x00";
pub const SCNxPTR: &'static [u8; 3usize] = b"lx\x00";
pub const _NETINET_IN_H: ::std::os::raw::c_uint = 1;
pub const _SYS_SOCKET_H: ::std::os::raw::c_uint = 1;
pub const _SYS_UIO_H: ::std::os::raw::c_uint = 1;
pub const _BITS_UIO_H: ::std::os::raw::c_uint = 1;
pub const UIO_MAXIOV: ::std::os::raw::c_uint = 1024;
pub const PF_UNSPEC: ::std::os::raw::c_uint = 0;
pub const PF_LOCAL: ::std::os::raw::c_uint = 1;
pub const PF_UNIX: ::std::os::raw::c_uint = 1;
pub const PF_FILE: ::std::os::raw::c_uint = 1;
pub const PF_INET: ::std::os::raw::c_uint = 2;
pub const PF_AX25: ::std::os::raw::c_uint = 3;
pub const PF_IPX: ::std::os::raw::c_uint = 4;
pub const PF_APPLETALK: ::std::os::raw::c_uint = 5;
pub const PF_NETROM: ::std::os::raw::c_uint = 6;
pub const PF_BRIDGE: ::std::os::raw::c_uint = 7;
pub const PF_ATMPVC: ::std::os::raw::c_uint = 8;
pub const PF_X25: ::std::os::raw::c_uint = 9;
pub const PF_INET6: ::std::os::raw::c_uint = 10;
pub const PF_ROSE: ::std::os::raw::c_uint = 11;
pub const PF_DECnet: ::std::os::raw::c_uint = 12;
pub const PF_NETBEUI: ::std::os::raw::c_uint = 13;
pub const PF_SECURITY: ::std::os::raw::c_uint = 14;
pub const PF_KEY: ::std::os::raw::c_uint = 15;
pub const PF_NETLINK: ::std::os::raw::c_uint = 16;
pub const PF_ROUTE: ::std::os::raw::c_uint = 16;
pub const PF_PACKET: ::std::os::raw::c_uint = 17;
pub const PF_ASH: ::std::os::raw::c_uint = 18;
pub const PF_ECONET: ::std::os::raw::c_uint = 19;
pub const PF_ATMSVC: ::std::os::raw::c_uint = 20;
pub const PF_RDS: ::std::os::raw::c_uint = 21;
pub const PF_SNA: ::std::os::raw::c_uint = 22;
pub const PF_IRDA: ::std::os::raw::c_uint = 23;
pub const PF_PPPOX: ::std::os::raw::c_uint = 24;
pub const PF_WANPIPE: ::std::os::raw::c_uint = 25;
pub const PF_LLC: ::std::os::raw::c_uint = 26;
pub const PF_IB: ::std::os::raw::c_uint = 27;
pub const PF_MPLS: ::std::os::raw::c_uint = 28;
pub const PF_CAN: ::std::os::raw::c_uint = 29;
pub const PF_TIPC: ::std::os::raw::c_uint = 30;
pub const PF_BLUETOOTH: ::std::os::raw::c_uint = 31;
pub const PF_IUCV: ::std::os::raw::c_uint = 32;
pub const PF_RXRPC: ::std::os::raw::c_uint = 33;
pub const PF_ISDN: ::std::os::raw::c_uint = 34;
pub const PF_PHONET: ::std::os::raw::c_uint = 35;
pub const PF_IEEE802154: ::std::os::raw::c_uint = 36;
pub const PF_CAIF: ::std::os::raw::c_uint = 37;
pub const PF_ALG: ::std::os::raw::c_uint = 38;
pub const PF_NFC: ::std::os::raw::c_uint = 39;
pub const PF_VSOCK: ::std::os::raw::c_uint = 40;
pub const PF_MAX: ::std::os::raw::c_uint = 41;
pub const AF_UNSPEC: ::std::os::raw::c_uint = 0;
pub const AF_LOCAL: ::std::os::raw::c_uint = 1;
pub const AF_UNIX: ::std::os::raw::c_uint = 1;
pub const AF_FILE: ::std::os::raw::c_uint = 1;
pub const AF_INET: ::std::os::raw::c_uint = 2;
pub const AF_AX25: ::std::os::raw::c_uint = 3;
pub const AF_IPX: ::std::os::raw::c_uint = 4;
pub const AF_APPLETALK: ::std::os::raw::c_uint = 5;
pub const AF_NETROM: ::std::os::raw::c_uint = 6;
pub const AF_BRIDGE: ::std::os::raw::c_uint = 7;
pub const AF_ATMPVC: ::std::os::raw::c_uint = 8;
pub const AF_X25: ::std::os::raw::c_uint = 9;
pub const AF_INET6: ::std::os::raw::c_uint = 10;
pub const AF_ROSE: ::std::os::raw::c_uint = 11;
pub const AF_DECnet: ::std::os::raw::c_uint = 12;
pub const AF_NETBEUI: ::std::os::raw::c_uint = 13;
pub const AF_SECURITY: ::std::os::raw::c_uint = 14;
pub const AF_KEY: ::std::os::raw::c_uint = 15;
pub const AF_NETLINK: ::std::os::raw::c_uint = 16;
pub const AF_ROUTE: ::std::os::raw::c_uint = 16;
pub const AF_PACKET: ::std::os::raw::c_uint = 17;
pub const AF_ASH: ::std::os::raw::c_uint = 18;
pub const AF_ECONET: ::std::os::raw::c_uint = 19;
pub const AF_ATMSVC: ::std::os::raw::c_uint = 20;
pub const AF_RDS: ::std::os::raw::c_uint = 21;
pub const AF_SNA: ::std::os::raw::c_uint = 22;
pub const AF_IRDA: ::std::os::raw::c_uint = 23;
pub const AF_PPPOX: ::std::os::raw::c_uint = 24;
pub const AF_WANPIPE: ::std::os::raw::c_uint = 25;
pub const AF_LLC: ::std::os::raw::c_uint = 26;
pub const AF_IB: ::std::os::raw::c_uint = 27;
pub const AF_MPLS: ::std::os::raw::c_uint = 28;
pub const AF_CAN: ::std::os::raw::c_uint = 29;
pub const AF_TIPC: ::std::os::raw::c_uint = 30;
pub const AF_BLUETOOTH: ::std::os::raw::c_uint = 31;
pub const AF_IUCV: ::std::os::raw::c_uint = 32;
pub const AF_RXRPC: ::std::os::raw::c_uint = 33;
pub const AF_ISDN: ::std::os::raw::c_uint = 34;
pub const AF_PHONET: ::std::os::raw::c_uint = 35;
pub const AF_IEEE802154: ::std::os::raw::c_uint = 36;
pub const AF_CAIF: ::std::os::raw::c_uint = 37;
pub const AF_ALG: ::std::os::raw::c_uint = 38;
pub const AF_NFC: ::std::os::raw::c_uint = 39;
pub const AF_VSOCK: ::std::os::raw::c_uint = 40;
pub const AF_MAX: ::std::os::raw::c_uint = 41;
pub const SOL_RAW: ::std::os::raw::c_uint = 255;
pub const SOL_DECNET: ::std::os::raw::c_uint = 261;
pub const SOL_X25: ::std::os::raw::c_uint = 262;
pub const SOL_PACKET: ::std::os::raw::c_uint = 263;
pub const SOL_ATM: ::std::os::raw::c_uint = 264;
pub const SOL_AAL: ::std::os::raw::c_uint = 265;
pub const SOL_IRDA: ::std::os::raw::c_uint = 266;
pub const SOMAXCONN: ::std::os::raw::c_uint = 128;
pub const _BITS_SOCKADDR_H: ::std::os::raw::c_uint = 1;
pub const _SS_SIZE: ::std::os::raw::c_uint = 128;
pub const FIOSETOWN: ::std::os::raw::c_uint = 35073;
pub const SIOCSPGRP: ::std::os::raw::c_uint = 35074;
pub const FIOGETOWN: ::std::os::raw::c_uint = 35075;
pub const SIOCGPGRP: ::std::os::raw::c_uint = 35076;
pub const SIOCATMARK: ::std::os::raw::c_uint = 35077;
pub const SIOCGSTAMP: ::std::os::raw::c_uint = 35078;
pub const SIOCGSTAMPNS: ::std::os::raw::c_uint = 35079;
pub const SOL_SOCKET: ::std::os::raw::c_uint = 1;
pub const SO_DEBUG: ::std::os::raw::c_uint = 1;
pub const SO_REUSEADDR: ::std::os::raw::c_uint = 2;
pub const SO_TYPE: ::std::os::raw::c_uint = 3;
pub const SO_ERROR: ::std::os::raw::c_uint = 4;
pub const SO_DONTROUTE: ::std::os::raw::c_uint = 5;
pub const SO_BROADCAST: ::std::os::raw::c_uint = 6;
pub const SO_SNDBUF: ::std::os::raw::c_uint = 7;
pub const SO_RCVBUF: ::std::os::raw::c_uint = 8;
pub const SO_SNDBUFFORCE: ::std::os::raw::c_uint = 32;
pub const SO_RCVBUFFORCE: ::std::os::raw::c_uint = 33;
pub const SO_KEEPALIVE: ::std::os::raw::c_uint = 9;
pub const SO_OOBINLINE: ::std::os::raw::c_uint = 10;
pub const SO_NO_CHECK: ::std::os::raw::c_uint = 11;
pub const SO_PRIORITY: ::std::os::raw::c_uint = 12;
pub const SO_LINGER: ::std::os::raw::c_uint = 13;
pub const SO_BSDCOMPAT: ::std::os::raw::c_uint = 14;
pub const SO_REUSEPORT: ::std::os::raw::c_uint = 15;
pub const SO_PASSCRED: ::std::os::raw::c_uint = 16;
pub const SO_PEERCRED: ::std::os::raw::c_uint = 17;
pub const SO_RCVLOWAT: ::std::os::raw::c_uint = 18;
pub const SO_SNDLOWAT: ::std::os::raw::c_uint = 19;
pub const SO_RCVTIMEO: ::std::os::raw::c_uint = 20;
pub const SO_SNDTIMEO: ::std::os::raw::c_uint = 21;
pub const SO_SECURITY_AUTHENTICATION: ::std::os::raw::c_uint = 22;
pub const SO_SECURITY_ENCRYPTION_TRANSPORT: ::std::os::raw::c_uint = 23;
pub const SO_SECURITY_ENCRYPTION_NETWORK: ::std::os::raw::c_uint = 24;
pub const SO_BINDTODEVICE: ::std::os::raw::c_uint = 25;
pub const SO_ATTACH_FILTER: ::std::os::raw::c_uint = 26;
pub const SO_DETACH_FILTER: ::std::os::raw::c_uint = 27;
pub const SO_GET_FILTER: ::std::os::raw::c_uint = 26;
pub const SO_PEERNAME: ::std::os::raw::c_uint = 28;
pub const SO_TIMESTAMP: ::std::os::raw::c_uint = 29;
pub const SCM_TIMESTAMP: ::std::os::raw::c_uint = 29;
pub const SO_ACCEPTCONN: ::std::os::raw::c_uint = 30;
pub const SO_PEERSEC: ::std::os::raw::c_uint = 31;
pub const SO_PASSSEC: ::std::os::raw::c_uint = 34;
pub const SO_TIMESTAMPNS: ::std::os::raw::c_uint = 35;
pub const SCM_TIMESTAMPNS: ::std::os::raw::c_uint = 35;
pub const SO_MARK: ::std::os::raw::c_uint = 36;
pub const SO_TIMESTAMPING: ::std::os::raw::c_uint = 37;
pub const SCM_TIMESTAMPING: ::std::os::raw::c_uint = 37;
pub const SO_PROTOCOL: ::std::os::raw::c_uint = 38;
pub const SO_DOMAIN: ::std::os::raw::c_uint = 39;
pub const SO_RXQ_OVFL: ::std::os::raw::c_uint = 40;
pub const SO_WIFI_STATUS: ::std::os::raw::c_uint = 41;
pub const SCM_WIFI_STATUS: ::std::os::raw::c_uint = 41;
pub const SO_PEEK_OFF: ::std::os::raw::c_uint = 42;
pub const SO_NOFCS: ::std::os::raw::c_uint = 43;
pub const SO_LOCK_FILTER: ::std::os::raw::c_uint = 44;
pub const SO_SELECT_ERR_QUEUE: ::std::os::raw::c_uint = 45;
pub const SO_BUSY_POLL: ::std::os::raw::c_uint = 46;
pub const SO_MAX_PACING_RATE: ::std::os::raw::c_uint = 47;
pub const SO_BPF_EXTENSIONS: ::std::os::raw::c_uint = 48;
pub const SO_INCOMING_CPU: ::std::os::raw::c_uint = 49;
pub const SO_ATTACH_BPF: ::std::os::raw::c_uint = 50;
pub const SO_DETACH_BPF: ::std::os::raw::c_uint = 27;
pub const IP_OPTIONS: ::std::os::raw::c_uint = 4;
pub const IP_HDRINCL: ::std::os::raw::c_uint = 3;
pub const IP_TOS: ::std::os::raw::c_uint = 1;
pub const IP_TTL: ::std::os::raw::c_uint = 2;
pub const IP_RECVOPTS: ::std::os::raw::c_uint = 6;
pub const IP_RETOPTS: ::std::os::raw::c_uint = 7;
pub const IP_MULTICAST_IF: ::std::os::raw::c_uint = 32;
pub const IP_MULTICAST_TTL: ::std::os::raw::c_uint = 33;
pub const IP_MULTICAST_LOOP: ::std::os::raw::c_uint = 34;
pub const IP_ADD_MEMBERSHIP: ::std::os::raw::c_uint = 35;
pub const IP_DROP_MEMBERSHIP: ::std::os::raw::c_uint = 36;
pub const IP_UNBLOCK_SOURCE: ::std::os::raw::c_uint = 37;
pub const IP_BLOCK_SOURCE: ::std::os::raw::c_uint = 38;
pub const IP_ADD_SOURCE_MEMBERSHIP: ::std::os::raw::c_uint = 39;
pub const IP_DROP_SOURCE_MEMBERSHIP: ::std::os::raw::c_uint = 40;
pub const IP_MSFILTER: ::std::os::raw::c_uint = 41;
pub const MCAST_JOIN_GROUP: ::std::os::raw::c_uint = 42;
pub const MCAST_BLOCK_SOURCE: ::std::os::raw::c_uint = 43;
pub const MCAST_UNBLOCK_SOURCE: ::std::os::raw::c_uint = 44;
pub const MCAST_LEAVE_GROUP: ::std::os::raw::c_uint = 45;
pub const MCAST_JOIN_SOURCE_GROUP: ::std::os::raw::c_uint = 46;
pub const MCAST_LEAVE_SOURCE_GROUP: ::std::os::raw::c_uint = 47;
pub const MCAST_MSFILTER: ::std::os::raw::c_uint = 48;
pub const IP_MULTICAST_ALL: ::std::os::raw::c_uint = 49;
pub const IP_UNICAST_IF: ::std::os::raw::c_uint = 50;
pub const MCAST_EXCLUDE: ::std::os::raw::c_uint = 0;
pub const MCAST_INCLUDE: ::std::os::raw::c_uint = 1;
pub const IP_ROUTER_ALERT: ::std::os::raw::c_uint = 5;
pub const IP_PKTINFO: ::std::os::raw::c_uint = 8;
pub const IP_PKTOPTIONS: ::std::os::raw::c_uint = 9;
pub const IP_PMTUDISC: ::std::os::raw::c_uint = 10;
pub const IP_MTU_DISCOVER: ::std::os::raw::c_uint = 10;
pub const IP_RECVERR: ::std::os::raw::c_uint = 11;
pub const IP_RECVTTL: ::std::os::raw::c_uint = 12;
pub const IP_RECVTOS: ::std::os::raw::c_uint = 13;
pub const IP_MTU: ::std::os::raw::c_uint = 14;
pub const IP_FREEBIND: ::std::os::raw::c_uint = 15;
pub const IP_IPSEC_POLICY: ::std::os::raw::c_uint = 16;
pub const IP_XFRM_POLICY: ::std::os::raw::c_uint = 17;
pub const IP_PASSSEC: ::std::os::raw::c_uint = 18;
pub const IP_TRANSPARENT: ::std::os::raw::c_uint = 19;
pub const IP_ORIGDSTADDR: ::std::os::raw::c_uint = 20;
pub const IP_RECVORIGDSTADDR: ::std::os::raw::c_uint = 20;
pub const IP_MINTTL: ::std::os::raw::c_uint = 21;
pub const IP_NODEFRAG: ::std::os::raw::c_uint = 22;
pub const IP_CHECKSUM: ::std::os::raw::c_uint = 23;
pub const IP_BIND_ADDRESS_NO_PORT: ::std::os::raw::c_uint = 24;
pub const IP_PMTUDISC_DONT: ::std::os::raw::c_uint = 0;
pub const IP_PMTUDISC_WANT: ::std::os::raw::c_uint = 1;
pub const IP_PMTUDISC_DO: ::std::os::raw::c_uint = 2;
pub const IP_PMTUDISC_PROBE: ::std::os::raw::c_uint = 3;
pub const IP_PMTUDISC_INTERFACE: ::std::os::raw::c_uint = 4;
pub const IP_PMTUDISC_OMIT: ::std::os::raw::c_uint = 5;
pub const SOL_IP: ::std::os::raw::c_uint = 0;
pub const IP_DEFAULT_MULTICAST_TTL: ::std::os::raw::c_uint = 1;
pub const IP_DEFAULT_MULTICAST_LOOP: ::std::os::raw::c_uint = 1;
pub const IP_MAX_MEMBERSHIPS: ::std::os::raw::c_uint = 20;
pub const IPV6_ADDRFORM: ::std::os::raw::c_uint = 1;
pub const IPV6_2292PKTINFO: ::std::os::raw::c_uint = 2;
pub const IPV6_2292HOPOPTS: ::std::os::raw::c_uint = 3;
pub const IPV6_2292DSTOPTS: ::std::os::raw::c_uint = 4;
pub const IPV6_2292RTHDR: ::std::os::raw::c_uint = 5;
pub const IPV6_2292PKTOPTIONS: ::std::os::raw::c_uint = 6;
pub const IPV6_CHECKSUM: ::std::os::raw::c_uint = 7;
pub const IPV6_2292HOPLIMIT: ::std::os::raw::c_uint = 8;
pub const IPV6_NEXTHOP: ::std::os::raw::c_uint = 9;
pub const IPV6_AUTHHDR: ::std::os::raw::c_uint = 10;
pub const IPV6_UNICAST_HOPS: ::std::os::raw::c_uint = 16;
pub const IPV6_MULTICAST_IF: ::std::os::raw::c_uint = 17;
pub const IPV6_MULTICAST_HOPS: ::std::os::raw::c_uint = 18;
pub const IPV6_MULTICAST_LOOP: ::std::os::raw::c_uint = 19;
pub const IPV6_JOIN_GROUP: ::std::os::raw::c_uint = 20;
pub const IPV6_LEAVE_GROUP: ::std::os::raw::c_uint = 21;
pub const IPV6_ROUTER_ALERT: ::std::os::raw::c_uint = 22;
pub const IPV6_MTU_DISCOVER: ::std::os::raw::c_uint = 23;
pub const IPV6_MTU: ::std::os::raw::c_uint = 24;
pub const IPV6_RECVERR: ::std::os::raw::c_uint = 25;
pub const IPV6_V6ONLY: ::std::os::raw::c_uint = 26;
pub const IPV6_JOIN_ANYCAST: ::std::os::raw::c_uint = 27;
pub const IPV6_LEAVE_ANYCAST: ::std::os::raw::c_uint = 28;
pub const IPV6_IPSEC_POLICY: ::std::os::raw::c_uint = 34;
pub const IPV6_XFRM_POLICY: ::std::os::raw::c_uint = 35;
pub const IPV6_RECVPKTINFO: ::std::os::raw::c_uint = 49;
pub const IPV6_PKTINFO: ::std::os::raw::c_uint = 50;
pub const IPV6_RECVHOPLIMIT: ::std::os::raw::c_uint = 51;
pub const IPV6_HOPLIMIT: ::std::os::raw::c_uint = 52;
pub const IPV6_RECVHOPOPTS: ::std::os::raw::c_uint = 53;
pub const IPV6_HOPOPTS: ::std::os::raw::c_uint = 54;
pub const IPV6_RTHDRDSTOPTS: ::std::os::raw::c_uint = 55;
pub const IPV6_RECVRTHDR: ::std::os::raw::c_uint = 56;
pub const IPV6_RTHDR: ::std::os::raw::c_uint = 57;
pub const IPV6_RECVDSTOPTS: ::std::os::raw::c_uint = 58;
pub const IPV6_DSTOPTS: ::std::os::raw::c_uint = 59;
pub const IPV6_RECVPATHMTU: ::std::os::raw::c_uint = 60;
pub const IPV6_PATHMTU: ::std::os::raw::c_uint = 61;
pub const IPV6_DONTFRAG: ::std::os::raw::c_uint = 62;
pub const IPV6_RECVTCLASS: ::std::os::raw::c_uint = 66;
pub const IPV6_TCLASS: ::std::os::raw::c_uint = 67;
pub const IPV6_ADD_MEMBERSHIP: ::std::os::raw::c_uint = 20;
pub const IPV6_DROP_MEMBERSHIP: ::std::os::raw::c_uint = 21;
pub const IPV6_RXHOPOPTS: ::std::os::raw::c_uint = 54;
pub const IPV6_RXDSTOPTS: ::std::os::raw::c_uint = 59;
pub const IPV6_PMTUDISC_DONT: ::std::os::raw::c_uint = 0;
pub const IPV6_PMTUDISC_WANT: ::std::os::raw::c_uint = 1;
pub const IPV6_PMTUDISC_DO: ::std::os::raw::c_uint = 2;
pub const IPV6_PMTUDISC_PROBE: ::std::os::raw::c_uint = 3;
pub const IPV6_PMTUDISC_INTERFACE: ::std::os::raw::c_uint = 4;
pub const IPV6_PMTUDISC_OMIT: ::std::os::raw::c_uint = 5;
pub const SOL_IPV6: ::std::os::raw::c_uint = 41;
pub const SOL_ICMPV6: ::std::os::raw::c_uint = 58;
pub const IPV6_RTHDR_LOOSE: ::std::os::raw::c_uint = 0;
pub const IPV6_RTHDR_STRICT: ::std::os::raw::c_uint = 1;
pub const IPV6_RTHDR_TYPE_0: ::std::os::raw::c_uint = 0;
pub const IN_CLASSA_NET: ::std::os::raw::c_uint = 4278190080;
pub const IN_CLASSA_NSHIFT: ::std::os::raw::c_uint = 24;
pub const IN_CLASSA_HOST: ::std::os::raw::c_uint = 16777215;
pub const IN_CLASSA_MAX: ::std::os::raw::c_uint = 128;
pub const IN_CLASSB_NET: ::std::os::raw::c_uint = 4294901760;
pub const IN_CLASSB_NSHIFT: ::std::os::raw::c_uint = 16;
pub const IN_CLASSB_HOST: ::std::os::raw::c_uint = 65535;
pub const IN_CLASSB_MAX: ::std::os::raw::c_uint = 65536;
pub const IN_CLASSC_NET: ::std::os::raw::c_uint = 4294967040;
pub const IN_CLASSC_NSHIFT: ::std::os::raw::c_uint = 8;
pub const IN_CLASSC_HOST: ::std::os::raw::c_uint = 255;
pub const IN_LOOPBACKNET: ::std::os::raw::c_uint = 127;
pub const INET_ADDRSTRLEN: ::std::os::raw::c_uint = 16;
pub const INET6_ADDRSTRLEN: ::std::os::raw::c_uint = 46;
pub const _ASSERT_H: ::std::os::raw::c_uint = 1;
pub const ASN1C_ENVIRONMENT_VERSION: ::std::os::raw::c_uint = 923;
pub const asn_debug_indent: ::std::os::raw::c_uint = 0;
pub const _ASN_DEFAULT_STACK_MAX: ::std::os::raw::c_uint = 30000;
pub type __u_char = ::std::os::raw::c_uchar;
pub type __u_short = ::std::os::raw::c_ushort;
pub type __u_int = ::std::os::raw::c_uint;
pub type __u_long = ::std::os::raw::c_ulong;
pub type __int8_t = ::std::os::raw::c_schar;
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __int16_t = ::std::os::raw::c_short;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __int32_t = ::std::os::raw::c_int;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __int64_t = ::std::os::raw::c_long;
pub type __uint64_t = ::std::os::raw::c_ulong;
pub type __quad_t = ::std::os::raw::c_long;
pub type __u_quad_t = ::std::os::raw::c_ulong;
pub type __dev_t = ::std::os::raw::c_ulong;
pub type __uid_t = ::std::os::raw::c_uint;
pub type __gid_t = ::std::os::raw::c_uint;
pub type __ino_t = ::std::os::raw::c_ulong;
pub type __ino64_t = ::std::os::raw::c_ulong;
pub type __mode_t = ::std::os::raw::c_uint;
pub type __nlink_t = ::std::os::raw::c_ulong;
pub type __off_t = ::std::os::raw::c_long;
pub type __off64_t = ::std::os::raw::c_long;
pub type __pid_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct __fsid_t {
    pub __val: [::std::os::raw::c_int; 2usize],
}
#[test]
fn bindgen_test_layout___fsid_t() {
    assert_eq!(::std::mem::size_of::<__fsid_t>() , 8usize , concat ! (
               "Size of: " , stringify ! ( __fsid_t ) ));
    assert_eq! (::std::mem::align_of::<__fsid_t>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( __fsid_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __fsid_t ) ) . __val as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( __fsid_t ) , "::" ,
                stringify ! ( __val ) ));
}
impl Clone for __fsid_t {
    fn clone(&self) -> Self { *self }
}
pub type __clock_t = ::std::os::raw::c_long;
pub type __rlim_t = ::std::os::raw::c_ulong;
pub type __rlim64_t = ::std::os::raw::c_ulong;
pub type __id_t = ::std::os::raw::c_uint;
pub type __time_t = ::std::os::raw::c_long;
pub type __useconds_t = ::std::os::raw::c_uint;
pub type __suseconds_t = ::std::os::raw::c_long;
pub type __daddr_t = ::std::os::raw::c_int;
pub type __key_t = ::std::os::raw::c_int;
pub type __clockid_t = ::std::os::raw::c_int;
pub type __timer_t = *mut ::std::os::raw::c_void;
pub type __blksize_t = ::std::os::raw::c_long;
pub type __blkcnt_t = ::std::os::raw::c_long;
pub type __blkcnt64_t = ::std::os::raw::c_long;
pub type __fsblkcnt_t = ::std::os::raw::c_ulong;
pub type __fsblkcnt64_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt64_t = ::std::os::raw::c_ulong;
pub type __fsword_t = ::std::os::raw::c_long;
pub type __ssize_t = ::std::os::raw::c_long;
pub type __syscall_slong_t = ::std::os::raw::c_long;
pub type __syscall_ulong_t = ::std::os::raw::c_ulong;
pub type __loff_t = __off64_t;
pub type __qaddr_t = *mut __quad_t;
pub type __caddr_t = *mut ::std::os::raw::c_char;
pub type __intptr_t = ::std::os::raw::c_long;
pub type __socklen_t = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _IO_FILE {
    pub _flags: ::std::os::raw::c_int,
    pub _IO_read_ptr: *mut ::std::os::raw::c_char,
    pub _IO_read_end: *mut ::std::os::raw::c_char,
    pub _IO_read_base: *mut ::std::os::raw::c_char,
    pub _IO_write_base: *mut ::std::os::raw::c_char,
    pub _IO_write_ptr: *mut ::std::os::raw::c_char,
    pub _IO_write_end: *mut ::std::os::raw::c_char,
    pub _IO_buf_base: *mut ::std::os::raw::c_char,
    pub _IO_buf_end: *mut ::std::os::raw::c_char,
    pub _IO_save_base: *mut ::std::os::raw::c_char,
    pub _IO_backup_base: *mut ::std::os::raw::c_char,
    pub _IO_save_end: *mut ::std::os::raw::c_char,
    pub _markers: *mut _IO_marker,
    pub _chain: *mut _IO_FILE,
    pub _fileno: ::std::os::raw::c_int,
    pub _flags2: ::std::os::raw::c_int,
    pub _old_offset: __off_t,
    pub _cur_column: ::std::os::raw::c_ushort,
    pub _vtable_offset: ::std::os::raw::c_schar,
    pub _shortbuf: [::std::os::raw::c_char; 1usize],
    pub _lock: *mut _IO_lock_t,
    pub _offset: __off64_t,
    pub __pad1: *mut ::std::os::raw::c_void,
    pub __pad2: *mut ::std::os::raw::c_void,
    pub __pad3: *mut ::std::os::raw::c_void,
    pub __pad4: *mut ::std::os::raw::c_void,
    pub __pad5: usize,
    pub _mode: ::std::os::raw::c_int,
    pub _unused2: [::std::os::raw::c_char; 20usize],
}
#[test]
fn bindgen_test_layout__IO_FILE() {
    assert_eq!(::std::mem::size_of::<_IO_FILE>() , 216usize , concat ! (
               "Size of: " , stringify ! ( _IO_FILE ) ));
    assert_eq! (::std::mem::align_of::<_IO_FILE>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( _IO_FILE ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IO_FILE ) ) . _flags as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _IO_FILE ) , "::" ,
                stringify ! ( _flags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IO_FILE ) ) . _IO_read_ptr as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( _IO_FILE ) , "::" ,
                stringify ! ( _IO_read_ptr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IO_FILE ) ) . _IO_read_end as * const _
                as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( _IO_FILE ) , "::" ,
                stringify ! ( _IO_read_end ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IO_FILE ) ) . _IO_read_base as * const _
                as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( _IO_FILE ) , "::" ,
                stringify ! ( _IO_read_base ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IO_FILE ) ) . _IO_write_base as * const
                _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( _IO_FILE ) , "::" ,
                stringify ! ( _IO_write_base ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IO_FILE ) ) . _IO_write_ptr as * const _
                as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( _IO_FILE ) , "::" ,
                stringify ! ( _IO_write_ptr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IO_FILE ) ) . _IO_write_end as * const _
                as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( _IO_FILE ) , "::" ,
                stringify ! ( _IO_write_end ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IO_FILE ) ) . _IO_buf_base as * const _
                as usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( _IO_FILE ) , "::" ,
                stringify ! ( _IO_buf_base ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IO_FILE ) ) . _IO_buf_end as * const _
                as usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( _IO_FILE ) , "::" ,
                stringify ! ( _IO_buf_end ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IO_FILE ) ) . _IO_save_base as * const _
                as usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( _IO_FILE ) , "::" ,
                stringify ! ( _IO_save_base ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IO_FILE ) ) . _IO_backup_base as * const
                _ as usize } , 80usize , concat ! (
                "Alignment of field: " , stringify ! ( _IO_FILE ) , "::" ,
                stringify ! ( _IO_backup_base ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IO_FILE ) ) . _IO_save_end as * const _
                as usize } , 88usize , concat ! (
                "Alignment of field: " , stringify ! ( _IO_FILE ) , "::" ,
                stringify ! ( _IO_save_end ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IO_FILE ) ) . _markers as * const _ as
                usize } , 96usize , concat ! (
                "Alignment of field: " , stringify ! ( _IO_FILE ) , "::" ,
                stringify ! ( _markers ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IO_FILE ) ) . _chain as * const _ as
                usize } , 104usize , concat ! (
                "Alignment of field: " , stringify ! ( _IO_FILE ) , "::" ,
                stringify ! ( _chain ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IO_FILE ) ) . _fileno as * const _ as
                usize } , 112usize , concat ! (
                "Alignment of field: " , stringify ! ( _IO_FILE ) , "::" ,
                stringify ! ( _fileno ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IO_FILE ) ) . _flags2 as * const _ as
                usize } , 116usize , concat ! (
                "Alignment of field: " , stringify ! ( _IO_FILE ) , "::" ,
                stringify ! ( _flags2 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IO_FILE ) ) . _old_offset as * const _
                as usize } , 120usize , concat ! (
                "Alignment of field: " , stringify ! ( _IO_FILE ) , "::" ,
                stringify ! ( _old_offset ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IO_FILE ) ) . _cur_column as * const _
                as usize } , 128usize , concat ! (
                "Alignment of field: " , stringify ! ( _IO_FILE ) , "::" ,
                stringify ! ( _cur_column ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IO_FILE ) ) . _vtable_offset as * const
                _ as usize } , 130usize , concat ! (
                "Alignment of field: " , stringify ! ( _IO_FILE ) , "::" ,
                stringify ! ( _vtable_offset ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IO_FILE ) ) . _shortbuf as * const _ as
                usize } , 131usize , concat ! (
                "Alignment of field: " , stringify ! ( _IO_FILE ) , "::" ,
                stringify ! ( _shortbuf ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IO_FILE ) ) . _lock as * const _ as
                usize } , 136usize , concat ! (
                "Alignment of field: " , stringify ! ( _IO_FILE ) , "::" ,
                stringify ! ( _lock ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IO_FILE ) ) . _offset as * const _ as
                usize } , 144usize , concat ! (
                "Alignment of field: " , stringify ! ( _IO_FILE ) , "::" ,
                stringify ! ( _offset ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IO_FILE ) ) . __pad1 as * const _ as
                usize } , 152usize , concat ! (
                "Alignment of field: " , stringify ! ( _IO_FILE ) , "::" ,
                stringify ! ( __pad1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IO_FILE ) ) . __pad2 as * const _ as
                usize } , 160usize , concat ! (
                "Alignment of field: " , stringify ! ( _IO_FILE ) , "::" ,
                stringify ! ( __pad2 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IO_FILE ) ) . __pad3 as * const _ as
                usize } , 168usize , concat ! (
                "Alignment of field: " , stringify ! ( _IO_FILE ) , "::" ,
                stringify ! ( __pad3 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IO_FILE ) ) . __pad4 as * const _ as
                usize } , 176usize , concat ! (
                "Alignment of field: " , stringify ! ( _IO_FILE ) , "::" ,
                stringify ! ( __pad4 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IO_FILE ) ) . __pad5 as * const _ as
                usize } , 184usize , concat ! (
                "Alignment of field: " , stringify ! ( _IO_FILE ) , "::" ,
                stringify ! ( __pad5 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IO_FILE ) ) . _mode as * const _ as
                usize } , 192usize , concat ! (
                "Alignment of field: " , stringify ! ( _IO_FILE ) , "::" ,
                stringify ! ( _mode ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IO_FILE ) ) . _unused2 as * const _ as
                usize } , 196usize , concat ! (
                "Alignment of field: " , stringify ! ( _IO_FILE ) , "::" ,
                stringify ! ( _unused2 ) ));
}
impl Clone for _IO_FILE {
    fn clone(&self) -> Self { *self }
}
pub type FILE = _IO_FILE;
pub type __FILE = _IO_FILE;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct __mbstate_t {
    pub __count: ::std::os::raw::c_int,
    pub __value: __mbstate_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct __mbstate_t__bindgen_ty_1 {
    pub __wch: __BindgenUnionField<::std::os::raw::c_uint>,
    pub __wchb: __BindgenUnionField<[::std::os::raw::c_char; 4usize]>,
    pub bindgen_union_field: u32,
}
#[test]
fn bindgen_test_layout___mbstate_t__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<__mbstate_t__bindgen_ty_1>() , 4usize ,
               concat ! (
               "Size of: " , stringify ! ( __mbstate_t__bindgen_ty_1 ) ));
    assert_eq! (::std::mem::align_of::<__mbstate_t__bindgen_ty_1>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( __mbstate_t__bindgen_ty_1 )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __mbstate_t__bindgen_ty_1 ) ) . __wch as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                __mbstate_t__bindgen_ty_1 ) , "::" , stringify ! ( __wch ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __mbstate_t__bindgen_ty_1 ) ) . __wchb as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                __mbstate_t__bindgen_ty_1 ) , "::" , stringify ! ( __wchb )
                ));
}
impl Clone for __mbstate_t__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout___mbstate_t() {
    assert_eq!(::std::mem::size_of::<__mbstate_t>() , 8usize , concat ! (
               "Size of: " , stringify ! ( __mbstate_t ) ));
    assert_eq! (::std::mem::align_of::<__mbstate_t>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( __mbstate_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __mbstate_t ) ) . __count as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( __mbstate_t ) , "::" ,
                stringify ! ( __count ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __mbstate_t ) ) . __value as * const _ as
                usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( __mbstate_t ) , "::" ,
                stringify ! ( __value ) ));
}
impl Clone for __mbstate_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _G_fpos_t {
    pub __pos: __off_t,
    pub __state: __mbstate_t,
}
#[test]
fn bindgen_test_layout__G_fpos_t() {
    assert_eq!(::std::mem::size_of::<_G_fpos_t>() , 16usize , concat ! (
               "Size of: " , stringify ! ( _G_fpos_t ) ));
    assert_eq! (::std::mem::align_of::<_G_fpos_t>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( _G_fpos_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _G_fpos_t ) ) . __pos as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _G_fpos_t ) , "::" ,
                stringify ! ( __pos ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _G_fpos_t ) ) . __state as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( _G_fpos_t ) , "::" ,
                stringify ! ( __state ) ));
}
impl Clone for _G_fpos_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _G_fpos64_t {
    pub __pos: __off64_t,
    pub __state: __mbstate_t,
}
#[test]
fn bindgen_test_layout__G_fpos64_t() {
    assert_eq!(::std::mem::size_of::<_G_fpos64_t>() , 16usize , concat ! (
               "Size of: " , stringify ! ( _G_fpos64_t ) ));
    assert_eq! (::std::mem::align_of::<_G_fpos64_t>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( _G_fpos64_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _G_fpos64_t ) ) . __pos as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _G_fpos64_t ) , "::" ,
                stringify ! ( __pos ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _G_fpos64_t ) ) . __state as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( _G_fpos64_t ) , "::" ,
                stringify ! ( __state ) ));
}
impl Clone for _G_fpos64_t {
    fn clone(&self) -> Self { *self }
}
pub type va_list = __builtin_va_list;
pub type __gnuc_va_list = __builtin_va_list;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_jump_t {
    _unused: [u8; 0],
}
pub type _IO_lock_t = ::std::os::raw::c_void;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _IO_marker {
    pub _next: *mut _IO_marker,
    pub _sbuf: *mut _IO_FILE,
    pub _pos: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout__IO_marker() {
    assert_eq!(::std::mem::size_of::<_IO_marker>() , 24usize , concat ! (
               "Size of: " , stringify ! ( _IO_marker ) ));
    assert_eq! (::std::mem::align_of::<_IO_marker>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( _IO_marker ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IO_marker ) ) . _next as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _IO_marker ) , "::" ,
                stringify ! ( _next ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IO_marker ) ) . _sbuf as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( _IO_marker ) , "::" ,
                stringify ! ( _sbuf ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IO_marker ) ) . _pos as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( _IO_marker ) , "::" ,
                stringify ! ( _pos ) ));
}
impl Clone for _IO_marker {
    fn clone(&self) -> Self { *self }
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum __codecvt_result {
    __codecvt_ok = 0,
    __codecvt_partial = 1,
    __codecvt_error = 2,
    __codecvt_noconv = 3,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_FILE_plus {
    _unused: [u8; 0],
}
extern "C" {
    #[link_name = "_IO_2_1_stdin_"]
    pub static mut _IO_2_1_stdin_: _IO_FILE_plus;
}
extern "C" {
    #[link_name = "_IO_2_1_stdout_"]
    pub static mut _IO_2_1_stdout_: _IO_FILE_plus;
}
extern "C" {
    #[link_name = "_IO_2_1_stderr_"]
    pub static mut _IO_2_1_stderr_: _IO_FILE_plus;
}
pub type __io_read_fn =
    ::std::option::Option<unsafe extern "C" fn(__cookie:
                                                   *mut ::std::os::raw::c_void,
                                               __buf:
                                                   *mut ::std::os::raw::c_char,
                                               __nbytes: usize) -> __ssize_t>;
pub type __io_write_fn =
    ::std::option::Option<unsafe extern "C" fn(__cookie:
                                                   *mut ::std::os::raw::c_void,
                                               __buf:
                                                   *const ::std::os::raw::c_char,
                                               __n: usize) -> __ssize_t>;
pub type __io_seek_fn =
    ::std::option::Option<unsafe extern "C" fn(__cookie:
                                                   *mut ::std::os::raw::c_void,
                                               __pos: *mut __off64_t,
                                               __w: ::std::os::raw::c_int)
                              -> ::std::os::raw::c_int>;
pub type __io_close_fn =
    ::std::option::Option<unsafe extern "C" fn(__cookie:
                                                   *mut ::std::os::raw::c_void)
                              -> ::std::os::raw::c_int>;
extern "C" {
    pub fn __underflow(arg1: *mut _IO_FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __uflow(arg1: *mut _IO_FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __overflow(arg1: *mut _IO_FILE, arg2: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _IO_getc(__fp: *mut _IO_FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _IO_putc(__c: ::std::os::raw::c_int, __fp: *mut _IO_FILE)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _IO_feof(__fp: *mut _IO_FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _IO_ferror(__fp: *mut _IO_FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _IO_peekc_locked(__fp: *mut _IO_FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _IO_flockfile(arg1: *mut _IO_FILE);
}
extern "C" {
    pub fn _IO_funlockfile(arg1: *mut _IO_FILE);
}
extern "C" {
    pub fn _IO_ftrylockfile(arg1: *mut _IO_FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _IO_vfscanf(arg1: *mut _IO_FILE,
                       arg2: *const ::std::os::raw::c_char,
                       arg3: *mut __va_list_tag,
                       arg4: *mut ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _IO_vfprintf(arg1: *mut _IO_FILE,
                        arg2: *const ::std::os::raw::c_char,
                        arg3: *mut __va_list_tag) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _IO_padn(arg1: *mut _IO_FILE, arg2: ::std::os::raw::c_int,
                    arg3: __ssize_t) -> __ssize_t;
}
extern "C" {
    pub fn _IO_sgetn(arg1: *mut _IO_FILE, arg2: *mut ::std::os::raw::c_void,
                     arg3: usize) -> usize;
}
extern "C" {
    pub fn _IO_seekoff(arg1: *mut _IO_FILE, arg2: __off64_t,
                       arg3: ::std::os::raw::c_int,
                       arg4: ::std::os::raw::c_int) -> __off64_t;
}
extern "C" {
    pub fn _IO_seekpos(arg1: *mut _IO_FILE, arg2: __off64_t,
                       arg3: ::std::os::raw::c_int) -> __off64_t;
}
extern "C" {
    pub fn _IO_free_backup_area(arg1: *mut _IO_FILE);
}
pub type off_t = __off_t;
pub type fpos_t = _G_fpos_t;
extern "C" {
    #[link_name = "stdin"]
    pub static mut stdin: *mut _IO_FILE;
}
extern "C" {
    #[link_name = "stdout"]
    pub static mut stdout: *mut _IO_FILE;
}
extern "C" {
    #[link_name = "stderr"]
    pub static mut stderr: *mut _IO_FILE;
}
extern "C" {
    pub fn remove(__filename: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rename(__old: *const ::std::os::raw::c_char,
                  __new: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn renameat(__oldfd: ::std::os::raw::c_int,
                    __old: *const ::std::os::raw::c_char,
                    __newfd: ::std::os::raw::c_int,
                    __new: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn tmpfile() -> *mut FILE;
}
extern "C" {
    pub fn tmpnam(__s: *mut ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn tmpnam_r(__s: *mut ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn tempnam(__dir: *const ::std::os::raw::c_char,
                   __pfx: *const ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn fclose(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fflush(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fflush_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fopen(__filename: *const ::std::os::raw::c_char,
                 __modes: *const ::std::os::raw::c_char) -> *mut FILE;
}
extern "C" {
    pub fn freopen(__filename: *const ::std::os::raw::c_char,
                   __modes: *const ::std::os::raw::c_char,
                   __stream: *mut FILE) -> *mut FILE;
}
extern "C" {
    pub fn fdopen(__fd: ::std::os::raw::c_int,
                  __modes: *const ::std::os::raw::c_char) -> *mut FILE;
}
extern "C" {
    pub fn fmemopen(__s: *mut ::std::os::raw::c_void, __len: usize,
                    __modes: *const ::std::os::raw::c_char) -> *mut FILE;
}
extern "C" {
    pub fn open_memstream(__bufloc: *mut *mut ::std::os::raw::c_char,
                          __sizeloc: *mut usize) -> *mut FILE;
}
extern "C" {
    pub fn setbuf(__stream: *mut FILE, __buf: *mut ::std::os::raw::c_char);
}
extern "C" {
    pub fn setvbuf(__stream: *mut FILE, __buf: *mut ::std::os::raw::c_char,
                   __modes: ::std::os::raw::c_int, __n: usize)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setbuffer(__stream: *mut FILE, __buf: *mut ::std::os::raw::c_char,
                     __size: usize);
}
extern "C" {
    pub fn setlinebuf(__stream: *mut FILE);
}
extern "C" {
    pub fn fprintf(__stream: *mut FILE,
                   __format: *const ::std::os::raw::c_char, ...)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn printf(__format: *const ::std::os::raw::c_char, ...)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sprintf(__s: *mut ::std::os::raw::c_char,
                   __format: *const ::std::os::raw::c_char, ...)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vfprintf(__s: *mut FILE, __format: *const ::std::os::raw::c_char,
                    __arg: *mut __va_list_tag) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vprintf(__format: *const ::std::os::raw::c_char,
                   __arg: *mut __va_list_tag) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vsprintf(__s: *mut ::std::os::raw::c_char,
                    __format: *const ::std::os::raw::c_char,
                    __arg: *mut __va_list_tag) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn snprintf(__s: *mut ::std::os::raw::c_char, __maxlen: usize,
                    __format: *const ::std::os::raw::c_char, ...)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vsnprintf(__s: *mut ::std::os::raw::c_char, __maxlen: usize,
                     __format: *const ::std::os::raw::c_char,
                     __arg: *mut __va_list_tag) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vdprintf(__fd: ::std::os::raw::c_int,
                    __fmt: *const ::std::os::raw::c_char,
                    __arg: *mut __va_list_tag) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn dprintf(__fd: ::std::os::raw::c_int,
                   __fmt: *const ::std::os::raw::c_char, ...)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fscanf(__stream: *mut FILE,
                  __format: *const ::std::os::raw::c_char, ...)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn scanf(__format: *const ::std::os::raw::c_char, ...)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sscanf(__s: *const ::std::os::raw::c_char,
                  __format: *const ::std::os::raw::c_char, ...)
     -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "__isoc99_fscanf"]
    pub fn fscanf1(__stream: *mut FILE,
                   __format: *const ::std::os::raw::c_char, ...)
     -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "__isoc99_scanf"]
    pub fn scanf1(__format: *const ::std::os::raw::c_char, ...)
     -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "__isoc99_sscanf"]
    pub fn sscanf1(__s: *const ::std::os::raw::c_char,
                   __format: *const ::std::os::raw::c_char, ...)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vfscanf(__s: *mut FILE, __format: *const ::std::os::raw::c_char,
                   __arg: *mut __va_list_tag) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vscanf(__format: *const ::std::os::raw::c_char,
                  __arg: *mut __va_list_tag) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vsscanf(__s: *const ::std::os::raw::c_char,
                   __format: *const ::std::os::raw::c_char,
                   __arg: *mut __va_list_tag) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "__isoc99_vfscanf"]
    pub fn vfscanf1(__s: *mut FILE, __format: *const ::std::os::raw::c_char,
                    __arg: *mut __va_list_tag) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "__isoc99_vscanf"]
    pub fn vscanf1(__format: *const ::std::os::raw::c_char,
                   __arg: *mut __va_list_tag) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "__isoc99_vsscanf"]
    pub fn vsscanf1(__s: *const ::std::os::raw::c_char,
                    __format: *const ::std::os::raw::c_char,
                    __arg: *mut __va_list_tag) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgetc(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getc(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getchar() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getc_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getchar_unlocked() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgetc_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fputc(__c: ::std::os::raw::c_int, __stream: *mut FILE)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putc(__c: ::std::os::raw::c_int, __stream: *mut FILE)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putchar(__c: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fputc_unlocked(__c: ::std::os::raw::c_int, __stream: *mut FILE)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putc_unlocked(__c: ::std::os::raw::c_int, __stream: *mut FILE)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putchar_unlocked(__c: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getw(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putw(__w: ::std::os::raw::c_int, __stream: *mut FILE)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgets(__s: *mut ::std::os::raw::c_char, __n: ::std::os::raw::c_int,
                 __stream: *mut FILE) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn __getdelim(__lineptr: *mut *mut ::std::os::raw::c_char,
                      __n: *mut usize, __delimiter: ::std::os::raw::c_int,
                      __stream: *mut FILE) -> __ssize_t;
}
extern "C" {
    pub fn getdelim(__lineptr: *mut *mut ::std::os::raw::c_char,
                    __n: *mut usize, __delimiter: ::std::os::raw::c_int,
                    __stream: *mut FILE) -> __ssize_t;
}
extern "C" {
    pub fn getline(__lineptr: *mut *mut ::std::os::raw::c_char,
                   __n: *mut usize, __stream: *mut FILE) -> __ssize_t;
}
extern "C" {
    pub fn fputs(__s: *const ::std::os::raw::c_char, __stream: *mut FILE)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn puts(__s: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ungetc(__c: ::std::os::raw::c_int, __stream: *mut FILE)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fread(__ptr: *mut ::std::os::raw::c_void, __size: usize,
                 __n: usize, __stream: *mut FILE) -> usize;
}
extern "C" {
    pub fn fwrite(__ptr: *const ::std::os::raw::c_void, __size: usize,
                  __n: usize, __s: *mut FILE) -> usize;
}
extern "C" {
    pub fn fread_unlocked(__ptr: *mut ::std::os::raw::c_void, __size: usize,
                          __n: usize, __stream: *mut FILE) -> usize;
}
extern "C" {
    pub fn fwrite_unlocked(__ptr: *const ::std::os::raw::c_void,
                           __size: usize, __n: usize, __stream: *mut FILE)
     -> usize;
}
extern "C" {
    pub fn fseek(__stream: *mut FILE, __off: ::std::os::raw::c_long,
                 __whence: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ftell(__stream: *mut FILE) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn rewind(__stream: *mut FILE);
}
extern "C" {
    pub fn fseeko(__stream: *mut FILE, __off: __off_t,
                  __whence: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ftello(__stream: *mut FILE) -> __off_t;
}
extern "C" {
    pub fn fgetpos(__stream: *mut FILE, __pos: *mut fpos_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fsetpos(__stream: *mut FILE, __pos: *const fpos_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clearerr(__stream: *mut FILE);
}
extern "C" {
    pub fn feof(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ferror(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clearerr_unlocked(__stream: *mut FILE);
}
extern "C" {
    pub fn feof_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ferror_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn perror(__s: *const ::std::os::raw::c_char);
}
extern "C" {
    #[link_name = "sys_nerr"]
    pub static mut sys_nerr: ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "sys_errlist"]
    pub static mut sys_errlist: [*const ::std::os::raw::c_char; 0usize];
}
extern "C" {
    pub fn fileno(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fileno_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn popen(__command: *const ::std::os::raw::c_char,
                 __modes: *const ::std::os::raw::c_char) -> *mut FILE;
}
extern "C" {
    pub fn pclose(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ctermid(__s: *mut ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn flockfile(__stream: *mut FILE);
}
extern "C" {
    pub fn ftrylockfile(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn funlockfile(__stream: *mut FILE);
}
pub type wchar_t = ::std::os::raw::c_int;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum idtype_t { P_ALL = 0, P_PID = 1, P_PGID = 2, }
#[repr(C)]
#[derive(Debug, Copy)]
pub struct wait {
    pub w_status: __BindgenUnionField<::std::os::raw::c_int>,
    pub __wait_terminated: __BindgenUnionField<wait__bindgen_ty_1>,
    pub __wait_stopped: __BindgenUnionField<wait__bindgen_ty_2>,
    pub bindgen_union_field: u32,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct wait__bindgen_ty_1 {
    pub _bitfield_1: [u16; 2usize],
    pub __bindgen_align: [u32; 0usize],
}
#[test]
fn bindgen_test_layout_wait__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<wait__bindgen_ty_1>() , 4usize , concat !
               ( "Size of: " , stringify ! ( wait__bindgen_ty_1 ) ));
    assert_eq! (::std::mem::align_of::<wait__bindgen_ty_1>() , 4usize , concat
                ! ( "Alignment of " , stringify ! ( wait__bindgen_ty_1 ) ));
}
impl Clone for wait__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl wait__bindgen_ty_1 {
    #[inline]
    pub fn __w_termsig(&self) -> ::std::os::raw::c_uint {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        let mask = 127u64 as u32;
        let val = (unit_field_val & mask) >> 0usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set___w_termsig(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 127u64 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 0usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>());
        }
    }
    #[inline]
    pub fn __w_coredump(&self) -> ::std::os::raw::c_uint {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        let mask = 128u64 as u32;
        let val = (unit_field_val & mask) >> 7usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set___w_coredump(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 128u64 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 7usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>());
        }
    }
    #[inline]
    pub fn __w_retcode(&self) -> ::std::os::raw::c_uint {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        let mask = 65280u64 as u32;
        let val = (unit_field_val & mask) >> 8usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set___w_retcode(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 65280u64 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 8usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>());
        }
    }
    #[inline]
    pub fn new_bitfield_1(__w_termsig: ::std::os::raw::c_uint,
                          __w_coredump: ::std::os::raw::c_uint,
                          __w_retcode: ::std::os::raw::c_uint) -> u32 {
        ({
             ({
                  ({ 0 } |
                       ((__w_termsig as u32 as u32) << 0usize) &
                           (127u64 as u32))
              } | ((__w_coredump as u32 as u32) << 7usize) & (128u64 as u32))
         } | ((__w_retcode as u32 as u32) << 8usize) & (65280u64 as u32))
    }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct wait__bindgen_ty_2 {
    pub _bitfield_1: [u16; 2usize],
    pub __bindgen_align: [u32; 0usize],
}
#[test]
fn bindgen_test_layout_wait__bindgen_ty_2() {
    assert_eq!(::std::mem::size_of::<wait__bindgen_ty_2>() , 4usize , concat !
               ( "Size of: " , stringify ! ( wait__bindgen_ty_2 ) ));
    assert_eq! (::std::mem::align_of::<wait__bindgen_ty_2>() , 4usize , concat
                ! ( "Alignment of " , stringify ! ( wait__bindgen_ty_2 ) ));
}
impl Clone for wait__bindgen_ty_2 {
    fn clone(&self) -> Self { *self }
}
impl wait__bindgen_ty_2 {
    #[inline]
    pub fn __w_stopval(&self) -> ::std::os::raw::c_uint {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        let mask = 255u64 as u32;
        let val = (unit_field_val & mask) >> 0usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set___w_stopval(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 255u64 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 0usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>());
        }
    }
    #[inline]
    pub fn __w_stopsig(&self) -> ::std::os::raw::c_uint {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        let mask = 65280u64 as u32;
        let val = (unit_field_val & mask) >> 8usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set___w_stopsig(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 65280u64 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 8usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>());
        }
    }
    #[inline]
    pub fn new_bitfield_1(__w_stopval: ::std::os::raw::c_uint,
                          __w_stopsig: ::std::os::raw::c_uint) -> u32 {
        ({
             ({ 0 } |
                  ((__w_stopval as u32 as u32) << 0usize) & (255u64 as u32))
         } | ((__w_stopsig as u32 as u32) << 8usize) & (65280u64 as u32))
    }
}
#[test]
fn bindgen_test_layout_wait() {
    assert_eq!(::std::mem::size_of::<wait>() , 4usize , concat ! (
               "Size of: " , stringify ! ( wait ) ));
    assert_eq! (::std::mem::align_of::<wait>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( wait ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const wait ) ) . w_status as * const _ as usize
                } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( wait ) , "::" ,
                stringify ! ( w_status ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const wait ) ) . __wait_terminated as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( wait ) , "::" ,
                stringify ! ( __wait_terminated ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const wait ) ) . __wait_stopped as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( wait ) , "::" ,
                stringify ! ( __wait_stopped ) ));
}
impl Clone for wait {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct __WAIT_STATUS {
    pub __uptr: __BindgenUnionField<*mut wait>,
    pub __iptr: __BindgenUnionField<*mut ::std::os::raw::c_int>,
    pub bindgen_union_field: u64,
}
#[test]
fn bindgen_test_layout___WAIT_STATUS() {
    assert_eq!(::std::mem::size_of::<__WAIT_STATUS>() , 8usize , concat ! (
               "Size of: " , stringify ! ( __WAIT_STATUS ) ));
    assert_eq! (::std::mem::align_of::<__WAIT_STATUS>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( __WAIT_STATUS ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __WAIT_STATUS ) ) . __uptr as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( __WAIT_STATUS ) , "::"
                , stringify ! ( __uptr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __WAIT_STATUS ) ) . __iptr as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( __WAIT_STATUS ) , "::"
                , stringify ! ( __iptr ) ));
}
impl Clone for __WAIT_STATUS {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct div_t {
    pub quot: ::std::os::raw::c_int,
    pub rem: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_div_t() {
    assert_eq!(::std::mem::size_of::<div_t>() , 8usize , concat ! (
               "Size of: " , stringify ! ( div_t ) ));
    assert_eq! (::std::mem::align_of::<div_t>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( div_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const div_t ) ) . quot as * const _ as usize }
                , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( div_t ) , "::" ,
                stringify ! ( quot ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const div_t ) ) . rem as * const _ as usize } ,
                4usize , concat ! (
                "Alignment of field: " , stringify ! ( div_t ) , "::" ,
                stringify ! ( rem ) ));
}
impl Clone for div_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct ldiv_t {
    pub quot: ::std::os::raw::c_long,
    pub rem: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_ldiv_t() {
    assert_eq!(::std::mem::size_of::<ldiv_t>() , 16usize , concat ! (
               "Size of: " , stringify ! ( ldiv_t ) ));
    assert_eq! (::std::mem::align_of::<ldiv_t>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( ldiv_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ldiv_t ) ) . quot as * const _ as usize }
                , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ldiv_t ) , "::" ,
                stringify ! ( quot ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ldiv_t ) ) . rem as * const _ as usize }
                , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( ldiv_t ) , "::" ,
                stringify ! ( rem ) ));
}
impl Clone for ldiv_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct lldiv_t {
    pub quot: ::std::os::raw::c_longlong,
    pub rem: ::std::os::raw::c_longlong,
}
#[test]
fn bindgen_test_layout_lldiv_t() {
    assert_eq!(::std::mem::size_of::<lldiv_t>() , 16usize , concat ! (
               "Size of: " , stringify ! ( lldiv_t ) ));
    assert_eq! (::std::mem::align_of::<lldiv_t>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( lldiv_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lldiv_t ) ) . quot as * const _ as usize
                } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( lldiv_t ) , "::" ,
                stringify ! ( quot ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lldiv_t ) ) . rem as * const _ as usize }
                , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( lldiv_t ) , "::" ,
                stringify ! ( rem ) ));
}
impl Clone for lldiv_t {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn __ctype_get_mb_cur_max() -> usize;
}
extern "C" {
    pub fn atof(__nptr: *const ::std::os::raw::c_char) -> f64;
}
extern "C" {
    pub fn atoi(__nptr: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn atol(__nptr: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn atoll(__nptr: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn strtod(__nptr: *const ::std::os::raw::c_char,
                  __endptr: *mut *mut ::std::os::raw::c_char) -> f64;
}
extern "C" {
    pub fn strtof(__nptr: *const ::std::os::raw::c_char,
                  __endptr: *mut *mut ::std::os::raw::c_char) -> f32;
}
extern "C" {
    pub fn strtold(__nptr: *const ::std::os::raw::c_char,
                   __endptr: *mut *mut ::std::os::raw::c_char) -> f64;
}
extern "C" {
    pub fn strtol(__nptr: *const ::std::os::raw::c_char,
                  __endptr: *mut *mut ::std::os::raw::c_char,
                  __base: ::std::os::raw::c_int) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn strtoul(__nptr: *const ::std::os::raw::c_char,
                   __endptr: *mut *mut ::std::os::raw::c_char,
                   __base: ::std::os::raw::c_int) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strtoq(__nptr: *const ::std::os::raw::c_char,
                  __endptr: *mut *mut ::std::os::raw::c_char,
                  __base: ::std::os::raw::c_int)
     -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn strtouq(__nptr: *const ::std::os::raw::c_char,
                   __endptr: *mut *mut ::std::os::raw::c_char,
                   __base: ::std::os::raw::c_int)
     -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn strtoll(__nptr: *const ::std::os::raw::c_char,
                   __endptr: *mut *mut ::std::os::raw::c_char,
                   __base: ::std::os::raw::c_int)
     -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn strtoull(__nptr: *const ::std::os::raw::c_char,
                    __endptr: *mut *mut ::std::os::raw::c_char,
                    __base: ::std::os::raw::c_int)
     -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn l64a(__n: ::std::os::raw::c_long) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn a64l(__s: *const ::std::os::raw::c_char) -> ::std::os::raw::c_long;
}
pub type u_char = __u_char;
pub type u_short = __u_short;
pub type u_int = __u_int;
pub type u_long = __u_long;
pub type quad_t = __quad_t;
pub type u_quad_t = __u_quad_t;
pub type fsid_t = __fsid_t;
pub type loff_t = __loff_t;
pub type ino_t = __ino_t;
pub type dev_t = __dev_t;
pub type gid_t = __gid_t;
pub type mode_t = __mode_t;
pub type nlink_t = __nlink_t;
pub type uid_t = __uid_t;
pub type pid_t = __pid_t;
pub type id_t = __id_t;
pub type daddr_t = __daddr_t;
pub type caddr_t = __caddr_t;
pub type key_t = __key_t;
pub type clock_t = __clock_t;
pub type time_t = __time_t;
pub type clockid_t = __clockid_t;
pub type timer_t = __timer_t;
pub type ulong = ::std::os::raw::c_ulong;
pub type ushort = ::std::os::raw::c_ushort;
pub type uint = ::std::os::raw::c_uint;
pub type u_int8_t = ::std::os::raw::c_uchar;
pub type u_int16_t = ::std::os::raw::c_ushort;
pub type u_int32_t = ::std::os::raw::c_uint;
pub type u_int64_t = ::std::os::raw::c_ulong;
pub type register_t = ::std::os::raw::c_long;
pub type __sig_atomic_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct __sigset_t {
    pub __val: [::std::os::raw::c_ulong; 16usize],
}
#[test]
fn bindgen_test_layout___sigset_t() {
    assert_eq!(::std::mem::size_of::<__sigset_t>() , 128usize , concat ! (
               "Size of: " , stringify ! ( __sigset_t ) ));
    assert_eq! (::std::mem::align_of::<__sigset_t>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( __sigset_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __sigset_t ) ) . __val as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( __sigset_t ) , "::" ,
                stringify ! ( __val ) ));
}
impl Clone for __sigset_t {
    fn clone(&self) -> Self { *self }
}
pub type sigset_t = __sigset_t;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct timespec {
    pub tv_sec: __time_t,
    pub tv_nsec: __syscall_slong_t,
}
#[test]
fn bindgen_test_layout_timespec() {
    assert_eq!(::std::mem::size_of::<timespec>() , 16usize , concat ! (
               "Size of: " , stringify ! ( timespec ) ));
    assert_eq! (::std::mem::align_of::<timespec>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( timespec ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const timespec ) ) . tv_sec as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( timespec ) , "::" ,
                stringify ! ( tv_sec ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const timespec ) ) . tv_nsec as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( timespec ) , "::" ,
                stringify ! ( tv_nsec ) ));
}
impl Clone for timespec {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct timeval {
    pub tv_sec: __time_t,
    pub tv_usec: __suseconds_t,
}
#[test]
fn bindgen_test_layout_timeval() {
    assert_eq!(::std::mem::size_of::<timeval>() , 16usize , concat ! (
               "Size of: " , stringify ! ( timeval ) ));
    assert_eq! (::std::mem::align_of::<timeval>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( timeval ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const timeval ) ) . tv_sec as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( timeval ) , "::" ,
                stringify ! ( tv_sec ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const timeval ) ) . tv_usec as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( timeval ) , "::" ,
                stringify ! ( tv_usec ) ));
}
impl Clone for timeval {
    fn clone(&self) -> Self { *self }
}
pub type suseconds_t = __suseconds_t;
pub type __fd_mask = ::std::os::raw::c_long;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct fd_set {
    pub __fds_bits: [__fd_mask; 16usize],
}
#[test]
fn bindgen_test_layout_fd_set() {
    assert_eq!(::std::mem::size_of::<fd_set>() , 128usize , concat ! (
               "Size of: " , stringify ! ( fd_set ) ));
    assert_eq! (::std::mem::align_of::<fd_set>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( fd_set ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const fd_set ) ) . __fds_bits as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( fd_set ) , "::" ,
                stringify ! ( __fds_bits ) ));
}
impl Clone for fd_set {
    fn clone(&self) -> Self { *self }
}
pub type fd_mask = __fd_mask;
extern "C" {
    pub fn select(__nfds: ::std::os::raw::c_int, __readfds: *mut fd_set,
                  __writefds: *mut fd_set, __exceptfds: *mut fd_set,
                  __timeout: *mut timeval) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pselect(__nfds: ::std::os::raw::c_int, __readfds: *mut fd_set,
                   __writefds: *mut fd_set, __exceptfds: *mut fd_set,
                   __timeout: *const timespec, __sigmask: *const __sigset_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gnu_dev_major(__dev: ::std::os::raw::c_ulonglong)
     -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn gnu_dev_minor(__dev: ::std::os::raw::c_ulonglong)
     -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn gnu_dev_makedev(__major: ::std::os::raw::c_uint,
                           __minor: ::std::os::raw::c_uint)
     -> ::std::os::raw::c_ulonglong;
}
pub type blksize_t = __blksize_t;
pub type blkcnt_t = __blkcnt_t;
pub type fsblkcnt_t = __fsblkcnt_t;
pub type fsfilcnt_t = __fsfilcnt_t;
pub type pthread_t = ::std::os::raw::c_ulong;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct pthread_attr_t {
    pub __size: __BindgenUnionField<[::std::os::raw::c_char; 56usize]>,
    pub __align: __BindgenUnionField<::std::os::raw::c_long>,
    pub bindgen_union_field: [u64; 7usize],
}
#[test]
fn bindgen_test_layout_pthread_attr_t() {
    assert_eq!(::std::mem::size_of::<pthread_attr_t>() , 56usize , concat ! (
               "Size of: " , stringify ! ( pthread_attr_t ) ));
    assert_eq! (::std::mem::align_of::<pthread_attr_t>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( pthread_attr_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_attr_t ) ) . __size as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pthread_attr_t ) , "::"
                , stringify ! ( __size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_attr_t ) ) . __align as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pthread_attr_t ) , "::"
                , stringify ! ( __align ) ));
}
impl Clone for pthread_attr_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct __pthread_internal_list {
    pub __prev: *mut __pthread_internal_list,
    pub __next: *mut __pthread_internal_list,
}
#[test]
fn bindgen_test_layout___pthread_internal_list() {
    assert_eq!(::std::mem::size_of::<__pthread_internal_list>() , 16usize ,
               concat ! (
               "Size of: " , stringify ! ( __pthread_internal_list ) ));
    assert_eq! (::std::mem::align_of::<__pthread_internal_list>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( __pthread_internal_list ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __pthread_internal_list ) ) . __prev as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( __pthread_internal_list
                ) , "::" , stringify ! ( __prev ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __pthread_internal_list ) ) . __next as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( __pthread_internal_list
                ) , "::" , stringify ! ( __next ) ));
}
impl Clone for __pthread_internal_list {
    fn clone(&self) -> Self { *self }
}
pub type __pthread_list_t = __pthread_internal_list;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct pthread_mutex_t {
    pub __data: __BindgenUnionField<pthread_mutex_t___pthread_mutex_s>,
    pub __size: __BindgenUnionField<[::std::os::raw::c_char; 40usize]>,
    pub __align: __BindgenUnionField<::std::os::raw::c_long>,
    pub bindgen_union_field: [u64; 5usize],
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct pthread_mutex_t___pthread_mutex_s {
    pub __lock: ::std::os::raw::c_int,
    pub __count: ::std::os::raw::c_uint,
    pub __owner: ::std::os::raw::c_int,
    pub __nusers: ::std::os::raw::c_uint,
    pub __kind: ::std::os::raw::c_int,
    pub __spins: ::std::os::raw::c_short,
    pub __elision: ::std::os::raw::c_short,
    pub __list: __pthread_list_t,
}
#[test]
fn bindgen_test_layout_pthread_mutex_t___pthread_mutex_s() {
    assert_eq!(::std::mem::size_of::<pthread_mutex_t___pthread_mutex_s>() ,
               40usize , concat ! (
               "Size of: " , stringify ! ( pthread_mutex_t___pthread_mutex_s )
               ));
    assert_eq! (::std::mem::align_of::<pthread_mutex_t___pthread_mutex_s>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! (
                pthread_mutex_t___pthread_mutex_s ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_mutex_t___pthread_mutex_s ) ) .
                __lock as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_mutex_t___pthread_mutex_s ) , "::" , stringify ! (
                __lock ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_mutex_t___pthread_mutex_s ) ) .
                __count as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_mutex_t___pthread_mutex_s ) , "::" , stringify ! (
                __count ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_mutex_t___pthread_mutex_s ) ) .
                __owner as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_mutex_t___pthread_mutex_s ) , "::" , stringify ! (
                __owner ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_mutex_t___pthread_mutex_s ) ) .
                __nusers as * const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_mutex_t___pthread_mutex_s ) , "::" , stringify ! (
                __nusers ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_mutex_t___pthread_mutex_s ) ) .
                __kind as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_mutex_t___pthread_mutex_s ) , "::" , stringify ! (
                __kind ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_mutex_t___pthread_mutex_s ) ) .
                __spins as * const _ as usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_mutex_t___pthread_mutex_s ) , "::" , stringify ! (
                __spins ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_mutex_t___pthread_mutex_s ) ) .
                __elision as * const _ as usize } , 22usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_mutex_t___pthread_mutex_s ) , "::" , stringify ! (
                __elision ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_mutex_t___pthread_mutex_s ) ) .
                __list as * const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_mutex_t___pthread_mutex_s ) , "::" , stringify ! (
                __list ) ));
}
impl Clone for pthread_mutex_t___pthread_mutex_s {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_pthread_mutex_t() {
    assert_eq!(::std::mem::size_of::<pthread_mutex_t>() , 40usize , concat ! (
               "Size of: " , stringify ! ( pthread_mutex_t ) ));
    assert_eq! (::std::mem::align_of::<pthread_mutex_t>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( pthread_mutex_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_mutex_t ) ) . __data as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pthread_mutex_t ) ,
                "::" , stringify ! ( __data ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_mutex_t ) ) . __size as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pthread_mutex_t ) ,
                "::" , stringify ! ( __size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_mutex_t ) ) . __align as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pthread_mutex_t ) ,
                "::" , stringify ! ( __align ) ));
}
impl Clone for pthread_mutex_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct pthread_mutexattr_t {
    pub __size: __BindgenUnionField<[::std::os::raw::c_char; 4usize]>,
    pub __align: __BindgenUnionField<::std::os::raw::c_int>,
    pub bindgen_union_field: u32,
}
#[test]
fn bindgen_test_layout_pthread_mutexattr_t() {
    assert_eq!(::std::mem::size_of::<pthread_mutexattr_t>() , 4usize , concat
               ! ( "Size of: " , stringify ! ( pthread_mutexattr_t ) ));
    assert_eq! (::std::mem::align_of::<pthread_mutexattr_t>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( pthread_mutexattr_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_mutexattr_t ) ) . __size as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pthread_mutexattr_t ) ,
                "::" , stringify ! ( __size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_mutexattr_t ) ) . __align as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pthread_mutexattr_t ) ,
                "::" , stringify ! ( __align ) ));
}
impl Clone for pthread_mutexattr_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct pthread_cond_t {
    pub __data: __BindgenUnionField<pthread_cond_t__bindgen_ty_1>,
    pub __size: __BindgenUnionField<[::std::os::raw::c_char; 48usize]>,
    pub __align: __BindgenUnionField<::std::os::raw::c_longlong>,
    pub bindgen_union_field: [u64; 6usize],
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct pthread_cond_t__bindgen_ty_1 {
    pub __lock: ::std::os::raw::c_int,
    pub __futex: ::std::os::raw::c_uint,
    pub __total_seq: ::std::os::raw::c_ulonglong,
    pub __wakeup_seq: ::std::os::raw::c_ulonglong,
    pub __woken_seq: ::std::os::raw::c_ulonglong,
    pub __mutex: *mut ::std::os::raw::c_void,
    pub __nwaiters: ::std::os::raw::c_uint,
    pub __broadcast_seq: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_pthread_cond_t__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<pthread_cond_t__bindgen_ty_1>() , 48usize
               , concat ! (
               "Size of: " , stringify ! ( pthread_cond_t__bindgen_ty_1 ) ));
    assert_eq! (::std::mem::align_of::<pthread_cond_t__bindgen_ty_1>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! ( pthread_cond_t__bindgen_ty_1 )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_cond_t__bindgen_ty_1 ) ) . __lock
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_cond_t__bindgen_ty_1 ) , "::" , stringify ! ( __lock )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_cond_t__bindgen_ty_1 ) ) .
                __futex as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_cond_t__bindgen_ty_1 ) , "::" , stringify ! ( __futex
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_cond_t__bindgen_ty_1 ) ) .
                __total_seq as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_cond_t__bindgen_ty_1 ) , "::" , stringify ! (
                __total_seq ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_cond_t__bindgen_ty_1 ) ) .
                __wakeup_seq as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_cond_t__bindgen_ty_1 ) , "::" , stringify ! (
                __wakeup_seq ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_cond_t__bindgen_ty_1 ) ) .
                __woken_seq as * const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_cond_t__bindgen_ty_1 ) , "::" , stringify ! (
                __woken_seq ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_cond_t__bindgen_ty_1 ) ) .
                __mutex as * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_cond_t__bindgen_ty_1 ) , "::" , stringify ! ( __mutex
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_cond_t__bindgen_ty_1 ) ) .
                __nwaiters as * const _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_cond_t__bindgen_ty_1 ) , "::" , stringify ! (
                __nwaiters ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_cond_t__bindgen_ty_1 ) ) .
                __broadcast_seq as * const _ as usize } , 44usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_cond_t__bindgen_ty_1 ) , "::" , stringify ! (
                __broadcast_seq ) ));
}
impl Clone for pthread_cond_t__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_pthread_cond_t() {
    assert_eq!(::std::mem::size_of::<pthread_cond_t>() , 48usize , concat ! (
               "Size of: " , stringify ! ( pthread_cond_t ) ));
    assert_eq! (::std::mem::align_of::<pthread_cond_t>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( pthread_cond_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_cond_t ) ) . __data as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pthread_cond_t ) , "::"
                , stringify ! ( __data ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_cond_t ) ) . __size as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pthread_cond_t ) , "::"
                , stringify ! ( __size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_cond_t ) ) . __align as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pthread_cond_t ) , "::"
                , stringify ! ( __align ) ));
}
impl Clone for pthread_cond_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct pthread_condattr_t {
    pub __size: __BindgenUnionField<[::std::os::raw::c_char; 4usize]>,
    pub __align: __BindgenUnionField<::std::os::raw::c_int>,
    pub bindgen_union_field: u32,
}
#[test]
fn bindgen_test_layout_pthread_condattr_t() {
    assert_eq!(::std::mem::size_of::<pthread_condattr_t>() , 4usize , concat !
               ( "Size of: " , stringify ! ( pthread_condattr_t ) ));
    assert_eq! (::std::mem::align_of::<pthread_condattr_t>() , 4usize , concat
                ! ( "Alignment of " , stringify ! ( pthread_condattr_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_condattr_t ) ) . __size as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pthread_condattr_t ) ,
                "::" , stringify ! ( __size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_condattr_t ) ) . __align as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pthread_condattr_t ) ,
                "::" , stringify ! ( __align ) ));
}
impl Clone for pthread_condattr_t {
    fn clone(&self) -> Self { *self }
}
pub type pthread_key_t = ::std::os::raw::c_uint;
pub type pthread_once_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct pthread_rwlock_t {
    pub __data: __BindgenUnionField<pthread_rwlock_t__bindgen_ty_1>,
    pub __size: __BindgenUnionField<[::std::os::raw::c_char; 56usize]>,
    pub __align: __BindgenUnionField<::std::os::raw::c_long>,
    pub bindgen_union_field: [u64; 7usize],
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct pthread_rwlock_t__bindgen_ty_1 {
    pub __lock: ::std::os::raw::c_int,
    pub __nr_readers: ::std::os::raw::c_uint,
    pub __readers_wakeup: ::std::os::raw::c_uint,
    pub __writer_wakeup: ::std::os::raw::c_uint,
    pub __nr_readers_queued: ::std::os::raw::c_uint,
    pub __nr_writers_queued: ::std::os::raw::c_uint,
    pub __writer: ::std::os::raw::c_int,
    pub __shared: ::std::os::raw::c_int,
    pub __rwelision: ::std::os::raw::c_schar,
    pub __pad1: [::std::os::raw::c_uchar; 7usize],
    pub __pad2: ::std::os::raw::c_ulong,
    pub __flags: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_pthread_rwlock_t__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<pthread_rwlock_t__bindgen_ty_1>() ,
               56usize , concat ! (
               "Size of: " , stringify ! ( pthread_rwlock_t__bindgen_ty_1 )
               ));
    assert_eq! (::std::mem::align_of::<pthread_rwlock_t__bindgen_ty_1>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! ( pthread_rwlock_t__bindgen_ty_1
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_rwlock_t__bindgen_ty_1 ) ) .
                __lock as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_rwlock_t__bindgen_ty_1 ) , "::" , stringify ! ( __lock
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_rwlock_t__bindgen_ty_1 ) ) .
                __nr_readers as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_rwlock_t__bindgen_ty_1 ) , "::" , stringify ! (
                __nr_readers ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_rwlock_t__bindgen_ty_1 ) ) .
                __readers_wakeup as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_rwlock_t__bindgen_ty_1 ) , "::" , stringify ! (
                __readers_wakeup ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_rwlock_t__bindgen_ty_1 ) ) .
                __writer_wakeup as * const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_rwlock_t__bindgen_ty_1 ) , "::" , stringify ! (
                __writer_wakeup ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_rwlock_t__bindgen_ty_1 ) ) .
                __nr_readers_queued as * const _ as usize } , 16usize , concat
                ! (
                "Alignment of field: " , stringify ! (
                pthread_rwlock_t__bindgen_ty_1 ) , "::" , stringify ! (
                __nr_readers_queued ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_rwlock_t__bindgen_ty_1 ) ) .
                __nr_writers_queued as * const _ as usize } , 20usize , concat
                ! (
                "Alignment of field: " , stringify ! (
                pthread_rwlock_t__bindgen_ty_1 ) , "::" , stringify ! (
                __nr_writers_queued ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_rwlock_t__bindgen_ty_1 ) ) .
                __writer as * const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_rwlock_t__bindgen_ty_1 ) , "::" , stringify ! (
                __writer ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_rwlock_t__bindgen_ty_1 ) ) .
                __shared as * const _ as usize } , 28usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_rwlock_t__bindgen_ty_1 ) , "::" , stringify ! (
                __shared ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_rwlock_t__bindgen_ty_1 ) ) .
                __rwelision as * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_rwlock_t__bindgen_ty_1 ) , "::" , stringify ! (
                __rwelision ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_rwlock_t__bindgen_ty_1 ) ) .
                __pad1 as * const _ as usize } , 33usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_rwlock_t__bindgen_ty_1 ) , "::" , stringify ! ( __pad1
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_rwlock_t__bindgen_ty_1 ) ) .
                __pad2 as * const _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_rwlock_t__bindgen_ty_1 ) , "::" , stringify ! ( __pad2
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_rwlock_t__bindgen_ty_1 ) ) .
                __flags as * const _ as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_rwlock_t__bindgen_ty_1 ) , "::" , stringify ! (
                __flags ) ));
}
impl Clone for pthread_rwlock_t__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_pthread_rwlock_t() {
    assert_eq!(::std::mem::size_of::<pthread_rwlock_t>() , 56usize , concat !
               ( "Size of: " , stringify ! ( pthread_rwlock_t ) ));
    assert_eq! (::std::mem::align_of::<pthread_rwlock_t>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( pthread_rwlock_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_rwlock_t ) ) . __data as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pthread_rwlock_t ) ,
                "::" , stringify ! ( __data ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_rwlock_t ) ) . __size as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pthread_rwlock_t ) ,
                "::" , stringify ! ( __size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_rwlock_t ) ) . __align as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pthread_rwlock_t ) ,
                "::" , stringify ! ( __align ) ));
}
impl Clone for pthread_rwlock_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct pthread_rwlockattr_t {
    pub __size: __BindgenUnionField<[::std::os::raw::c_char; 8usize]>,
    pub __align: __BindgenUnionField<::std::os::raw::c_long>,
    pub bindgen_union_field: u64,
}
#[test]
fn bindgen_test_layout_pthread_rwlockattr_t() {
    assert_eq!(::std::mem::size_of::<pthread_rwlockattr_t>() , 8usize , concat
               ! ( "Size of: " , stringify ! ( pthread_rwlockattr_t ) ));
    assert_eq! (::std::mem::align_of::<pthread_rwlockattr_t>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( pthread_rwlockattr_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_rwlockattr_t ) ) . __size as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pthread_rwlockattr_t )
                , "::" , stringify ! ( __size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_rwlockattr_t ) ) . __align as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pthread_rwlockattr_t )
                , "::" , stringify ! ( __align ) ));
}
impl Clone for pthread_rwlockattr_t {
    fn clone(&self) -> Self { *self }
}
pub type pthread_spinlock_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct pthread_barrier_t {
    pub __size: __BindgenUnionField<[::std::os::raw::c_char; 32usize]>,
    pub __align: __BindgenUnionField<::std::os::raw::c_long>,
    pub bindgen_union_field: [u64; 4usize],
}
#[test]
fn bindgen_test_layout_pthread_barrier_t() {
    assert_eq!(::std::mem::size_of::<pthread_barrier_t>() , 32usize , concat !
               ( "Size of: " , stringify ! ( pthread_barrier_t ) ));
    assert_eq! (::std::mem::align_of::<pthread_barrier_t>() , 8usize , concat
                ! ( "Alignment of " , stringify ! ( pthread_barrier_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_barrier_t ) ) . __size as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pthread_barrier_t ) ,
                "::" , stringify ! ( __size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_barrier_t ) ) . __align as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pthread_barrier_t ) ,
                "::" , stringify ! ( __align ) ));
}
impl Clone for pthread_barrier_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct pthread_barrierattr_t {
    pub __size: __BindgenUnionField<[::std::os::raw::c_char; 4usize]>,
    pub __align: __BindgenUnionField<::std::os::raw::c_int>,
    pub bindgen_union_field: u32,
}
#[test]
fn bindgen_test_layout_pthread_barrierattr_t() {
    assert_eq!(::std::mem::size_of::<pthread_barrierattr_t>() , 4usize ,
               concat ! ( "Size of: " , stringify ! ( pthread_barrierattr_t )
               ));
    assert_eq! (::std::mem::align_of::<pthread_barrierattr_t>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( pthread_barrierattr_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_barrierattr_t ) ) . __size as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pthread_barrierattr_t )
                , "::" , stringify ! ( __size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_barrierattr_t ) ) . __align as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pthread_barrierattr_t )
                , "::" , stringify ! ( __align ) ));
}
impl Clone for pthread_barrierattr_t {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn random() -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn srandom(__seed: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn initstate(__seed: ::std::os::raw::c_uint,
                     __statebuf: *mut ::std::os::raw::c_char,
                     __statelen: usize) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn setstate(__statebuf: *mut ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct random_data {
    pub fptr: *mut i32,
    pub rptr: *mut i32,
    pub state: *mut i32,
    pub rand_type: ::std::os::raw::c_int,
    pub rand_deg: ::std::os::raw::c_int,
    pub rand_sep: ::std::os::raw::c_int,
    pub end_ptr: *mut i32,
}
#[test]
fn bindgen_test_layout_random_data() {
    assert_eq!(::std::mem::size_of::<random_data>() , 48usize , concat ! (
               "Size of: " , stringify ! ( random_data ) ));
    assert_eq! (::std::mem::align_of::<random_data>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( random_data ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const random_data ) ) . fptr as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( random_data ) , "::" ,
                stringify ! ( fptr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const random_data ) ) . rptr as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( random_data ) , "::" ,
                stringify ! ( rptr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const random_data ) ) . state as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( random_data ) , "::" ,
                stringify ! ( state ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const random_data ) ) . rand_type as * const _
                as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( random_data ) , "::" ,
                stringify ! ( rand_type ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const random_data ) ) . rand_deg as * const _
                as usize } , 28usize , concat ! (
                "Alignment of field: " , stringify ! ( random_data ) , "::" ,
                stringify ! ( rand_deg ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const random_data ) ) . rand_sep as * const _
                as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( random_data ) , "::" ,
                stringify ! ( rand_sep ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const random_data ) ) . end_ptr as * const _ as
                usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( random_data ) , "::" ,
                stringify ! ( end_ptr ) ));
}
impl Clone for random_data {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn random_r(__buf: *mut random_data, __result: *mut i32)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn srandom_r(__seed: ::std::os::raw::c_uint, __buf: *mut random_data)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn initstate_r(__seed: ::std::os::raw::c_uint,
                       __statebuf: *mut ::std::os::raw::c_char,
                       __statelen: usize, __buf: *mut random_data)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setstate_r(__statebuf: *mut ::std::os::raw::c_char,
                      __buf: *mut random_data) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rand() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn srand(__seed: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn rand_r(__seed: *mut ::std::os::raw::c_uint)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn drand48() -> f64;
}
extern "C" {
    pub fn erand48(__xsubi: *mut ::std::os::raw::c_ushort) -> f64;
}
extern "C" {
    pub fn lrand48() -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn nrand48(__xsubi: *mut ::std::os::raw::c_ushort)
     -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn mrand48() -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn jrand48(__xsubi: *mut ::std::os::raw::c_ushort)
     -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn srand48(__seedval: ::std::os::raw::c_long);
}
extern "C" {
    pub fn seed48(__seed16v: *mut ::std::os::raw::c_ushort)
     -> *mut ::std::os::raw::c_ushort;
}
extern "C" {
    pub fn lcong48(__param: *mut ::std::os::raw::c_ushort);
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct drand48_data {
    pub __x: [::std::os::raw::c_ushort; 3usize],
    pub __old_x: [::std::os::raw::c_ushort; 3usize],
    pub __c: ::std::os::raw::c_ushort,
    pub __init: ::std::os::raw::c_ushort,
    pub __a: ::std::os::raw::c_ulonglong,
}
#[test]
fn bindgen_test_layout_drand48_data() {
    assert_eq!(::std::mem::size_of::<drand48_data>() , 24usize , concat ! (
               "Size of: " , stringify ! ( drand48_data ) ));
    assert_eq! (::std::mem::align_of::<drand48_data>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( drand48_data ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const drand48_data ) ) . __x as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( drand48_data ) , "::" ,
                stringify ! ( __x ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const drand48_data ) ) . __old_x as * const _
                as usize } , 6usize , concat ! (
                "Alignment of field: " , stringify ! ( drand48_data ) , "::" ,
                stringify ! ( __old_x ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const drand48_data ) ) . __c as * const _ as
                usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( drand48_data ) , "::" ,
                stringify ! ( __c ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const drand48_data ) ) . __init as * const _ as
                usize } , 14usize , concat ! (
                "Alignment of field: " , stringify ! ( drand48_data ) , "::" ,
                stringify ! ( __init ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const drand48_data ) ) . __a as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( drand48_data ) , "::" ,
                stringify ! ( __a ) ));
}
impl Clone for drand48_data {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn drand48_r(__buffer: *mut drand48_data, __result: *mut f64)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn erand48_r(__xsubi: *mut ::std::os::raw::c_ushort,
                     __buffer: *mut drand48_data, __result: *mut f64)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn lrand48_r(__buffer: *mut drand48_data,
                     __result: *mut ::std::os::raw::c_long)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nrand48_r(__xsubi: *mut ::std::os::raw::c_ushort,
                     __buffer: *mut drand48_data,
                     __result: *mut ::std::os::raw::c_long)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mrand48_r(__buffer: *mut drand48_data,
                     __result: *mut ::std::os::raw::c_long)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn jrand48_r(__xsubi: *mut ::std::os::raw::c_ushort,
                     __buffer: *mut drand48_data,
                     __result: *mut ::std::os::raw::c_long)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn srand48_r(__seedval: ::std::os::raw::c_long,
                     __buffer: *mut drand48_data) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn seed48_r(__seed16v: *mut ::std::os::raw::c_ushort,
                    __buffer: *mut drand48_data) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn lcong48_r(__param: *mut ::std::os::raw::c_ushort,
                     __buffer: *mut drand48_data) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn malloc(__size: usize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn calloc(__nmemb: usize, __size: usize)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn realloc(__ptr: *mut ::std::os::raw::c_void, __size: usize)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn free(__ptr: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn cfree(__ptr: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn alloca(__size: usize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn valloc(__size: usize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn posix_memalign(__memptr: *mut *mut ::std::os::raw::c_void,
                          __alignment: usize, __size: usize)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aligned_alloc(__alignment: usize, __size: usize)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn abort();
}
extern "C" {
    pub fn atexit(__func: ::std::option::Option<unsafe extern "C" fn()>)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn at_quick_exit(__func:
                             ::std::option::Option<unsafe extern "C" fn()>)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn on_exit(__func:
                       ::std::option::Option<unsafe extern "C" fn(__status:
                                                                      ::std::os::raw::c_int,
                                                                  __arg:
                                                                      *mut ::std::os::raw::c_void)>,
                   __arg: *mut ::std::os::raw::c_void)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn exit(__status: ::std::os::raw::c_int);
}
extern "C" {
    pub fn quick_exit(__status: ::std::os::raw::c_int);
}
extern "C" {
    pub fn _Exit(__status: ::std::os::raw::c_int);
}
extern "C" {
    pub fn getenv(__name: *const ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn putenv(__string: *mut ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setenv(__name: *const ::std::os::raw::c_char,
                  __value: *const ::std::os::raw::c_char,
                  __replace: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn unsetenv(__name: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clearenv() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mktemp(__template: *mut ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn mkstemp(__template: *mut ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mkstemps(__template: *mut ::std::os::raw::c_char,
                    __suffixlen: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mkdtemp(__template: *mut ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn system(__command: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn realpath(__name: *const ::std::os::raw::c_char,
                    __resolved: *mut ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
pub type __compar_fn_t =
    ::std::option::Option<unsafe extern "C" fn(arg1:
                                                   *const ::std::os::raw::c_void,
                                               arg2:
                                                   *const ::std::os::raw::c_void)
                              -> ::std::os::raw::c_int>;
extern "C" {
    pub fn bsearch(__key: *const ::std::os::raw::c_void,
                   __base: *const ::std::os::raw::c_void, __nmemb: usize,
                   __size: usize, __compar: __compar_fn_t)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn qsort(__base: *mut ::std::os::raw::c_void, __nmemb: usize,
                 __size: usize, __compar: __compar_fn_t);
}
extern "C" {
    pub fn abs(__x: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn labs(__x: ::std::os::raw::c_long) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn llabs(__x: ::std::os::raw::c_longlong)
     -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn div(__numer: ::std::os::raw::c_int, __denom: ::std::os::raw::c_int)
     -> div_t;
}
extern "C" {
    pub fn ldiv(__numer: ::std::os::raw::c_long,
                __denom: ::std::os::raw::c_long) -> ldiv_t;
}
extern "C" {
    pub fn lldiv(__numer: ::std::os::raw::c_longlong,
                 __denom: ::std::os::raw::c_longlong) -> lldiv_t;
}
extern "C" {
    pub fn ecvt(__value: f64, __ndigit: ::std::os::raw::c_int,
                __decpt: *mut ::std::os::raw::c_int,
                __sign: *mut ::std::os::raw::c_int)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn fcvt(__value: f64, __ndigit: ::std::os::raw::c_int,
                __decpt: *mut ::std::os::raw::c_int,
                __sign: *mut ::std::os::raw::c_int)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn gcvt(__value: f64, __ndigit: ::std::os::raw::c_int,
                __buf: *mut ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn qecvt(__value: f64, __ndigit: ::std::os::raw::c_int,
                 __decpt: *mut ::std::os::raw::c_int,
                 __sign: *mut ::std::os::raw::c_int)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn qfcvt(__value: f64, __ndigit: ::std::os::raw::c_int,
                 __decpt: *mut ::std::os::raw::c_int,
                 __sign: *mut ::std::os::raw::c_int)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn qgcvt(__value: f64, __ndigit: ::std::os::raw::c_int,
                 __buf: *mut ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ecvt_r(__value: f64, __ndigit: ::std::os::raw::c_int,
                  __decpt: *mut ::std::os::raw::c_int,
                  __sign: *mut ::std::os::raw::c_int,
                  __buf: *mut ::std::os::raw::c_char, __len: usize)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fcvt_r(__value: f64, __ndigit: ::std::os::raw::c_int,
                  __decpt: *mut ::std::os::raw::c_int,
                  __sign: *mut ::std::os::raw::c_int,
                  __buf: *mut ::std::os::raw::c_char, __len: usize)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn qecvt_r(__value: f64, __ndigit: ::std::os::raw::c_int,
                   __decpt: *mut ::std::os::raw::c_int,
                   __sign: *mut ::std::os::raw::c_int,
                   __buf: *mut ::std::os::raw::c_char, __len: usize)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn qfcvt_r(__value: f64, __ndigit: ::std::os::raw::c_int,
                   __decpt: *mut ::std::os::raw::c_int,
                   __sign: *mut ::std::os::raw::c_int,
                   __buf: *mut ::std::os::raw::c_char, __len: usize)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mblen(__s: *const ::std::os::raw::c_char, __n: usize)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mbtowc(__pwc: *mut wchar_t, __s: *const ::std::os::raw::c_char,
                  __n: usize) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wctomb(__s: *mut ::std::os::raw::c_char, __wchar: wchar_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mbstowcs(__pwcs: *mut wchar_t, __s: *const ::std::os::raw::c_char,
                    __n: usize) -> usize;
}
extern "C" {
    pub fn wcstombs(__s: *mut ::std::os::raw::c_char, __pwcs: *const wchar_t,
                    __n: usize) -> usize;
}
extern "C" {
    pub fn rpmatch(__response: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getsubopt(__optionp: *mut *mut ::std::os::raw::c_char,
                     __tokens: *const *const ::std::os::raw::c_char,
                     __valuep: *mut *mut ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getloadavg(__loadavg: *mut f64, __nelem: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn memcpy(__dest: *mut ::std::os::raw::c_void,
                  __src: *const ::std::os::raw::c_void, __n: usize)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memmove(__dest: *mut ::std::os::raw::c_void,
                   __src: *const ::std::os::raw::c_void, __n: usize)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memccpy(__dest: *mut ::std::os::raw::c_void,
                   __src: *const ::std::os::raw::c_void,
                   __c: ::std::os::raw::c_int, __n: usize)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memset(__s: *mut ::std::os::raw::c_void,
                  __c: ::std::os::raw::c_int, __n: usize)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memcmp(__s1: *const ::std::os::raw::c_void,
                  __s2: *const ::std::os::raw::c_void, __n: usize)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn memchr(__s: *const ::std::os::raw::c_void,
                  __c: ::std::os::raw::c_int, __n: usize)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn strcpy(__dest: *mut ::std::os::raw::c_char,
                  __src: *const ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strncpy(__dest: *mut ::std::os::raw::c_char,
                   __src: *const ::std::os::raw::c_char, __n: usize)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strcat(__dest: *mut ::std::os::raw::c_char,
                  __src: *const ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strncat(__dest: *mut ::std::os::raw::c_char,
                   __src: *const ::std::os::raw::c_char, __n: usize)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strcmp(__s1: *const ::std::os::raw::c_char,
                  __s2: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strncmp(__s1: *const ::std::os::raw::c_char,
                   __s2: *const ::std::os::raw::c_char, __n: usize)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strcoll(__s1: *const ::std::os::raw::c_char,
                   __s2: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strxfrm(__dest: *mut ::std::os::raw::c_char,
                   __src: *const ::std::os::raw::c_char, __n: usize)
     -> ::std::os::raw::c_ulong;
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct __locale_struct {
    pub __locales: [*mut __locale_data; 13usize],
    pub __ctype_b: *const ::std::os::raw::c_ushort,
    pub __ctype_tolower: *const ::std::os::raw::c_int,
    pub __ctype_toupper: *const ::std::os::raw::c_int,
    pub __names: [*const ::std::os::raw::c_char; 13usize],
}
#[test]
fn bindgen_test_layout___locale_struct() {
    assert_eq!(::std::mem::size_of::<__locale_struct>() , 232usize , concat !
               ( "Size of: " , stringify ! ( __locale_struct ) ));
    assert_eq! (::std::mem::align_of::<__locale_struct>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( __locale_struct ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __locale_struct ) ) . __locales as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( __locale_struct ) ,
                "::" , stringify ! ( __locales ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __locale_struct ) ) . __ctype_b as *
                const _ as usize } , 104usize , concat ! (
                "Alignment of field: " , stringify ! ( __locale_struct ) ,
                "::" , stringify ! ( __ctype_b ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __locale_struct ) ) . __ctype_tolower as
                * const _ as usize } , 112usize , concat ! (
                "Alignment of field: " , stringify ! ( __locale_struct ) ,
                "::" , stringify ! ( __ctype_tolower ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __locale_struct ) ) . __ctype_toupper as
                * const _ as usize } , 120usize , concat ! (
                "Alignment of field: " , stringify ! ( __locale_struct ) ,
                "::" , stringify ! ( __ctype_toupper ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __locale_struct ) ) . __names as * const
                _ as usize } , 128usize , concat ! (
                "Alignment of field: " , stringify ! ( __locale_struct ) ,
                "::" , stringify ! ( __names ) ));
}
impl Clone for __locale_struct {
    fn clone(&self) -> Self { *self }
}
pub type __locale_t = *mut __locale_struct;
pub type locale_t = __locale_t;
extern "C" {
    pub fn strcoll_l(__s1: *const ::std::os::raw::c_char,
                     __s2: *const ::std::os::raw::c_char, __l: __locale_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strxfrm_l(__dest: *mut ::std::os::raw::c_char,
                     __src: *const ::std::os::raw::c_char, __n: usize,
                     __l: __locale_t) -> usize;
}
extern "C" {
    pub fn strdup(__s: *const ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strndup(__string: *const ::std::os::raw::c_char, __n: usize)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strchr(__s: *const ::std::os::raw::c_char,
                  __c: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strrchr(__s: *const ::std::os::raw::c_char,
                   __c: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strcspn(__s: *const ::std::os::raw::c_char,
                   __reject: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strspn(__s: *const ::std::os::raw::c_char,
                  __accept: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strpbrk(__s: *const ::std::os::raw::c_char,
                   __accept: *const ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strstr(__haystack: *const ::std::os::raw::c_char,
                  __needle: *const ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strtok(__s: *mut ::std::os::raw::c_char,
                  __delim: *const ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn __strtok_r(__s: *mut ::std::os::raw::c_char,
                      __delim: *const ::std::os::raw::c_char,
                      __save_ptr: *mut *mut ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strtok_r(__s: *mut ::std::os::raw::c_char,
                    __delim: *const ::std::os::raw::c_char,
                    __save_ptr: *mut *mut ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strlen(__s: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strnlen(__string: *const ::std::os::raw::c_char, __maxlen: usize)
     -> usize;
}
extern "C" {
    pub fn strerror(__errnum: ::std::os::raw::c_int)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "__xpg_strerror_r"]
    pub fn strerror_r(__errnum: ::std::os::raw::c_int,
                      __buf: *mut ::std::os::raw::c_char, __buflen: usize)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strerror_l(__errnum: ::std::os::raw::c_int, __l: __locale_t)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn __bzero(__s: *mut ::std::os::raw::c_void, __n: usize);
}
extern "C" {
    pub fn bcopy(__src: *const ::std::os::raw::c_void,
                 __dest: *mut ::std::os::raw::c_void, __n: usize);
}
extern "C" {
    pub fn bzero(__s: *mut ::std::os::raw::c_void, __n: usize);
}
extern "C" {
    pub fn bcmp(__s1: *const ::std::os::raw::c_void,
                __s2: *const ::std::os::raw::c_void, __n: usize)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn index(__s: *const ::std::os::raw::c_char,
                 __c: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn rindex(__s: *const ::std::os::raw::c_char,
                  __c: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ffs(__i: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strcasecmp(__s1: *const ::std::os::raw::c_char,
                      __s2: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strncasecmp(__s1: *const ::std::os::raw::c_char,
                       __s2: *const ::std::os::raw::c_char, __n: usize)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strsep(__stringp: *mut *mut ::std::os::raw::c_char,
                  __delim: *const ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strsignal(__sig: ::std::os::raw::c_int)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn __stpcpy(__dest: *mut ::std::os::raw::c_char,
                    __src: *const ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn stpcpy(__dest: *mut ::std::os::raw::c_char,
                  __src: *const ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn __stpncpy(__dest: *mut ::std::os::raw::c_char,
                     __src: *const ::std::os::raw::c_char, __n: usize)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn stpncpy(__dest: *mut ::std::os::raw::c_char,
                   __src: *const ::std::os::raw::c_char, __n: usize)
     -> *mut ::std::os::raw::c_char;
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct max_align_t {
    pub __clang_max_align_nonce1: ::std::os::raw::c_longlong,
    pub __bindgen_padding_0: u64,
    pub __clang_max_align_nonce2: f64,
}
#[test]
fn bindgen_test_layout_max_align_t() {
    assert_eq!(::std::mem::size_of::<max_align_t>() , 32usize , concat ! (
               "Size of: " , stringify ! ( max_align_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const max_align_t ) ) .
                __clang_max_align_nonce1 as * const _ as usize } , 0usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( max_align_t ) , "::" ,
                stringify ! ( __clang_max_align_nonce1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const max_align_t ) ) .
                __clang_max_align_nonce2 as * const _ as usize } , 16usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( max_align_t ) , "::" ,
                stringify ! ( __clang_max_align_nonce2 ) ));
}
impl Clone for max_align_t {
    fn clone(&self) -> Self { *self }
}
pub type int_least8_t = ::std::os::raw::c_schar;
pub type int_least16_t = ::std::os::raw::c_short;
pub type int_least32_t = ::std::os::raw::c_int;
pub type int_least64_t = ::std::os::raw::c_long;
pub type uint_least8_t = ::std::os::raw::c_uchar;
pub type uint_least16_t = ::std::os::raw::c_ushort;
pub type uint_least32_t = ::std::os::raw::c_uint;
pub type uint_least64_t = ::std::os::raw::c_ulong;
pub type int_fast8_t = ::std::os::raw::c_schar;
pub type int_fast16_t = ::std::os::raw::c_long;
pub type int_fast32_t = ::std::os::raw::c_long;
pub type int_fast64_t = ::std::os::raw::c_long;
pub type uint_fast8_t = ::std::os::raw::c_uchar;
pub type uint_fast16_t = ::std::os::raw::c_ulong;
pub type uint_fast32_t = ::std::os::raw::c_ulong;
pub type uint_fast64_t = ::std::os::raw::c_ulong;
pub type intmax_t = ::std::os::raw::c_long;
pub type uintmax_t = ::std::os::raw::c_ulong;
pub type __gwchar_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct imaxdiv_t {
    pub quot: ::std::os::raw::c_long,
    pub rem: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_imaxdiv_t() {
    assert_eq!(::std::mem::size_of::<imaxdiv_t>() , 16usize , concat ! (
               "Size of: " , stringify ! ( imaxdiv_t ) ));
    assert_eq! (::std::mem::align_of::<imaxdiv_t>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( imaxdiv_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const imaxdiv_t ) ) . quot as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( imaxdiv_t ) , "::" ,
                stringify ! ( quot ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const imaxdiv_t ) ) . rem as * const _ as usize
                } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( imaxdiv_t ) , "::" ,
                stringify ! ( rem ) ));
}
impl Clone for imaxdiv_t {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn imaxabs(__n: intmax_t) -> intmax_t;
}
extern "C" {
    pub fn imaxdiv(__numer: intmax_t, __denom: intmax_t) -> imaxdiv_t;
}
extern "C" {
    pub fn strtoimax(__nptr: *const ::std::os::raw::c_char,
                     __endptr: *mut *mut ::std::os::raw::c_char,
                     __base: ::std::os::raw::c_int) -> intmax_t;
}
extern "C" {
    pub fn strtoumax(__nptr: *const ::std::os::raw::c_char,
                     __endptr: *mut *mut ::std::os::raw::c_char,
                     __base: ::std::os::raw::c_int) -> uintmax_t;
}
extern "C" {
    pub fn wcstoimax(__nptr: *const __gwchar_t,
                     __endptr: *mut *mut __gwchar_t,
                     __base: ::std::os::raw::c_int) -> intmax_t;
}
extern "C" {
    pub fn wcstoumax(__nptr: *const __gwchar_t,
                     __endptr: *mut *mut __gwchar_t,
                     __base: ::std::os::raw::c_int) -> uintmax_t;
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct iovec {
    pub iov_base: *mut ::std::os::raw::c_void,
    pub iov_len: usize,
}
#[test]
fn bindgen_test_layout_iovec() {
    assert_eq!(::std::mem::size_of::<iovec>() , 16usize , concat ! (
               "Size of: " , stringify ! ( iovec ) ));
    assert_eq! (::std::mem::align_of::<iovec>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( iovec ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const iovec ) ) . iov_base as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( iovec ) , "::" ,
                stringify ! ( iov_base ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const iovec ) ) . iov_len as * const _ as usize
                } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( iovec ) , "::" ,
                stringify ! ( iov_len ) ));
}
impl Clone for iovec {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn readv(__fd: ::std::os::raw::c_int, __iovec: *const iovec,
                 __count: ::std::os::raw::c_int) -> isize;
}
extern "C" {
    pub fn writev(__fd: ::std::os::raw::c_int, __iovec: *const iovec,
                  __count: ::std::os::raw::c_int) -> isize;
}
extern "C" {
    pub fn preadv(__fd: ::std::os::raw::c_int, __iovec: *const iovec,
                  __count: ::std::os::raw::c_int, __offset: __off_t) -> isize;
}
extern "C" {
    pub fn pwritev(__fd: ::std::os::raw::c_int, __iovec: *const iovec,
                   __count: ::std::os::raw::c_int, __offset: __off_t)
     -> isize;
}
pub type socklen_t = __socklen_t;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum __socket_type {
    SOCK_STREAM = 1,
    SOCK_DGRAM = 2,
    SOCK_RAW = 3,
    SOCK_RDM = 4,
    SOCK_SEQPACKET = 5,
    SOCK_DCCP = 6,
    SOCK_PACKET = 10,
    SOCK_CLOEXEC = 524288,
    SOCK_NONBLOCK = 2048,
}
pub type sa_family_t = ::std::os::raw::c_ushort;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct sockaddr {
    pub sa_family: sa_family_t,
    pub sa_data: [::std::os::raw::c_char; 14usize],
}
#[test]
fn bindgen_test_layout_sockaddr() {
    assert_eq!(::std::mem::size_of::<sockaddr>() , 16usize , concat ! (
               "Size of: " , stringify ! ( sockaddr ) ));
    assert_eq! (::std::mem::align_of::<sockaddr>() , 2usize , concat ! (
                "Alignment of " , stringify ! ( sockaddr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sockaddr ) ) . sa_family as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( sockaddr ) , "::" ,
                stringify ! ( sa_family ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sockaddr ) ) . sa_data as * const _ as
                usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! ( sockaddr ) , "::" ,
                stringify ! ( sa_data ) ));
}
impl Clone for sockaddr {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
pub struct sockaddr_storage {
    pub ss_family: sa_family_t,
    pub __ss_padding: [::std::os::raw::c_char; 118usize],
    pub __ss_align: ::std::os::raw::c_ulong,
}
#[test]
fn bindgen_test_layout_sockaddr_storage() {
    assert_eq!(::std::mem::size_of::<sockaddr_storage>() , 128usize , concat !
               ( "Size of: " , stringify ! ( sockaddr_storage ) ));
    assert_eq! (::std::mem::align_of::<sockaddr_storage>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( sockaddr_storage ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sockaddr_storage ) ) . ss_family as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( sockaddr_storage ) ,
                "::" , stringify ! ( ss_family ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sockaddr_storage ) ) . __ss_padding as *
                const _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! ( sockaddr_storage ) ,
                "::" , stringify ! ( __ss_padding ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sockaddr_storage ) ) . __ss_align as *
                const _ as usize } , 120usize , concat ! (
                "Alignment of field: " , stringify ! ( sockaddr_storage ) ,
                "::" , stringify ! ( __ss_align ) ));
}
pub const MSG_OOB: _bindgen_ty_1 = _bindgen_ty_1::MSG_OOB;
pub const MSG_PEEK: _bindgen_ty_1 = _bindgen_ty_1::MSG_PEEK;
pub const MSG_DONTROUTE: _bindgen_ty_1 = _bindgen_ty_1::MSG_DONTROUTE;
pub const MSG_CTRUNC: _bindgen_ty_1 = _bindgen_ty_1::MSG_CTRUNC;
pub const MSG_PROXY: _bindgen_ty_1 = _bindgen_ty_1::MSG_PROXY;
pub const MSG_TRUNC: _bindgen_ty_1 = _bindgen_ty_1::MSG_TRUNC;
pub const MSG_DONTWAIT: _bindgen_ty_1 = _bindgen_ty_1::MSG_DONTWAIT;
pub const MSG_EOR: _bindgen_ty_1 = _bindgen_ty_1::MSG_EOR;
pub const MSG_WAITALL: _bindgen_ty_1 = _bindgen_ty_1::MSG_WAITALL;
pub const MSG_FIN: _bindgen_ty_1 = _bindgen_ty_1::MSG_FIN;
pub const MSG_SYN: _bindgen_ty_1 = _bindgen_ty_1::MSG_SYN;
pub const MSG_CONFIRM: _bindgen_ty_1 = _bindgen_ty_1::MSG_CONFIRM;
pub const MSG_RST: _bindgen_ty_1 = _bindgen_ty_1::MSG_RST;
pub const MSG_ERRQUEUE: _bindgen_ty_1 = _bindgen_ty_1::MSG_ERRQUEUE;
pub const MSG_NOSIGNAL: _bindgen_ty_1 = _bindgen_ty_1::MSG_NOSIGNAL;
pub const MSG_MORE: _bindgen_ty_1 = _bindgen_ty_1::MSG_MORE;
pub const MSG_WAITFORONE: _bindgen_ty_1 = _bindgen_ty_1::MSG_WAITFORONE;
pub const MSG_FASTOPEN: _bindgen_ty_1 = _bindgen_ty_1::MSG_FASTOPEN;
pub const MSG_CMSG_CLOEXEC: _bindgen_ty_1 = _bindgen_ty_1::MSG_CMSG_CLOEXEC;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_1 {
    MSG_OOB = 1,
    MSG_PEEK = 2,
    MSG_DONTROUTE = 4,
    MSG_CTRUNC = 8,
    MSG_PROXY = 16,
    MSG_TRUNC = 32,
    MSG_DONTWAIT = 64,
    MSG_EOR = 128,
    MSG_WAITALL = 256,
    MSG_FIN = 512,
    MSG_SYN = 1024,
    MSG_CONFIRM = 2048,
    MSG_RST = 4096,
    MSG_ERRQUEUE = 8192,
    MSG_NOSIGNAL = 16384,
    MSG_MORE = 32768,
    MSG_WAITFORONE = 65536,
    MSG_FASTOPEN = 536870912,
    MSG_CMSG_CLOEXEC = 1073741824,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct msghdr {
    pub msg_name: *mut ::std::os::raw::c_void,
    pub msg_namelen: socklen_t,
    pub msg_iov: *mut iovec,
    pub msg_iovlen: usize,
    pub msg_control: *mut ::std::os::raw::c_void,
    pub msg_controllen: usize,
    pub msg_flags: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_msghdr() {
    assert_eq!(::std::mem::size_of::<msghdr>() , 56usize , concat ! (
               "Size of: " , stringify ! ( msghdr ) ));
    assert_eq! (::std::mem::align_of::<msghdr>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( msghdr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const msghdr ) ) . msg_name as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( msghdr ) , "::" ,
                stringify ! ( msg_name ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const msghdr ) ) . msg_namelen as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( msghdr ) , "::" ,
                stringify ! ( msg_namelen ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const msghdr ) ) . msg_iov as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( msghdr ) , "::" ,
                stringify ! ( msg_iov ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const msghdr ) ) . msg_iovlen as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( msghdr ) , "::" ,
                stringify ! ( msg_iovlen ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const msghdr ) ) . msg_control as * const _ as
                usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( msghdr ) , "::" ,
                stringify ! ( msg_control ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const msghdr ) ) . msg_controllen as * const _
                as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( msghdr ) , "::" ,
                stringify ! ( msg_controllen ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const msghdr ) ) . msg_flags as * const _ as
                usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( msghdr ) , "::" ,
                stringify ! ( msg_flags ) ));
}
impl Clone for msghdr {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct cmsghdr {
    pub cmsg_len: usize,
    pub cmsg_level: ::std::os::raw::c_int,
    pub cmsg_type: ::std::os::raw::c_int,
    pub __cmsg_data: __IncompleteArrayField<::std::os::raw::c_uchar>,
}
#[test]
fn bindgen_test_layout_cmsghdr() {
    assert_eq!(::std::mem::size_of::<cmsghdr>() , 16usize , concat ! (
               "Size of: " , stringify ! ( cmsghdr ) ));
    assert_eq! (::std::mem::align_of::<cmsghdr>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( cmsghdr ) ));
}
impl Clone for cmsghdr {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn __cmsg_nxthdr(__mhdr: *mut msghdr, __cmsg: *mut cmsghdr)
     -> *mut cmsghdr;
}
pub const SCM_RIGHTS: _bindgen_ty_2 = _bindgen_ty_2::SCM_RIGHTS;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_2 { SCM_RIGHTS = 1, }
#[repr(C)]
#[derive(Debug, Copy)]
pub struct linger {
    pub l_onoff: ::std::os::raw::c_int,
    pub l_linger: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_linger() {
    assert_eq!(::std::mem::size_of::<linger>() , 8usize , concat ! (
               "Size of: " , stringify ! ( linger ) ));
    assert_eq! (::std::mem::align_of::<linger>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( linger ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const linger ) ) . l_onoff as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( linger ) , "::" ,
                stringify ! ( l_onoff ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const linger ) ) . l_linger as * const _ as
                usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( linger ) , "::" ,
                stringify ! ( l_linger ) ));
}
impl Clone for linger {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct osockaddr {
    pub sa_family: ::std::os::raw::c_ushort,
    pub sa_data: [::std::os::raw::c_uchar; 14usize],
}
#[test]
fn bindgen_test_layout_osockaddr() {
    assert_eq!(::std::mem::size_of::<osockaddr>() , 16usize , concat ! (
               "Size of: " , stringify ! ( osockaddr ) ));
    assert_eq! (::std::mem::align_of::<osockaddr>() , 2usize , concat ! (
                "Alignment of " , stringify ! ( osockaddr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const osockaddr ) ) . sa_family as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( osockaddr ) , "::" ,
                stringify ! ( sa_family ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const osockaddr ) ) . sa_data as * const _ as
                usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! ( osockaddr ) , "::" ,
                stringify ! ( sa_data ) ));
}
impl Clone for osockaddr {
    fn clone(&self) -> Self { *self }
}
pub const SHUT_RD: _bindgen_ty_3 = _bindgen_ty_3::SHUT_RD;
pub const SHUT_WR: _bindgen_ty_3 = _bindgen_ty_3::SHUT_WR;
pub const SHUT_RDWR: _bindgen_ty_3 = _bindgen_ty_3::SHUT_RDWR;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_3 { SHUT_RD = 0, SHUT_WR = 1, SHUT_RDWR = 2, }
extern "C" {
    pub fn socket(__domain: ::std::os::raw::c_int,
                  __type: ::std::os::raw::c_int,
                  __protocol: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn socketpair(__domain: ::std::os::raw::c_int,
                      __type: ::std::os::raw::c_int,
                      __protocol: ::std::os::raw::c_int,
                      __fds: *mut ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bind(__fd: ::std::os::raw::c_int, __addr: *const sockaddr,
                __len: socklen_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getsockname(__fd: ::std::os::raw::c_int, __addr: *mut sockaddr,
                       __len: *mut socklen_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn connect(__fd: ::std::os::raw::c_int, __addr: *const sockaddr,
                   __len: socklen_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getpeername(__fd: ::std::os::raw::c_int, __addr: *mut sockaddr,
                       __len: *mut socklen_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn send(__fd: ::std::os::raw::c_int,
                __buf: *const ::std::os::raw::c_void, __n: usize,
                __flags: ::std::os::raw::c_int) -> isize;
}
extern "C" {
    pub fn recv(__fd: ::std::os::raw::c_int,
                __buf: *mut ::std::os::raw::c_void, __n: usize,
                __flags: ::std::os::raw::c_int) -> isize;
}
extern "C" {
    pub fn sendto(__fd: ::std::os::raw::c_int,
                  __buf: *const ::std::os::raw::c_void, __n: usize,
                  __flags: ::std::os::raw::c_int, __addr: *const sockaddr,
                  __addr_len: socklen_t) -> isize;
}
extern "C" {
    pub fn recvfrom(__fd: ::std::os::raw::c_int,
                    __buf: *mut ::std::os::raw::c_void, __n: usize,
                    __flags: ::std::os::raw::c_int, __addr: *mut sockaddr,
                    __addr_len: *mut socklen_t) -> isize;
}
extern "C" {
    pub fn sendmsg(__fd: ::std::os::raw::c_int, __message: *const msghdr,
                   __flags: ::std::os::raw::c_int) -> isize;
}
extern "C" {
    pub fn recvmsg(__fd: ::std::os::raw::c_int, __message: *mut msghdr,
                   __flags: ::std::os::raw::c_int) -> isize;
}
extern "C" {
    pub fn getsockopt(__fd: ::std::os::raw::c_int,
                      __level: ::std::os::raw::c_int,
                      __optname: ::std::os::raw::c_int,
                      __optval: *mut ::std::os::raw::c_void,
                      __optlen: *mut socklen_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setsockopt(__fd: ::std::os::raw::c_int,
                      __level: ::std::os::raw::c_int,
                      __optname: ::std::os::raw::c_int,
                      __optval: *const ::std::os::raw::c_void,
                      __optlen: socklen_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn listen(__fd: ::std::os::raw::c_int, __n: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn accept(__fd: ::std::os::raw::c_int, __addr: *mut sockaddr,
                  __addr_len: *mut socklen_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn shutdown(__fd: ::std::os::raw::c_int, __how: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sockatmark(__fd: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isfdtype(__fd: ::std::os::raw::c_int,
                    __fdtype: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
pub type in_addr_t = u32;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct in_addr {
    pub s_addr: in_addr_t,
}
#[test]
fn bindgen_test_layout_in_addr() {
    assert_eq!(::std::mem::size_of::<in_addr>() , 4usize , concat ! (
               "Size of: " , stringify ! ( in_addr ) ));
    assert_eq! (::std::mem::align_of::<in_addr>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( in_addr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const in_addr ) ) . s_addr as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( in_addr ) , "::" ,
                stringify ! ( s_addr ) ));
}
impl Clone for in_addr {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
pub struct ip_opts {
    pub ip_dst: in_addr,
    pub ip_opts: [::std::os::raw::c_char; 40usize],
}
#[test]
fn bindgen_test_layout_ip_opts() {
    assert_eq!(::std::mem::size_of::<ip_opts>() , 44usize , concat ! (
               "Size of: " , stringify ! ( ip_opts ) ));
    assert_eq! (::std::mem::align_of::<ip_opts>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( ip_opts ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ip_opts ) ) . ip_dst as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ip_opts ) , "::" ,
                stringify ! ( ip_dst ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ip_opts ) ) . ip_opts as * const _ as
                usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( ip_opts ) , "::" ,
                stringify ! ( ip_opts ) ));
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct ip_mreqn {
    pub imr_multiaddr: in_addr,
    pub imr_address: in_addr,
    pub imr_ifindex: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_ip_mreqn() {
    assert_eq!(::std::mem::size_of::<ip_mreqn>() , 12usize , concat ! (
               "Size of: " , stringify ! ( ip_mreqn ) ));
    assert_eq! (::std::mem::align_of::<ip_mreqn>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( ip_mreqn ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ip_mreqn ) ) . imr_multiaddr as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ip_mreqn ) , "::" ,
                stringify ! ( imr_multiaddr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ip_mreqn ) ) . imr_address as * const _
                as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( ip_mreqn ) , "::" ,
                stringify ! ( imr_address ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ip_mreqn ) ) . imr_ifindex as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( ip_mreqn ) , "::" ,
                stringify ! ( imr_ifindex ) ));
}
impl Clone for ip_mreqn {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct in_pktinfo {
    pub ipi_ifindex: ::std::os::raw::c_int,
    pub ipi_spec_dst: in_addr,
    pub ipi_addr: in_addr,
}
#[test]
fn bindgen_test_layout_in_pktinfo() {
    assert_eq!(::std::mem::size_of::<in_pktinfo>() , 12usize , concat ! (
               "Size of: " , stringify ! ( in_pktinfo ) ));
    assert_eq! (::std::mem::align_of::<in_pktinfo>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( in_pktinfo ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const in_pktinfo ) ) . ipi_ifindex as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( in_pktinfo ) , "::" ,
                stringify ! ( ipi_ifindex ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const in_pktinfo ) ) . ipi_spec_dst as * const
                _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( in_pktinfo ) , "::" ,
                stringify ! ( ipi_spec_dst ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const in_pktinfo ) ) . ipi_addr as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( in_pktinfo ) , "::" ,
                stringify ! ( ipi_addr ) ));
}
impl Clone for in_pktinfo {
    fn clone(&self) -> Self { *self }
}
pub const IPPROTO_IP: _bindgen_ty_4 = _bindgen_ty_4::IPPROTO_IP;
pub const IPPROTO_ICMP: _bindgen_ty_4 = _bindgen_ty_4::IPPROTO_ICMP;
pub const IPPROTO_IGMP: _bindgen_ty_4 = _bindgen_ty_4::IPPROTO_IGMP;
pub const IPPROTO_IPIP: _bindgen_ty_4 = _bindgen_ty_4::IPPROTO_IPIP;
pub const IPPROTO_TCP: _bindgen_ty_4 = _bindgen_ty_4::IPPROTO_TCP;
pub const IPPROTO_EGP: _bindgen_ty_4 = _bindgen_ty_4::IPPROTO_EGP;
pub const IPPROTO_PUP: _bindgen_ty_4 = _bindgen_ty_4::IPPROTO_PUP;
pub const IPPROTO_UDP: _bindgen_ty_4 = _bindgen_ty_4::IPPROTO_UDP;
pub const IPPROTO_IDP: _bindgen_ty_4 = _bindgen_ty_4::IPPROTO_IDP;
pub const IPPROTO_TP: _bindgen_ty_4 = _bindgen_ty_4::IPPROTO_TP;
pub const IPPROTO_DCCP: _bindgen_ty_4 = _bindgen_ty_4::IPPROTO_DCCP;
pub const IPPROTO_IPV6: _bindgen_ty_4 = _bindgen_ty_4::IPPROTO_IPV6;
pub const IPPROTO_RSVP: _bindgen_ty_4 = _bindgen_ty_4::IPPROTO_RSVP;
pub const IPPROTO_GRE: _bindgen_ty_4 = _bindgen_ty_4::IPPROTO_GRE;
pub const IPPROTO_ESP: _bindgen_ty_4 = _bindgen_ty_4::IPPROTO_ESP;
pub const IPPROTO_AH: _bindgen_ty_4 = _bindgen_ty_4::IPPROTO_AH;
pub const IPPROTO_MTP: _bindgen_ty_4 = _bindgen_ty_4::IPPROTO_MTP;
pub const IPPROTO_BEETPH: _bindgen_ty_4 = _bindgen_ty_4::IPPROTO_BEETPH;
pub const IPPROTO_ENCAP: _bindgen_ty_4 = _bindgen_ty_4::IPPROTO_ENCAP;
pub const IPPROTO_PIM: _bindgen_ty_4 = _bindgen_ty_4::IPPROTO_PIM;
pub const IPPROTO_COMP: _bindgen_ty_4 = _bindgen_ty_4::IPPROTO_COMP;
pub const IPPROTO_SCTP: _bindgen_ty_4 = _bindgen_ty_4::IPPROTO_SCTP;
pub const IPPROTO_UDPLITE: _bindgen_ty_4 = _bindgen_ty_4::IPPROTO_UDPLITE;
pub const IPPROTO_MPLS: _bindgen_ty_4 = _bindgen_ty_4::IPPROTO_MPLS;
pub const IPPROTO_RAW: _bindgen_ty_4 = _bindgen_ty_4::IPPROTO_RAW;
pub const IPPROTO_MAX: _bindgen_ty_4 = _bindgen_ty_4::IPPROTO_MAX;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_4 {
    IPPROTO_IP = 0,
    IPPROTO_ICMP = 1,
    IPPROTO_IGMP = 2,
    IPPROTO_IPIP = 4,
    IPPROTO_TCP = 6,
    IPPROTO_EGP = 8,
    IPPROTO_PUP = 12,
    IPPROTO_UDP = 17,
    IPPROTO_IDP = 22,
    IPPROTO_TP = 29,
    IPPROTO_DCCP = 33,
    IPPROTO_IPV6 = 41,
    IPPROTO_RSVP = 46,
    IPPROTO_GRE = 47,
    IPPROTO_ESP = 50,
    IPPROTO_AH = 51,
    IPPROTO_MTP = 92,
    IPPROTO_BEETPH = 94,
    IPPROTO_ENCAP = 98,
    IPPROTO_PIM = 103,
    IPPROTO_COMP = 108,
    IPPROTO_SCTP = 132,
    IPPROTO_UDPLITE = 136,
    IPPROTO_MPLS = 137,
    IPPROTO_RAW = 255,
    IPPROTO_MAX = 256,
}
pub const IPPROTO_HOPOPTS: _bindgen_ty_5 = _bindgen_ty_5::IPPROTO_HOPOPTS;
pub const IPPROTO_ROUTING: _bindgen_ty_5 = _bindgen_ty_5::IPPROTO_ROUTING;
pub const IPPROTO_FRAGMENT: _bindgen_ty_5 = _bindgen_ty_5::IPPROTO_FRAGMENT;
pub const IPPROTO_ICMPV6: _bindgen_ty_5 = _bindgen_ty_5::IPPROTO_ICMPV6;
pub const IPPROTO_NONE: _bindgen_ty_5 = _bindgen_ty_5::IPPROTO_NONE;
pub const IPPROTO_DSTOPTS: _bindgen_ty_5 = _bindgen_ty_5::IPPROTO_DSTOPTS;
pub const IPPROTO_MH: _bindgen_ty_5 = _bindgen_ty_5::IPPROTO_MH;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_5 {
    IPPROTO_HOPOPTS = 0,
    IPPROTO_ROUTING = 43,
    IPPROTO_FRAGMENT = 44,
    IPPROTO_ICMPV6 = 58,
    IPPROTO_NONE = 59,
    IPPROTO_DSTOPTS = 60,
    IPPROTO_MH = 135,
}
pub type in_port_t = u16;
pub const IPPORT_ECHO: _bindgen_ty_6 = _bindgen_ty_6::IPPORT_ECHO;
pub const IPPORT_DISCARD: _bindgen_ty_6 = _bindgen_ty_6::IPPORT_DISCARD;
pub const IPPORT_SYSTAT: _bindgen_ty_6 = _bindgen_ty_6::IPPORT_SYSTAT;
pub const IPPORT_DAYTIME: _bindgen_ty_6 = _bindgen_ty_6::IPPORT_DAYTIME;
pub const IPPORT_NETSTAT: _bindgen_ty_6 = _bindgen_ty_6::IPPORT_NETSTAT;
pub const IPPORT_FTP: _bindgen_ty_6 = _bindgen_ty_6::IPPORT_FTP;
pub const IPPORT_TELNET: _bindgen_ty_6 = _bindgen_ty_6::IPPORT_TELNET;
pub const IPPORT_SMTP: _bindgen_ty_6 = _bindgen_ty_6::IPPORT_SMTP;
pub const IPPORT_TIMESERVER: _bindgen_ty_6 = _bindgen_ty_6::IPPORT_TIMESERVER;
pub const IPPORT_NAMESERVER: _bindgen_ty_6 = _bindgen_ty_6::IPPORT_NAMESERVER;
pub const IPPORT_WHOIS: _bindgen_ty_6 = _bindgen_ty_6::IPPORT_WHOIS;
pub const IPPORT_MTP: _bindgen_ty_6 = _bindgen_ty_6::IPPORT_MTP;
pub const IPPORT_TFTP: _bindgen_ty_6 = _bindgen_ty_6::IPPORT_TFTP;
pub const IPPORT_RJE: _bindgen_ty_6 = _bindgen_ty_6::IPPORT_RJE;
pub const IPPORT_FINGER: _bindgen_ty_6 = _bindgen_ty_6::IPPORT_FINGER;
pub const IPPORT_TTYLINK: _bindgen_ty_6 = _bindgen_ty_6::IPPORT_TTYLINK;
pub const IPPORT_SUPDUP: _bindgen_ty_6 = _bindgen_ty_6::IPPORT_SUPDUP;
pub const IPPORT_EXECSERVER: _bindgen_ty_6 = _bindgen_ty_6::IPPORT_EXECSERVER;
pub const IPPORT_LOGINSERVER: _bindgen_ty_6 =
    _bindgen_ty_6::IPPORT_LOGINSERVER;
pub const IPPORT_CMDSERVER: _bindgen_ty_6 = _bindgen_ty_6::IPPORT_CMDSERVER;
pub const IPPORT_EFSSERVER: _bindgen_ty_6 = _bindgen_ty_6::IPPORT_EFSSERVER;
pub const IPPORT_BIFFUDP: _bindgen_ty_6 = _bindgen_ty_6::IPPORT_EXECSERVER;
pub const IPPORT_WHOSERVER: _bindgen_ty_6 = _bindgen_ty_6::IPPORT_LOGINSERVER;
pub const IPPORT_ROUTESERVER: _bindgen_ty_6 = _bindgen_ty_6::IPPORT_EFSSERVER;
pub const IPPORT_RESERVED: _bindgen_ty_6 = _bindgen_ty_6::IPPORT_RESERVED;
pub const IPPORT_USERRESERVED: _bindgen_ty_6 =
    _bindgen_ty_6::IPPORT_USERRESERVED;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_6 {
    IPPORT_ECHO = 7,
    IPPORT_DISCARD = 9,
    IPPORT_SYSTAT = 11,
    IPPORT_DAYTIME = 13,
    IPPORT_NETSTAT = 15,
    IPPORT_FTP = 21,
    IPPORT_TELNET = 23,
    IPPORT_SMTP = 25,
    IPPORT_TIMESERVER = 37,
    IPPORT_NAMESERVER = 42,
    IPPORT_WHOIS = 43,
    IPPORT_MTP = 57,
    IPPORT_TFTP = 69,
    IPPORT_RJE = 77,
    IPPORT_FINGER = 79,
    IPPORT_TTYLINK = 87,
    IPPORT_SUPDUP = 95,
    IPPORT_EXECSERVER = 512,
    IPPORT_LOGINSERVER = 513,
    IPPORT_CMDSERVER = 514,
    IPPORT_EFSSERVER = 520,
    IPPORT_RESERVED = 1024,
    IPPORT_USERRESERVED = 5000,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct in6_addr {
    pub __in6_u: in6_addr__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct in6_addr__bindgen_ty_1 {
    pub __u6_addr8: __BindgenUnionField<[u8; 16usize]>,
    pub __u6_addr16: __BindgenUnionField<[u16; 8usize]>,
    pub __u6_addr32: __BindgenUnionField<[u32; 4usize]>,
    pub bindgen_union_field: [u32; 4usize],
}
#[test]
fn bindgen_test_layout_in6_addr__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<in6_addr__bindgen_ty_1>() , 16usize ,
               concat ! ( "Size of: " , stringify ! ( in6_addr__bindgen_ty_1 )
               ));
    assert_eq! (::std::mem::align_of::<in6_addr__bindgen_ty_1>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( in6_addr__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const in6_addr__bindgen_ty_1 ) ) . __u6_addr8
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( in6_addr__bindgen_ty_1
                ) , "::" , stringify ! ( __u6_addr8 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const in6_addr__bindgen_ty_1 ) ) . __u6_addr16
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( in6_addr__bindgen_ty_1
                ) , "::" , stringify ! ( __u6_addr16 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const in6_addr__bindgen_ty_1 ) ) . __u6_addr32
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( in6_addr__bindgen_ty_1
                ) , "::" , stringify ! ( __u6_addr32 ) ));
}
impl Clone for in6_addr__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_in6_addr() {
    assert_eq!(::std::mem::size_of::<in6_addr>() , 16usize , concat ! (
               "Size of: " , stringify ! ( in6_addr ) ));
    assert_eq! (::std::mem::align_of::<in6_addr>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( in6_addr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const in6_addr ) ) . __in6_u as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( in6_addr ) , "::" ,
                stringify ! ( __in6_u ) ));
}
impl Clone for in6_addr {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    #[link_name = "in6addr_any"]
    pub static in6addr_any: in6_addr;
}
extern "C" {
    #[link_name = "in6addr_loopback"]
    pub static in6addr_loopback: in6_addr;
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct sockaddr_in {
    pub sin_family: sa_family_t,
    pub sin_port: in_port_t,
    pub sin_addr: in_addr,
    pub sin_zero: [::std::os::raw::c_uchar; 8usize],
}
#[test]
fn bindgen_test_layout_sockaddr_in() {
    assert_eq!(::std::mem::size_of::<sockaddr_in>() , 16usize , concat ! (
               "Size of: " , stringify ! ( sockaddr_in ) ));
    assert_eq! (::std::mem::align_of::<sockaddr_in>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( sockaddr_in ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sockaddr_in ) ) . sin_family as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( sockaddr_in ) , "::" ,
                stringify ! ( sin_family ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sockaddr_in ) ) . sin_port as * const _
                as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! ( sockaddr_in ) , "::" ,
                stringify ! ( sin_port ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sockaddr_in ) ) . sin_addr as * const _
                as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( sockaddr_in ) , "::" ,
                stringify ! ( sin_addr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sockaddr_in ) ) . sin_zero as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( sockaddr_in ) , "::" ,
                stringify ! ( sin_zero ) ));
}
impl Clone for sockaddr_in {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct sockaddr_in6 {
    pub sin6_family: sa_family_t,
    pub sin6_port: in_port_t,
    pub sin6_flowinfo: u32,
    pub sin6_addr: in6_addr,
    pub sin6_scope_id: u32,
}
#[test]
fn bindgen_test_layout_sockaddr_in6() {
    assert_eq!(::std::mem::size_of::<sockaddr_in6>() , 28usize , concat ! (
               "Size of: " , stringify ! ( sockaddr_in6 ) ));
    assert_eq! (::std::mem::align_of::<sockaddr_in6>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( sockaddr_in6 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sockaddr_in6 ) ) . sin6_family as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( sockaddr_in6 ) , "::" ,
                stringify ! ( sin6_family ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sockaddr_in6 ) ) . sin6_port as * const _
                as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! ( sockaddr_in6 ) , "::" ,
                stringify ! ( sin6_port ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sockaddr_in6 ) ) . sin6_flowinfo as *
                const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( sockaddr_in6 ) , "::" ,
                stringify ! ( sin6_flowinfo ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sockaddr_in6 ) ) . sin6_addr as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( sockaddr_in6 ) , "::" ,
                stringify ! ( sin6_addr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sockaddr_in6 ) ) . sin6_scope_id as *
                const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( sockaddr_in6 ) , "::" ,
                stringify ! ( sin6_scope_id ) ));
}
impl Clone for sockaddr_in6 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct ip_mreq {
    pub imr_multiaddr: in_addr,
    pub imr_interface: in_addr,
}
#[test]
fn bindgen_test_layout_ip_mreq() {
    assert_eq!(::std::mem::size_of::<ip_mreq>() , 8usize , concat ! (
               "Size of: " , stringify ! ( ip_mreq ) ));
    assert_eq! (::std::mem::align_of::<ip_mreq>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( ip_mreq ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ip_mreq ) ) . imr_multiaddr as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ip_mreq ) , "::" ,
                stringify ! ( imr_multiaddr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ip_mreq ) ) . imr_interface as * const _
                as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( ip_mreq ) , "::" ,
                stringify ! ( imr_interface ) ));
}
impl Clone for ip_mreq {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct ip_mreq_source {
    pub imr_multiaddr: in_addr,
    pub imr_interface: in_addr,
    pub imr_sourceaddr: in_addr,
}
#[test]
fn bindgen_test_layout_ip_mreq_source() {
    assert_eq!(::std::mem::size_of::<ip_mreq_source>() , 12usize , concat ! (
               "Size of: " , stringify ! ( ip_mreq_source ) ));
    assert_eq! (::std::mem::align_of::<ip_mreq_source>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( ip_mreq_source ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ip_mreq_source ) ) . imr_multiaddr as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ip_mreq_source ) , "::"
                , stringify ! ( imr_multiaddr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ip_mreq_source ) ) . imr_interface as *
                const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( ip_mreq_source ) , "::"
                , stringify ! ( imr_interface ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ip_mreq_source ) ) . imr_sourceaddr as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( ip_mreq_source ) , "::"
                , stringify ! ( imr_sourceaddr ) ));
}
impl Clone for ip_mreq_source {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct ipv6_mreq {
    pub ipv6mr_multiaddr: in6_addr,
    pub ipv6mr_interface: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_ipv6_mreq() {
    assert_eq!(::std::mem::size_of::<ipv6_mreq>() , 20usize , concat ! (
               "Size of: " , stringify ! ( ipv6_mreq ) ));
    assert_eq! (::std::mem::align_of::<ipv6_mreq>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( ipv6_mreq ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ipv6_mreq ) ) . ipv6mr_multiaddr as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ipv6_mreq ) , "::" ,
                stringify ! ( ipv6mr_multiaddr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ipv6_mreq ) ) . ipv6mr_interface as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( ipv6_mreq ) , "::" ,
                stringify ! ( ipv6mr_interface ) ));
}
impl Clone for ipv6_mreq {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
pub struct group_req {
    pub gr_interface: u32,
    pub gr_group: sockaddr_storage,
}
#[test]
fn bindgen_test_layout_group_req() {
    assert_eq!(::std::mem::size_of::<group_req>() , 136usize , concat ! (
               "Size of: " , stringify ! ( group_req ) ));
    assert_eq! (::std::mem::align_of::<group_req>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( group_req ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const group_req ) ) . gr_interface as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( group_req ) , "::" ,
                stringify ! ( gr_interface ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const group_req ) ) . gr_group as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( group_req ) , "::" ,
                stringify ! ( gr_group ) ));
}
#[repr(C)]
pub struct group_source_req {
    pub gsr_interface: u32,
    pub gsr_group: sockaddr_storage,
    pub gsr_source: sockaddr_storage,
}
#[test]
fn bindgen_test_layout_group_source_req() {
    assert_eq!(::std::mem::size_of::<group_source_req>() , 264usize , concat !
               ( "Size of: " , stringify ! ( group_source_req ) ));
    assert_eq! (::std::mem::align_of::<group_source_req>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( group_source_req ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const group_source_req ) ) . gsr_interface as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( group_source_req ) ,
                "::" , stringify ! ( gsr_interface ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const group_source_req ) ) . gsr_group as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( group_source_req ) ,
                "::" , stringify ! ( gsr_group ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const group_source_req ) ) . gsr_source as *
                const _ as usize } , 136usize , concat ! (
                "Alignment of field: " , stringify ! ( group_source_req ) ,
                "::" , stringify ! ( gsr_source ) ));
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct ip_msfilter {
    pub imsf_multiaddr: in_addr,
    pub imsf_interface: in_addr,
    pub imsf_fmode: u32,
    pub imsf_numsrc: u32,
    pub imsf_slist: [in_addr; 1usize],
}
#[test]
fn bindgen_test_layout_ip_msfilter() {
    assert_eq!(::std::mem::size_of::<ip_msfilter>() , 20usize , concat ! (
               "Size of: " , stringify ! ( ip_msfilter ) ));
    assert_eq! (::std::mem::align_of::<ip_msfilter>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( ip_msfilter ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ip_msfilter ) ) . imsf_multiaddr as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ip_msfilter ) , "::" ,
                stringify ! ( imsf_multiaddr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ip_msfilter ) ) . imsf_interface as *
                const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( ip_msfilter ) , "::" ,
                stringify ! ( imsf_interface ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ip_msfilter ) ) . imsf_fmode as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( ip_msfilter ) , "::" ,
                stringify ! ( imsf_fmode ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ip_msfilter ) ) . imsf_numsrc as * const
                _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( ip_msfilter ) , "::" ,
                stringify ! ( imsf_numsrc ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ip_msfilter ) ) . imsf_slist as * const _
                as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( ip_msfilter ) , "::" ,
                stringify ! ( imsf_slist ) ));
}
impl Clone for ip_msfilter {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
pub struct group_filter {
    pub gf_interface: u32,
    pub gf_group: sockaddr_storage,
    pub gf_fmode: u32,
    pub gf_numsrc: u32,
    pub gf_slist: [sockaddr_storage; 1usize],
}
#[test]
fn bindgen_test_layout_group_filter() {
    assert_eq!(::std::mem::size_of::<group_filter>() , 272usize , concat ! (
               "Size of: " , stringify ! ( group_filter ) ));
    assert_eq! (::std::mem::align_of::<group_filter>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( group_filter ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const group_filter ) ) . gf_interface as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( group_filter ) , "::" ,
                stringify ! ( gf_interface ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const group_filter ) ) . gf_group as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( group_filter ) , "::" ,
                stringify ! ( gf_group ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const group_filter ) ) . gf_fmode as * const _
                as usize } , 136usize , concat ! (
                "Alignment of field: " , stringify ! ( group_filter ) , "::" ,
                stringify ! ( gf_fmode ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const group_filter ) ) . gf_numsrc as * const _
                as usize } , 140usize , concat ! (
                "Alignment of field: " , stringify ! ( group_filter ) , "::" ,
                stringify ! ( gf_numsrc ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const group_filter ) ) . gf_slist as * const _
                as usize } , 144usize , concat ! (
                "Alignment of field: " , stringify ! ( group_filter ) , "::" ,
                stringify ! ( gf_slist ) ));
}
extern "C" {
    pub fn ntohl(__netlong: u32) -> u32;
}
extern "C" {
    pub fn ntohs(__netshort: u16) -> u16;
}
extern "C" {
    pub fn htonl(__hostlong: u32) -> u32;
}
extern "C" {
    pub fn htons(__hostshort: u16) -> u16;
}
extern "C" {
    pub fn bindresvport(__sockfd: ::std::os::raw::c_int,
                        __sock_in: *mut sockaddr_in) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bindresvport6(__sockfd: ::std::os::raw::c_int,
                         __sock_in: *mut sockaddr_in6)
     -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct asn_TYPE_descriptor_s {
    pub name: *mut ::std::os::raw::c_char,
    pub xml_tag: *mut ::std::os::raw::c_char,
    pub free_struct: asn_struct_free_f,
    pub print_struct: asn_struct_print_f,
    pub check_constraints: asn_constr_check_f,
    pub ber_decoder: ber_type_decoder_f,
    pub der_encoder: der_type_encoder_f,
    pub xer_decoder: xer_type_decoder_f,
    pub xer_encoder: xer_type_encoder_f,
    pub uper_decoder: per_type_decoder_f,
    pub uper_encoder: per_type_encoder_f,
    pub outmost_tag: asn_outmost_tag_f,
    pub tags: *mut ber_tlv_tag_t,
    pub tags_count: ::std::os::raw::c_int,
    pub all_tags: *mut ber_tlv_tag_t,
    pub all_tags_count: ::std::os::raw::c_int,
    pub per_constraints: *mut asn_per_constraints_t,
    pub elements: *mut asn_TYPE_member_s,
    pub elements_count: ::std::os::raw::c_int,
    pub specifics: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_asn_TYPE_descriptor_s() {
    assert_eq!(::std::mem::size_of::<asn_TYPE_descriptor_s>() , 160usize ,
               concat ! ( "Size of: " , stringify ! ( asn_TYPE_descriptor_s )
               ));
    assert_eq! (::std::mem::align_of::<asn_TYPE_descriptor_s>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( asn_TYPE_descriptor_s ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const asn_TYPE_descriptor_s ) ) . name as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( asn_TYPE_descriptor_s )
                , "::" , stringify ! ( name ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const asn_TYPE_descriptor_s ) ) . xml_tag as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( asn_TYPE_descriptor_s )
                , "::" , stringify ! ( xml_tag ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const asn_TYPE_descriptor_s ) ) . free_struct
                as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( asn_TYPE_descriptor_s )
                , "::" , stringify ! ( free_struct ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const asn_TYPE_descriptor_s ) ) . print_struct
                as * const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( asn_TYPE_descriptor_s )
                , "::" , stringify ! ( print_struct ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const asn_TYPE_descriptor_s ) ) .
                check_constraints as * const _ as usize } , 32usize , concat !
                (
                "Alignment of field: " , stringify ! ( asn_TYPE_descriptor_s )
                , "::" , stringify ! ( check_constraints ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const asn_TYPE_descriptor_s ) ) . ber_decoder
                as * const _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( asn_TYPE_descriptor_s )
                , "::" , stringify ! ( ber_decoder ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const asn_TYPE_descriptor_s ) ) . der_encoder
                as * const _ as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( asn_TYPE_descriptor_s )
                , "::" , stringify ! ( der_encoder ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const asn_TYPE_descriptor_s ) ) . xer_decoder
                as * const _ as usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( asn_TYPE_descriptor_s )
                , "::" , stringify ! ( xer_decoder ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const asn_TYPE_descriptor_s ) ) . xer_encoder
                as * const _ as usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( asn_TYPE_descriptor_s )
                , "::" , stringify ! ( xer_encoder ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const asn_TYPE_descriptor_s ) ) . uper_decoder
                as * const _ as usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( asn_TYPE_descriptor_s )
                , "::" , stringify ! ( uper_decoder ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const asn_TYPE_descriptor_s ) ) . uper_encoder
                as * const _ as usize } , 80usize , concat ! (
                "Alignment of field: " , stringify ! ( asn_TYPE_descriptor_s )
                , "::" , stringify ! ( uper_encoder ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const asn_TYPE_descriptor_s ) ) . outmost_tag
                as * const _ as usize } , 88usize , concat ! (
                "Alignment of field: " , stringify ! ( asn_TYPE_descriptor_s )
                , "::" , stringify ! ( outmost_tag ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const asn_TYPE_descriptor_s ) ) . tags as *
                const _ as usize } , 96usize , concat ! (
                "Alignment of field: " , stringify ! ( asn_TYPE_descriptor_s )
                , "::" , stringify ! ( tags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const asn_TYPE_descriptor_s ) ) . tags_count as
                * const _ as usize } , 104usize , concat ! (
                "Alignment of field: " , stringify ! ( asn_TYPE_descriptor_s )
                , "::" , stringify ! ( tags_count ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const asn_TYPE_descriptor_s ) ) . all_tags as *
                const _ as usize } , 112usize , concat ! (
                "Alignment of field: " , stringify ! ( asn_TYPE_descriptor_s )
                , "::" , stringify ! ( all_tags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const asn_TYPE_descriptor_s ) ) .
                all_tags_count as * const _ as usize } , 120usize , concat ! (
                "Alignment of field: " , stringify ! ( asn_TYPE_descriptor_s )
                , "::" , stringify ! ( all_tags_count ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const asn_TYPE_descriptor_s ) ) .
                per_constraints as * const _ as usize } , 128usize , concat !
                (
                "Alignment of field: " , stringify ! ( asn_TYPE_descriptor_s )
                , "::" , stringify ! ( per_constraints ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const asn_TYPE_descriptor_s ) ) . elements as *
                const _ as usize } , 136usize , concat ! (
                "Alignment of field: " , stringify ! ( asn_TYPE_descriptor_s )
                , "::" , stringify ! ( elements ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const asn_TYPE_descriptor_s ) ) .
                elements_count as * const _ as usize } , 144usize , concat ! (
                "Alignment of field: " , stringify ! ( asn_TYPE_descriptor_s )
                , "::" , stringify ! ( elements_count ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const asn_TYPE_descriptor_s ) ) . specifics as
                * const _ as usize } , 152usize , concat ! (
                "Alignment of field: " , stringify ! ( asn_TYPE_descriptor_s )
                , "::" , stringify ! ( specifics ) ));
}
impl Clone for asn_TYPE_descriptor_s {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct asn_codec_ctx_s {
    pub max_stack_size: usize,
}
#[test]
fn bindgen_test_layout_asn_codec_ctx_s() {
    assert_eq!(::std::mem::size_of::<asn_codec_ctx_s>() , 8usize , concat ! (
               "Size of: " , stringify ! ( asn_codec_ctx_s ) ));
    assert_eq! (::std::mem::align_of::<asn_codec_ctx_s>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( asn_codec_ctx_s ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const asn_codec_ctx_s ) ) . max_stack_size as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( asn_codec_ctx_s ) ,
                "::" , stringify ! ( max_stack_size ) ));
}
impl Clone for asn_codec_ctx_s {
    fn clone(&self) -> Self { *self }
}
pub type asn_codec_ctx_t = asn_codec_ctx_s;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct asn_enc_rval_s {
    pub encoded: isize,
    pub failed_type: *mut asn_TYPE_descriptor_s,
    pub structure_ptr: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_asn_enc_rval_s() {
    assert_eq!(::std::mem::size_of::<asn_enc_rval_s>() , 24usize , concat ! (
               "Size of: " , stringify ! ( asn_enc_rval_s ) ));
    assert_eq! (::std::mem::align_of::<asn_enc_rval_s>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( asn_enc_rval_s ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const asn_enc_rval_s ) ) . encoded as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( asn_enc_rval_s ) , "::"
                , stringify ! ( encoded ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const asn_enc_rval_s ) ) . failed_type as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( asn_enc_rval_s ) , "::"
                , stringify ! ( failed_type ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const asn_enc_rval_s ) ) . structure_ptr as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( asn_enc_rval_s ) , "::"
                , stringify ! ( structure_ptr ) ));
}
impl Clone for asn_enc_rval_s {
    fn clone(&self) -> Self { *self }
}
pub type asn_enc_rval_t = asn_enc_rval_s;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum asn_dec_rval_code_e { RC_OK = 0, RC_WMORE = 1, RC_FAIL = 2, }
#[repr(C)]
#[derive(Debug, Copy)]
pub struct asn_dec_rval_s {
    pub code: asn_dec_rval_code_e,
    pub consumed: usize,
}
#[test]
fn bindgen_test_layout_asn_dec_rval_s() {
    assert_eq!(::std::mem::size_of::<asn_dec_rval_s>() , 16usize , concat ! (
               "Size of: " , stringify ! ( asn_dec_rval_s ) ));
    assert_eq! (::std::mem::align_of::<asn_dec_rval_s>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( asn_dec_rval_s ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const asn_dec_rval_s ) ) . code as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( asn_dec_rval_s ) , "::"
                , stringify ! ( code ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const asn_dec_rval_s ) ) . consumed as * const
                _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( asn_dec_rval_s ) , "::"
                , stringify ! ( consumed ) ));
}
impl Clone for asn_dec_rval_s {
    fn clone(&self) -> Self { *self }
}
pub type asn_dec_rval_t = asn_dec_rval_s;
pub type asn_app_consume_bytes_f =
    ::std::option::Option<unsafe extern "C" fn(buffer:
                                                   *const ::std::os::raw::c_void,
                                               size: usize,
                                               application_specific_key:
                                                   *mut ::std::os::raw::c_void)
                              -> ::std::os::raw::c_int>;
pub type asn_app_constraint_failed_f =
    ::std::option::Option<unsafe extern "C" fn(application_specific_key:
                                                   *mut ::std::os::raw::c_void,
                                               type_descriptor_which_failed:
                                                   *mut asn_TYPE_descriptor_s,
                                               structure_which_failed_ptr:
                                                   *const ::std::os::raw::c_void,
                                               error_message_format:
                                                   *const ::std::os::raw::c_char, ...)>;
pub type ber_tlv_len_t = isize;
extern "C" {
    pub fn ber_fetch_length(_is_constructed: ::std::os::raw::c_int,
                            bufptr: *const ::std::os::raw::c_void,
                            size: usize, len_r: *mut ber_tlv_len_t) -> isize;
}
extern "C" {
    pub fn ber_skip_length(opt_codec_ctx: *mut asn_codec_ctx_s,
                           _is_constructed: ::std::os::raw::c_int,
                           bufptr: *const ::std::os::raw::c_void, size: usize)
     -> isize;
}
extern "C" {
    pub fn der_tlv_length_serialize(len: ber_tlv_len_t,
                                    bufptr: *mut ::std::os::raw::c_void,
                                    size: usize) -> usize;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum asn_tag_class {
    ASN_TAG_CLASS_UNIVERSAL = 0,
    ASN_TAG_CLASS_APPLICATION = 1,
    ASN_TAG_CLASS_CONTEXT = 2,
    ASN_TAG_CLASS_PRIVATE = 3,
}
pub type ber_tlv_tag_t = ::std::os::raw::c_uint;
extern "C" {
    pub fn ber_tlv_tag_snprint(tag: ber_tlv_tag_t,
                               buf: *mut ::std::os::raw::c_char,
                               buflen: usize) -> isize;
}
extern "C" {
    pub fn ber_tlv_tag_fwrite(tag: ber_tlv_tag_t, arg1: *mut FILE) -> isize;
}
extern "C" {
    pub fn ber_tlv_tag_string(tag: ber_tlv_tag_t)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ber_fetch_tag(bufptr: *const ::std::os::raw::c_void, size: usize,
                         tag_r: *mut ber_tlv_tag_t) -> isize;
}
extern "C" {
    pub fn ber_tlv_tag_serialize(tag: ber_tlv_tag_t,
                                 bufptr: *mut ::std::os::raw::c_void,
                                 size: usize) -> usize;
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct asn_TYPE_member_s {
    pub flags: asn_TYPE_flags_e,
    pub optional: ::std::os::raw::c_int,
    pub memb_offset: ::std::os::raw::c_int,
    pub tag: ber_tlv_tag_t,
    pub tag_mode: ::std::os::raw::c_int,
    pub type_: *mut asn_TYPE_descriptor_t,
    pub memb_constraints: asn_constr_check_f,
    pub per_constraints: *mut asn_per_constraints_t,
    pub default_value: ::std::option::Option<unsafe extern "C" fn(setval:
                                                                      ::std::os::raw::c_int,
                                                                  sptr:
                                                                      *mut *mut ::std::os::raw::c_void)
                                                 -> ::std::os::raw::c_int>,
    pub name: *mut ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_asn_TYPE_member_s() {
    assert_eq!(::std::mem::size_of::<asn_TYPE_member_s>() , 64usize , concat !
               ( "Size of: " , stringify ! ( asn_TYPE_member_s ) ));
    assert_eq! (::std::mem::align_of::<asn_TYPE_member_s>() , 8usize , concat
                ! ( "Alignment of " , stringify ! ( asn_TYPE_member_s ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const asn_TYPE_member_s ) ) . flags as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( asn_TYPE_member_s ) ,
                "::" , stringify ! ( flags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const asn_TYPE_member_s ) ) . optional as *
                const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( asn_TYPE_member_s ) ,
                "::" , stringify ! ( optional ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const asn_TYPE_member_s ) ) . memb_offset as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( asn_TYPE_member_s ) ,
                "::" , stringify ! ( memb_offset ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const asn_TYPE_member_s ) ) . tag as * const _
                as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( asn_TYPE_member_s ) ,
                "::" , stringify ! ( tag ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const asn_TYPE_member_s ) ) . tag_mode as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( asn_TYPE_member_s ) ,
                "::" , stringify ! ( tag_mode ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const asn_TYPE_member_s ) ) . type_ as * const
                _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( asn_TYPE_member_s ) ,
                "::" , stringify ! ( type_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const asn_TYPE_member_s ) ) . memb_constraints
                as * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( asn_TYPE_member_s ) ,
                "::" , stringify ! ( memb_constraints ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const asn_TYPE_member_s ) ) . per_constraints
                as * const _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( asn_TYPE_member_s ) ,
                "::" , stringify ! ( per_constraints ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const asn_TYPE_member_s ) ) . default_value as
                * const _ as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( asn_TYPE_member_s ) ,
                "::" , stringify ! ( default_value ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const asn_TYPE_member_s ) ) . name as * const _
                as usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( asn_TYPE_member_s ) ,
                "::" , stringify ! ( name ) ));
}
impl Clone for asn_TYPE_member_s {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct asn_struct_ctx_s {
    pub phase: ::std::os::raw::c_short,
    pub step: ::std::os::raw::c_short,
    pub context: ::std::os::raw::c_int,
    pub ptr: *mut ::std::os::raw::c_void,
    pub left: ber_tlv_len_t,
}
#[test]
fn bindgen_test_layout_asn_struct_ctx_s() {
    assert_eq!(::std::mem::size_of::<asn_struct_ctx_s>() , 24usize , concat !
               ( "Size of: " , stringify ! ( asn_struct_ctx_s ) ));
    assert_eq! (::std::mem::align_of::<asn_struct_ctx_s>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( asn_struct_ctx_s ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const asn_struct_ctx_s ) ) . phase as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( asn_struct_ctx_s ) ,
                "::" , stringify ! ( phase ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const asn_struct_ctx_s ) ) . step as * const _
                as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! ( asn_struct_ctx_s ) ,
                "::" , stringify ! ( step ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const asn_struct_ctx_s ) ) . context as * const
                _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( asn_struct_ctx_s ) ,
                "::" , stringify ! ( context ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const asn_struct_ctx_s ) ) . ptr as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( asn_struct_ctx_s ) ,
                "::" , stringify ! ( ptr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const asn_struct_ctx_s ) ) . left as * const _
                as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( asn_struct_ctx_s ) ,
                "::" , stringify ! ( left ) ));
}
impl Clone for asn_struct_ctx_s {
    fn clone(&self) -> Self { *self }
}
pub type asn_struct_ctx_t = asn_struct_ctx_s;
extern "C" {
    pub fn ber_decode(opt_codec_ctx: *mut asn_codec_ctx_s,
                      type_descriptor: *mut asn_TYPE_descriptor_s,
                      struct_ptr: *mut *mut ::std::os::raw::c_void,
                      buffer: *const ::std::os::raw::c_void, size: usize)
     -> asn_dec_rval_t;
}
pub type ber_type_decoder_f =
    ::std::option::Option<unsafe extern "C" fn(opt_codec_ctx:
                                                   *mut asn_codec_ctx_s,
                                               type_descriptor:
                                                   *mut asn_TYPE_descriptor_s,
                                               struct_ptr:
                                                   *mut *mut ::std::os::raw::c_void,
                                               buf_ptr:
                                                   *const ::std::os::raw::c_void,
                                               size: usize,
                                               tag_mode:
                                                   ::std::os::raw::c_int)
                              -> asn_dec_rval_t>;
extern "C" {
    pub fn ber_check_tags(opt_codec_ctx: *mut asn_codec_ctx_s,
                          type_descriptor: *mut asn_TYPE_descriptor_s,
                          opt_ctx: *mut asn_struct_ctx_t,
                          ptr: *const ::std::os::raw::c_void, size: usize,
                          tag_mode: ::std::os::raw::c_int,
                          last_tag_form: ::std::os::raw::c_int,
                          last_length: *mut ber_tlv_len_t,
                          opt_tlv_form: *mut ::std::os::raw::c_int)
     -> asn_dec_rval_t;
}
extern "C" {
    pub fn der_encode(type_descriptor: *mut asn_TYPE_descriptor_s,
                      struct_ptr: *mut ::std::os::raw::c_void,
                      consume_bytes_cb: asn_app_consume_bytes_f,
                      app_key: *mut ::std::os::raw::c_void) -> asn_enc_rval_t;
}
extern "C" {
    pub fn der_encode_to_buffer(type_descriptor: *mut asn_TYPE_descriptor_s,
                                struct_ptr: *mut ::std::os::raw::c_void,
                                buffer: *mut ::std::os::raw::c_void,
                                buffer_size: usize) -> asn_enc_rval_t;
}
pub type der_type_encoder_f =
    ::std::option::Option<unsafe extern "C" fn(type_descriptor:
                                                   *mut asn_TYPE_descriptor_s,
                                               struct_ptr:
                                                   *mut ::std::os::raw::c_void,
                                               tag_mode:
                                                   ::std::os::raw::c_int,
                                               tag: ber_tlv_tag_t,
                                               consume_bytes_cb:
                                                   asn_app_consume_bytes_f,
                                               app_key:
                                                   *mut ::std::os::raw::c_void)
                              -> asn_enc_rval_t>;
extern "C" {
    pub fn der_write_tags(type_descriptor: *mut asn_TYPE_descriptor_s,
                          struct_length: usize,
                          tag_mode: ::std::os::raw::c_int,
                          last_tag_form: ::std::os::raw::c_int,
                          tag: ber_tlv_tag_t,
                          consume_bytes_cb: asn_app_consume_bytes_f,
                          app_key: *mut ::std::os::raw::c_void) -> isize;
}
extern "C" {
    pub fn xer_decode(opt_codec_ctx: *mut asn_codec_ctx_s,
                      type_descriptor: *mut asn_TYPE_descriptor_s,
                      struct_ptr: *mut *mut ::std::os::raw::c_void,
                      buffer: *const ::std::os::raw::c_void, size: usize)
     -> asn_dec_rval_t;
}
pub type xer_type_decoder_f =
    ::std::option::Option<unsafe extern "C" fn(opt_codec_ctx:
                                                   *mut asn_codec_ctx_t,
                                               type_descriptor:
                                                   *mut asn_TYPE_descriptor_s,
                                               struct_ptr:
                                                   *mut *mut ::std::os::raw::c_void,
                                               opt_mname:
                                                   *const ::std::os::raw::c_char,
                                               buf_ptr:
                                                   *const ::std::os::raw::c_void,
                                               size: usize)
                              -> asn_dec_rval_t>;
extern "C" {
    pub fn xer_decode_general(opt_codec_ctx: *mut asn_codec_ctx_t,
                              ctx: *mut asn_struct_ctx_t,
                              struct_key: *mut ::std::os::raw::c_void,
                              xml_tag: *const ::std::os::raw::c_char,
                              buf_ptr: *const ::std::os::raw::c_void,
                              size: usize,
                              opt_unexpected_tag_decoder:
                                  ::std::option::Option<unsafe extern "C" fn(struct_key:
                                                                                 *mut ::std::os::raw::c_void,
                                                                             chunk_buf:
                                                                                 *const ::std::os::raw::c_void,
                                                                             chunk_size:
                                                                                 usize)
                                                            ->
                                                                ::std::os::raw::c_int>,
                              body_receiver:
                                  ::std::option::Option<unsafe extern "C" fn(struct_key:
                                                                                 *mut ::std::os::raw::c_void,
                                                                             chunk_buf:
                                                                                 *const ::std::os::raw::c_void,
                                                                             chunk_size:
                                                                                 usize,
                                                                             have_more:
                                                                                 ::std::os::raw::c_int)
                                                            -> isize>)
     -> asn_dec_rval_t;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum pxer_chunk_type { PXER_TAG = 0, PXER_TEXT = 1, PXER_COMMENT = 2, }
pub use self::pxer_chunk_type as pxer_chunk_type_e;
extern "C" {
    pub fn xer_next_token(stateContext: *mut ::std::os::raw::c_int,
                          buffer: *const ::std::os::raw::c_void, size: usize,
                          _ch_type: *mut pxer_chunk_type_e) -> isize;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum xer_check_tag {
    XCT_BROKEN = 0,
    XCT_OPENING = 1,
    XCT_CLOSING = 2,
    XCT_BOTH = 3,
    XCT__UNK__MASK = 4,
    XCT_UNKNOWN_OP = 5,
    XCT_UNKNOWN_CL = 6,
    XCT_UNKNOWN_BO = 7,
}
pub use self::xer_check_tag as xer_check_tag_e;
extern "C" {
    pub fn xer_check_tag(buf_ptr: *const ::std::os::raw::c_void,
                         size: ::std::os::raw::c_int,
                         need_tag: *const ::std::os::raw::c_char)
     -> xer_check_tag_e;
}
extern "C" {
    pub fn xer_whitespace_span(chunk_buf: *const ::std::os::raw::c_void,
                               chunk_size: usize) -> usize;
}
extern "C" {
    pub fn xer_skip_unknown(tcv: xer_check_tag_e, depth: *mut ber_tlv_len_t)
     -> ::std::os::raw::c_int;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum xer_encoder_flags_e { XER_F_BASIC = 1, XER_F_CANONICAL = 2, }
extern "C" {
    pub fn xer_encode(type_descriptor: *mut asn_TYPE_descriptor_s,
                      struct_ptr: *mut ::std::os::raw::c_void,
                      xer_flags: xer_encoder_flags_e,
                      consume_bytes_cb: asn_app_consume_bytes_f,
                      app_key: *mut ::std::os::raw::c_void) -> asn_enc_rval_t;
}
extern "C" {
    pub fn xer_fprint(stream: *mut FILE, td: *mut asn_TYPE_descriptor_s,
                      sptr: *mut ::std::os::raw::c_void)
     -> ::std::os::raw::c_int;
}
pub type xer_type_encoder_f =
    ::std::option::Option<unsafe extern "C" fn(type_descriptor:
                                                   *mut asn_TYPE_descriptor_s,
                                               struct_ptr:
                                                   *mut ::std::os::raw::c_void,
                                               ilevel: ::std::os::raw::c_int,
                                               xer_flags: xer_encoder_flags_e,
                                               consume_bytes_cb:
                                                   asn_app_consume_bytes_f,
                                               app_key:
                                                   *mut ::std::os::raw::c_void)
                              -> asn_enc_rval_t>;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct asn_per_constraint_s {
    pub flags: asn_per_constraint_s_asn_per_constraint_flags,
    pub range_bits: ::std::os::raw::c_int,
    pub effective_bits: ::std::os::raw::c_int,
    pub lower_bound: ::std::os::raw::c_long,
    pub upper_bound: ::std::os::raw::c_long,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum asn_per_constraint_s_asn_per_constraint_flags {
    APC_UNCONSTRAINED = 0,
    APC_SEMI_CONSTRAINED = 1,
    APC_CONSTRAINED = 2,
    APC_EXTENSIBLE = 4,
}
#[test]
fn bindgen_test_layout_asn_per_constraint_s() {
    assert_eq!(::std::mem::size_of::<asn_per_constraint_s>() , 32usize ,
               concat ! ( "Size of: " , stringify ! ( asn_per_constraint_s )
               ));
    assert_eq! (::std::mem::align_of::<asn_per_constraint_s>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( asn_per_constraint_s ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const asn_per_constraint_s ) ) . flags as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( asn_per_constraint_s )
                , "::" , stringify ! ( flags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const asn_per_constraint_s ) ) . range_bits as
                * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( asn_per_constraint_s )
                , "::" , stringify ! ( range_bits ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const asn_per_constraint_s ) ) . effective_bits
                as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( asn_per_constraint_s )
                , "::" , stringify ! ( effective_bits ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const asn_per_constraint_s ) ) . lower_bound as
                * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( asn_per_constraint_s )
                , "::" , stringify ! ( lower_bound ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const asn_per_constraint_s ) ) . upper_bound as
                * const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( asn_per_constraint_s )
                , "::" , stringify ! ( upper_bound ) ));
}
impl Clone for asn_per_constraint_s {
    fn clone(&self) -> Self { *self }
}
pub type asn_per_constraint_t = asn_per_constraint_s;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct asn_per_constraints_s {
    pub value: asn_per_constraint_t,
    pub size: asn_per_constraint_t,
    pub value2code: ::std::option::Option<unsafe extern "C" fn(value:
                                                                   ::std::os::raw::c_uint)
                                              -> ::std::os::raw::c_int>,
    pub code2value: ::std::option::Option<unsafe extern "C" fn(code:
                                                                   ::std::os::raw::c_uint)
                                              -> ::std::os::raw::c_int>,
}
#[test]
fn bindgen_test_layout_asn_per_constraints_s() {
    assert_eq!(::std::mem::size_of::<asn_per_constraints_s>() , 80usize ,
               concat ! ( "Size of: " , stringify ! ( asn_per_constraints_s )
               ));
    assert_eq! (::std::mem::align_of::<asn_per_constraints_s>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( asn_per_constraints_s ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const asn_per_constraints_s ) ) . value as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( asn_per_constraints_s )
                , "::" , stringify ! ( value ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const asn_per_constraints_s ) ) . size as *
                const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( asn_per_constraints_s )
                , "::" , stringify ! ( size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const asn_per_constraints_s ) ) . value2code as
                * const _ as usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( asn_per_constraints_s )
                , "::" , stringify ! ( value2code ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const asn_per_constraints_s ) ) . code2value as
                * const _ as usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( asn_per_constraints_s )
                , "::" , stringify ! ( code2value ) ));
}
impl Clone for asn_per_constraints_s {
    fn clone(&self) -> Self { *self }
}
pub type asn_per_constraints_t = asn_per_constraints_s;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct asn_per_data_s {
    pub buffer: *const u8,
    pub nboff: usize,
    pub nbits: usize,
    pub moved: usize,
    pub refill: ::std::option::Option<unsafe extern "C" fn(arg1:
                                                               *mut asn_per_data_s)
                                          -> ::std::os::raw::c_int>,
    pub refill_key: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_asn_per_data_s() {
    assert_eq!(::std::mem::size_of::<asn_per_data_s>() , 48usize , concat ! (
               "Size of: " , stringify ! ( asn_per_data_s ) ));
    assert_eq! (::std::mem::align_of::<asn_per_data_s>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( asn_per_data_s ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const asn_per_data_s ) ) . buffer as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( asn_per_data_s ) , "::"
                , stringify ! ( buffer ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const asn_per_data_s ) ) . nboff as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( asn_per_data_s ) , "::"
                , stringify ! ( nboff ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const asn_per_data_s ) ) . nbits as * const _
                as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( asn_per_data_s ) , "::"
                , stringify ! ( nbits ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const asn_per_data_s ) ) . moved as * const _
                as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( asn_per_data_s ) , "::"
                , stringify ! ( moved ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const asn_per_data_s ) ) . refill as * const _
                as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( asn_per_data_s ) , "::"
                , stringify ! ( refill ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const asn_per_data_s ) ) . refill_key as *
                const _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( asn_per_data_s ) , "::"
                , stringify ! ( refill_key ) ));
}
impl Clone for asn_per_data_s {
    fn clone(&self) -> Self { *self }
}
pub type asn_per_data_t = asn_per_data_s;
extern "C" {
    pub fn per_get_few_bits(per_data: *mut asn_per_data_t,
                            get_nbits: ::std::os::raw::c_int) -> i32;
}
extern "C" {
    pub fn per_get_undo(per_data: *mut asn_per_data_t,
                        get_nbits: ::std::os::raw::c_int);
}
extern "C" {
    pub fn per_get_many_bits(pd: *mut asn_per_data_t, dst: *mut u8,
                             right_align: ::std::os::raw::c_int,
                             get_nbits: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn uper_get_length(pd: *mut asn_per_data_t,
                           effective_bound_bits: ::std::os::raw::c_int,
                           repeat: *mut ::std::os::raw::c_int) -> isize;
}
extern "C" {
    pub fn uper_get_nslength(pd: *mut asn_per_data_t) -> isize;
}
extern "C" {
    pub fn uper_get_nsnnwn(pd: *mut asn_per_data_t) -> isize;
}
extern "C" {
    pub fn per_data_string(pd: *mut asn_per_data_t)
     -> *mut ::std::os::raw::c_char;
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct asn_per_outp_s {
    pub buffer: *mut u8,
    pub nboff: usize,
    pub nbits: usize,
    pub tmpspace: [u8; 32usize],
    pub outper: ::std::option::Option<unsafe extern "C" fn(data:
                                                               *const ::std::os::raw::c_void,
                                                           size: usize,
                                                           op_key:
                                                               *mut ::std::os::raw::c_void)
                                          -> ::std::os::raw::c_int>,
    pub op_key: *mut ::std::os::raw::c_void,
    pub flushed_bytes: usize,
}
#[test]
fn bindgen_test_layout_asn_per_outp_s() {
    assert_eq!(::std::mem::size_of::<asn_per_outp_s>() , 80usize , concat ! (
               "Size of: " , stringify ! ( asn_per_outp_s ) ));
    assert_eq! (::std::mem::align_of::<asn_per_outp_s>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( asn_per_outp_s ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const asn_per_outp_s ) ) . buffer as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( asn_per_outp_s ) , "::"
                , stringify ! ( buffer ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const asn_per_outp_s ) ) . nboff as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( asn_per_outp_s ) , "::"
                , stringify ! ( nboff ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const asn_per_outp_s ) ) . nbits as * const _
                as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( asn_per_outp_s ) , "::"
                , stringify ! ( nbits ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const asn_per_outp_s ) ) . tmpspace as * const
                _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( asn_per_outp_s ) , "::"
                , stringify ! ( tmpspace ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const asn_per_outp_s ) ) . outper as * const _
                as usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( asn_per_outp_s ) , "::"
                , stringify ! ( outper ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const asn_per_outp_s ) ) . op_key as * const _
                as usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( asn_per_outp_s ) , "::"
                , stringify ! ( op_key ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const asn_per_outp_s ) ) . flushed_bytes as *
                const _ as usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( asn_per_outp_s ) , "::"
                , stringify ! ( flushed_bytes ) ));
}
impl Clone for asn_per_outp_s {
    fn clone(&self) -> Self { *self }
}
pub type asn_per_outp_t = asn_per_outp_s;
extern "C" {
    pub fn per_put_few_bits(per_data: *mut asn_per_outp_t, bits: u32,
                            obits: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn per_put_many_bits(po: *mut asn_per_outp_t, src: *const u8,
                             put_nbits: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn uper_put_length(po: *mut asn_per_outp_t, whole_length: usize)
     -> isize;
}
extern "C" {
    pub fn uper_put_nslength(po: *mut asn_per_outp_t, length: usize)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn uper_put_nsnnwn(po: *mut asn_per_outp_t, n: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn uper_decode_complete(opt_codec_ctx: *mut asn_codec_ctx_s,
                                type_descriptor: *mut asn_TYPE_descriptor_s,
                                struct_ptr: *mut *mut ::std::os::raw::c_void,
                                buffer: *const ::std::os::raw::c_void,
                                size: usize) -> asn_dec_rval_t;
}
extern "C" {
    pub fn uper_decode(opt_codec_ctx: *mut asn_codec_ctx_s,
                       type_descriptor: *mut asn_TYPE_descriptor_s,
                       struct_ptr: *mut *mut ::std::os::raw::c_void,
                       buffer: *const ::std::os::raw::c_void, size: usize,
                       skip_bits: ::std::os::raw::c_int,
                       unused_bits: ::std::os::raw::c_int) -> asn_dec_rval_t;
}
pub type per_type_decoder_f =
    ::std::option::Option<unsafe extern "C" fn(opt_codec_ctx:
                                                   *mut asn_codec_ctx_t,
                                               type_descriptor:
                                                   *mut asn_TYPE_descriptor_s,
                                               constraints:
                                                   *mut asn_per_constraints_t,
                                               struct_ptr:
                                                   *mut *mut ::std::os::raw::c_void,
                                               per_data: *mut asn_per_data_t)
                              -> asn_dec_rval_t>;
extern "C" {
    pub fn uper_encode(type_descriptor: *mut asn_TYPE_descriptor_s,
                       struct_ptr: *mut ::std::os::raw::c_void,
                       consume_bytes_cb: asn_app_consume_bytes_f,
                       app_key: *mut ::std::os::raw::c_void)
     -> asn_enc_rval_t;
}
extern "C" {
    pub fn uper_encode_to_buffer(type_descriptor: *mut asn_TYPE_descriptor_s,
                                 struct_ptr: *mut ::std::os::raw::c_void,
                                 buffer: *mut ::std::os::raw::c_void,
                                 buffer_size: usize) -> asn_enc_rval_t;
}
extern "C" {
    pub fn uper_encode_to_new_buffer(type_descriptor:
                                         *mut asn_TYPE_descriptor_s,
                                     constraints: *mut asn_per_constraints_t,
                                     struct_ptr: *mut ::std::os::raw::c_void,
                                     buffer_r:
                                         *mut *mut ::std::os::raw::c_void)
     -> isize;
}
pub type per_type_encoder_f =
    ::std::option::Option<unsafe extern "C" fn(type_descriptor:
                                                   *mut asn_TYPE_descriptor_s,
                                               constraints:
                                                   *mut asn_per_constraints_t,
                                               struct_ptr:
                                                   *mut ::std::os::raw::c_void,
                                               per_output:
                                                   *mut asn_per_outp_t)
                              -> asn_enc_rval_t>;
extern "C" {
    pub fn asn_check_constraints(type_descriptor: *mut asn_TYPE_descriptor_s,
                                 struct_ptr: *const ::std::os::raw::c_void,
                                 errbuf: *mut ::std::os::raw::c_char,
                                 errlen: *mut usize) -> ::std::os::raw::c_int;
}
pub type asn_constr_check_f =
    ::std::option::Option<unsafe extern "C" fn(type_descriptor:
                                                   *mut asn_TYPE_descriptor_s,
                                               struct_ptr:
                                                   *const ::std::os::raw::c_void,
                                               optional_callback:
                                                   asn_app_constraint_failed_f,
                                               optional_app_key:
                                                   *mut ::std::os::raw::c_void)
                              -> ::std::os::raw::c_int>;
extern "C" {
    pub fn asn_generic_no_constraint(type_descriptor:
                                         *mut asn_TYPE_descriptor_s,
                                     struct_ptr:
                                         *const ::std::os::raw::c_void,
                                     optional_callback:
                                         asn_app_constraint_failed_f,
                                     optional_app_key:
                                         *mut ::std::os::raw::c_void)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn asn_generic_unknown_constraint(type_descriptor:
                                              *mut asn_TYPE_descriptor_s,
                                          struct_ptr:
                                              *const ::std::os::raw::c_void,
                                          optional_callback:
                                              asn_app_constraint_failed_f,
                                          optional_app_key:
                                              *mut ::std::os::raw::c_void)
     -> ::std::os::raw::c_int;
}
pub type asn_struct_free_f =
    ::std::option::Option<unsafe extern "C" fn(type_descriptor:
                                                   *mut asn_TYPE_descriptor_s,
                                               struct_ptr:
                                                   *mut ::std::os::raw::c_void,
                                               free_contents_only:
                                                   ::std::os::raw::c_int)>;
pub type asn_struct_print_f =
    ::std::option::Option<unsafe extern "C" fn(type_descriptor:
                                                   *mut asn_TYPE_descriptor_s,
                                               struct_ptr:
                                                   *const ::std::os::raw::c_void,
                                               level: ::std::os::raw::c_int,
                                               callback:
                                                   asn_app_consume_bytes_f,
                                               app_key:
                                                   *mut ::std::os::raw::c_void)
                              -> ::std::os::raw::c_int>;
pub type asn_outmost_tag_f =
    ::std::option::Option<unsafe extern "C" fn(type_descriptor:
                                                   *mut asn_TYPE_descriptor_s,
                                               struct_ptr:
                                                   *const ::std::os::raw::c_void,
                                               tag_mode:
                                                   ::std::os::raw::c_int,
                                               tag: ber_tlv_tag_t)
                              -> ber_tlv_tag_t>;
extern "C" {
    pub fn asn_TYPE_outmost_tag(type_descriptor: *mut asn_TYPE_descriptor_s,
                                struct_ptr: *const ::std::os::raw::c_void,
                                tag_mode: ::std::os::raw::c_int,
                                tag: ber_tlv_tag_t) -> ber_tlv_tag_t;
}
pub type asn_TYPE_descriptor_t = asn_TYPE_descriptor_s;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum asn_TYPE_flags_e {
    ATF_NOFLAGS = 0,
    ATF_POINTER = 1,
    ATF_OPEN_TYPE = 2,
}
pub type asn_TYPE_member_t = asn_TYPE_member_s;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct asn_TYPE_tag2member_s {
    pub el_tag: ber_tlv_tag_t,
    pub el_no: ::std::os::raw::c_int,
    pub toff_first: ::std::os::raw::c_int,
    pub toff_last: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_asn_TYPE_tag2member_s() {
    assert_eq!(::std::mem::size_of::<asn_TYPE_tag2member_s>() , 16usize ,
               concat ! ( "Size of: " , stringify ! ( asn_TYPE_tag2member_s )
               ));
    assert_eq! (::std::mem::align_of::<asn_TYPE_tag2member_s>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( asn_TYPE_tag2member_s ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const asn_TYPE_tag2member_s ) ) . el_tag as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( asn_TYPE_tag2member_s )
                , "::" , stringify ! ( el_tag ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const asn_TYPE_tag2member_s ) ) . el_no as *
                const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( asn_TYPE_tag2member_s )
                , "::" , stringify ! ( el_no ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const asn_TYPE_tag2member_s ) ) . toff_first as
                * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( asn_TYPE_tag2member_s )
                , "::" , stringify ! ( toff_first ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const asn_TYPE_tag2member_s ) ) . toff_last as
                * const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( asn_TYPE_tag2member_s )
                , "::" , stringify ! ( toff_last ) ));
}
impl Clone for asn_TYPE_tag2member_s {
    fn clone(&self) -> Self { *self }
}
pub type asn_TYPE_tag2member_t = asn_TYPE_tag2member_s;
extern "C" {
    pub fn asn_fprint(stream: *mut FILE, td: *mut asn_TYPE_descriptor_t,
                      struct_ptr: *const ::std::os::raw::c_void)
     -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct ASN__PRIMITIVE_TYPE_s {
    pub buf: *mut u8,
    pub size: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_ASN__PRIMITIVE_TYPE_s() {
    assert_eq!(::std::mem::size_of::<ASN__PRIMITIVE_TYPE_s>() , 16usize ,
               concat ! ( "Size of: " , stringify ! ( ASN__PRIMITIVE_TYPE_s )
               ));
    assert_eq! (::std::mem::align_of::<ASN__PRIMITIVE_TYPE_s>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( ASN__PRIMITIVE_TYPE_s ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ASN__PRIMITIVE_TYPE_s ) ) . buf as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ASN__PRIMITIVE_TYPE_s )
                , "::" , stringify ! ( buf ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ASN__PRIMITIVE_TYPE_s ) ) . size as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( ASN__PRIMITIVE_TYPE_s )
                , "::" , stringify ! ( size ) ));
}
impl Clone for ASN__PRIMITIVE_TYPE_s {
    fn clone(&self) -> Self { *self }
}
pub type ASN__PRIMITIVE_TYPE_t = ASN__PRIMITIVE_TYPE_s;
extern "C" {
    pub fn ASN__PRIMITIVE_TYPE_free(type_descriptor:
                                        *mut asn_TYPE_descriptor_s,
                                    struct_ptr: *mut ::std::os::raw::c_void,
                                    free_contents_only:
                                        ::std::os::raw::c_int);
}
extern "C" {
    pub fn ber_decode_primitive(opt_codec_ctx: *mut asn_codec_ctx_s,
                                type_descriptor: *mut asn_TYPE_descriptor_s,
                                struct_ptr: *mut *mut ::std::os::raw::c_void,
                                buf_ptr: *const ::std::os::raw::c_void,
                                size: usize, tag_mode: ::std::os::raw::c_int)
     -> asn_dec_rval_t;
}
extern "C" {
    pub fn der_encode_primitive(type_descriptor: *mut asn_TYPE_descriptor_s,
                                struct_ptr: *mut ::std::os::raw::c_void,
                                tag_mode: ::std::os::raw::c_int,
                                tag: ber_tlv_tag_t,
                                consume_bytes_cb: asn_app_consume_bytes_f,
                                app_key: *mut ::std::os::raw::c_void)
     -> asn_enc_rval_t;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum xer_pbd_rval {
    XPBD_SYSTEM_FAILURE = 0,
    XPBD_DECODER_LIMIT = 1,
    XPBD_BROKEN_ENCODING = 2,
    XPBD_NOT_BODY_IGNORE = 3,
    XPBD_BODY_CONSUMED = 4,
}
pub type xer_primitive_body_decoder_f =
    ::std::option::Option<unsafe extern "C" fn(td: *mut asn_TYPE_descriptor_t,
                                               struct_ptr:
                                                   *mut ::std::os::raw::c_void,
                                               chunk_buf:
                                                   *const ::std::os::raw::c_void,
                                               chunk_size: usize)
                              -> xer_pbd_rval>;
extern "C" {
    pub fn xer_decode_primitive(opt_codec_ctx: *mut asn_codec_ctx_t,
                                type_descriptor: *mut asn_TYPE_descriptor_t,
                                struct_ptr: *mut *mut ::std::os::raw::c_void,
                                struct_size: usize,
                                opt_mname: *const ::std::os::raw::c_char,
                                buf_ptr: *const ::std::os::raw::c_void,
                                size: usize,
                                prim_body_decoder:
                                    xer_primitive_body_decoder_f)
     -> asn_dec_rval_t;
}
pub type INTEGER_t = ASN__PRIMITIVE_TYPE_t;
extern "C" {
    #[link_name = "asn_DEF_INTEGER"]
    pub static mut asn_DEF_INTEGER: asn_TYPE_descriptor_t;
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct asn_INTEGER_enum_map_s {
    pub nat_value: ::std::os::raw::c_long,
    pub enum_len: usize,
    pub enum_name: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_asn_INTEGER_enum_map_s() {
    assert_eq!(::std::mem::size_of::<asn_INTEGER_enum_map_s>() , 24usize ,
               concat ! ( "Size of: " , stringify ! ( asn_INTEGER_enum_map_s )
               ));
    assert_eq! (::std::mem::align_of::<asn_INTEGER_enum_map_s>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( asn_INTEGER_enum_map_s ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const asn_INTEGER_enum_map_s ) ) . nat_value as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( asn_INTEGER_enum_map_s
                ) , "::" , stringify ! ( nat_value ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const asn_INTEGER_enum_map_s ) ) . enum_len as
                * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( asn_INTEGER_enum_map_s
                ) , "::" , stringify ! ( enum_len ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const asn_INTEGER_enum_map_s ) ) . enum_name as
                * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( asn_INTEGER_enum_map_s
                ) , "::" , stringify ! ( enum_name ) ));
}
impl Clone for asn_INTEGER_enum_map_s {
    fn clone(&self) -> Self { *self }
}
pub type asn_INTEGER_enum_map_t = asn_INTEGER_enum_map_s;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct asn_INTEGER_specifics_s {
    pub value2enum: *mut asn_INTEGER_enum_map_t,
    pub enum2value: *mut ::std::os::raw::c_uint,
    pub map_count: ::std::os::raw::c_int,
    pub extension: ::std::os::raw::c_int,
    pub strict_enumeration: ::std::os::raw::c_int,
    pub field_width: ::std::os::raw::c_int,
    pub field_unsigned: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_asn_INTEGER_specifics_s() {
    assert_eq!(::std::mem::size_of::<asn_INTEGER_specifics_s>() , 40usize ,
               concat ! (
               "Size of: " , stringify ! ( asn_INTEGER_specifics_s ) ));
    assert_eq! (::std::mem::align_of::<asn_INTEGER_specifics_s>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( asn_INTEGER_specifics_s ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const asn_INTEGER_specifics_s ) ) . value2enum
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( asn_INTEGER_specifics_s
                ) , "::" , stringify ! ( value2enum ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const asn_INTEGER_specifics_s ) ) . enum2value
                as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( asn_INTEGER_specifics_s
                ) , "::" , stringify ! ( enum2value ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const asn_INTEGER_specifics_s ) ) . map_count
                as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( asn_INTEGER_specifics_s
                ) , "::" , stringify ! ( map_count ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const asn_INTEGER_specifics_s ) ) . extension
                as * const _ as usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! ( asn_INTEGER_specifics_s
                ) , "::" , stringify ! ( extension ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const asn_INTEGER_specifics_s ) ) .
                strict_enumeration as * const _ as usize } , 24usize , concat
                ! (
                "Alignment of field: " , stringify ! ( asn_INTEGER_specifics_s
                ) , "::" , stringify ! ( strict_enumeration ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const asn_INTEGER_specifics_s ) ) . field_width
                as * const _ as usize } , 28usize , concat ! (
                "Alignment of field: " , stringify ! ( asn_INTEGER_specifics_s
                ) , "::" , stringify ! ( field_width ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const asn_INTEGER_specifics_s ) ) .
                field_unsigned as * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( asn_INTEGER_specifics_s
                ) , "::" , stringify ! ( field_unsigned ) ));
}
impl Clone for asn_INTEGER_specifics_s {
    fn clone(&self) -> Self { *self }
}
pub type asn_INTEGER_specifics_t = asn_INTEGER_specifics_s;
extern "C" {
    pub fn INTEGER_print(type_descriptor: *mut asn_TYPE_descriptor_s,
                         struct_ptr: *const ::std::os::raw::c_void,
                         level: ::std::os::raw::c_int,
                         callback: asn_app_consume_bytes_f,
                         app_key: *mut ::std::os::raw::c_void)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn INTEGER_decode_ber(opt_codec_ctx: *mut asn_codec_ctx_s,
                              type_descriptor: *mut asn_TYPE_descriptor_s,
                              struct_ptr: *mut *mut ::std::os::raw::c_void,
                              buf_ptr: *const ::std::os::raw::c_void,
                              size: usize, tag_mode: ::std::os::raw::c_int)
     -> asn_dec_rval_t;
}
extern "C" {
    pub fn INTEGER_encode_der(type_descriptor: *mut asn_TYPE_descriptor_s,
                              struct_ptr: *mut ::std::os::raw::c_void,
                              tag_mode: ::std::os::raw::c_int,
                              tag: ber_tlv_tag_t,
                              consume_bytes_cb: asn_app_consume_bytes_f,
                              app_key: *mut ::std::os::raw::c_void)
     -> asn_enc_rval_t;
}
extern "C" {
    pub fn INTEGER_decode_xer(opt_codec_ctx: *mut asn_codec_ctx_t,
                              type_descriptor: *mut asn_TYPE_descriptor_s,
                              struct_ptr: *mut *mut ::std::os::raw::c_void,
                              opt_mname: *const ::std::os::raw::c_char,
                              buf_ptr: *const ::std::os::raw::c_void,
                              size: usize) -> asn_dec_rval_t;
}
extern "C" {
    pub fn INTEGER_encode_xer(type_descriptor: *mut asn_TYPE_descriptor_s,
                              struct_ptr: *mut ::std::os::raw::c_void,
                              ilevel: ::std::os::raw::c_int,
                              xer_flags: xer_encoder_flags_e,
                              consume_bytes_cb: asn_app_consume_bytes_f,
                              app_key: *mut ::std::os::raw::c_void)
     -> asn_enc_rval_t;
}
extern "C" {
    pub fn INTEGER_decode_uper(opt_codec_ctx: *mut asn_codec_ctx_t,
                               type_descriptor: *mut asn_TYPE_descriptor_s,
                               constraints: *mut asn_per_constraints_t,
                               struct_ptr: *mut *mut ::std::os::raw::c_void,
                               per_data: *mut asn_per_data_t)
     -> asn_dec_rval_t;
}
extern "C" {
    pub fn INTEGER_encode_uper(type_descriptor: *mut asn_TYPE_descriptor_s,
                               constraints: *mut asn_per_constraints_t,
                               struct_ptr: *mut ::std::os::raw::c_void,
                               per_output: *mut asn_per_outp_t)
     -> asn_enc_rval_t;
}
extern "C" {
    pub fn asn_INTEGER2long(i: *const INTEGER_t,
                            l: *mut ::std::os::raw::c_long)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn asn_INTEGER2ulong(i: *const INTEGER_t,
                             l: *mut ::std::os::raw::c_ulong)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn asn_long2INTEGER(i: *mut INTEGER_t, l: ::std::os::raw::c_long)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn asn_ulong2INTEGER(i: *mut INTEGER_t, l: ::std::os::raw::c_ulong)
     -> ::std::os::raw::c_int;
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum asn_strtol_result_e {
    ASN_STRTOL_ERROR_RANGE = -3,
    ASN_STRTOL_ERROR_INVAL = -2,
    ASN_STRTOL_EXPECT_MORE = -1,
    ASN_STRTOL_OK = 0,
    ASN_STRTOL_EXTRA_DATA = 1,
}
extern "C" {
    pub fn asn_strtol_lim(str: *const ::std::os::raw::c_char,
                          end: *mut *const ::std::os::raw::c_char,
                          l: *mut ::std::os::raw::c_long)
     -> asn_strtol_result_e;
}
extern "C" {
    pub fn asn_strtol(str: *const ::std::os::raw::c_char,
                      end: *const ::std::os::raw::c_char,
                      l: *mut ::std::os::raw::c_long) -> asn_strtol_result_e;
}
extern "C" {
    pub fn INTEGER_map_value2enum(specs: *mut asn_INTEGER_specifics_t,
                                  value: ::std::os::raw::c_long)
     -> *const asn_INTEGER_enum_map_t;
}
extern "C" {
    #[link_name = "asn_DEF_NativeInteger"]
    pub static mut asn_DEF_NativeInteger: asn_TYPE_descriptor_t;
}
extern "C" {
    pub fn NativeInteger_free(type_descriptor: *mut asn_TYPE_descriptor_s,
                              struct_ptr: *mut ::std::os::raw::c_void,
                              free_contents_only: ::std::os::raw::c_int);
}
extern "C" {
    pub fn NativeInteger_print(type_descriptor: *mut asn_TYPE_descriptor_s,
                               struct_ptr: *const ::std::os::raw::c_void,
                               level: ::std::os::raw::c_int,
                               callback: asn_app_consume_bytes_f,
                               app_key: *mut ::std::os::raw::c_void)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn NativeInteger_decode_ber(opt_codec_ctx: *mut asn_codec_ctx_s,
                                    type_descriptor:
                                        *mut asn_TYPE_descriptor_s,
                                    struct_ptr:
                                        *mut *mut ::std::os::raw::c_void,
                                    buf_ptr: *const ::std::os::raw::c_void,
                                    size: usize,
                                    tag_mode: ::std::os::raw::c_int)
     -> asn_dec_rval_t;
}
extern "C" {
    pub fn NativeInteger_encode_der(type_descriptor:
                                        *mut asn_TYPE_descriptor_s,
                                    struct_ptr: *mut ::std::os::raw::c_void,
                                    tag_mode: ::std::os::raw::c_int,
                                    tag: ber_tlv_tag_t,
                                    consume_bytes_cb: asn_app_consume_bytes_f,
                                    app_key: *mut ::std::os::raw::c_void)
     -> asn_enc_rval_t;
}
extern "C" {
    pub fn NativeInteger_decode_xer(opt_codec_ctx: *mut asn_codec_ctx_t,
                                    type_descriptor:
                                        *mut asn_TYPE_descriptor_s,
                                    struct_ptr:
                                        *mut *mut ::std::os::raw::c_void,
                                    opt_mname: *const ::std::os::raw::c_char,
                                    buf_ptr: *const ::std::os::raw::c_void,
                                    size: usize) -> asn_dec_rval_t;
}
extern "C" {
    pub fn NativeInteger_encode_xer(type_descriptor:
                                        *mut asn_TYPE_descriptor_s,
                                    struct_ptr: *mut ::std::os::raw::c_void,
                                    ilevel: ::std::os::raw::c_int,
                                    xer_flags: xer_encoder_flags_e,
                                    consume_bytes_cb: asn_app_consume_bytes_f,
                                    app_key: *mut ::std::os::raw::c_void)
     -> asn_enc_rval_t;
}
extern "C" {
    pub fn NativeInteger_decode_uper(opt_codec_ctx: *mut asn_codec_ctx_t,
                                     type_descriptor:
                                         *mut asn_TYPE_descriptor_s,
                                     constraints: *mut asn_per_constraints_t,
                                     struct_ptr:
                                         *mut *mut ::std::os::raw::c_void,
                                     per_data: *mut asn_per_data_t)
     -> asn_dec_rval_t;
}
extern "C" {
    pub fn NativeInteger_encode_uper(type_descriptor:
                                         *mut asn_TYPE_descriptor_s,
                                     constraints: *mut asn_per_constraints_t,
                                     struct_ptr: *mut ::std::os::raw::c_void,
                                     per_output: *mut asn_per_outp_t)
     -> asn_enc_rval_t;
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct asn_SEQUENCE_specifics_s {
    pub struct_size: ::std::os::raw::c_int,
    pub ctx_offset: ::std::os::raw::c_int,
    pub tag2el: *mut asn_TYPE_tag2member_t,
    pub tag2el_count: ::std::os::raw::c_int,
    pub oms: *mut ::std::os::raw::c_int,
    pub roms_count: ::std::os::raw::c_int,
    pub aoms_count: ::std::os::raw::c_int,
    pub ext_after: ::std::os::raw::c_int,
    pub ext_before: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_asn_SEQUENCE_specifics_s() {
    assert_eq!(::std::mem::size_of::<asn_SEQUENCE_specifics_s>() , 48usize ,
               concat ! (
               "Size of: " , stringify ! ( asn_SEQUENCE_specifics_s ) ));
    assert_eq! (::std::mem::align_of::<asn_SEQUENCE_specifics_s>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( asn_SEQUENCE_specifics_s ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const asn_SEQUENCE_specifics_s ) ) .
                struct_size as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                asn_SEQUENCE_specifics_s ) , "::" , stringify ! ( struct_size
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const asn_SEQUENCE_specifics_s ) ) . ctx_offset
                as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                asn_SEQUENCE_specifics_s ) , "::" , stringify ! ( ctx_offset )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const asn_SEQUENCE_specifics_s ) ) . tag2el as
                * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                asn_SEQUENCE_specifics_s ) , "::" , stringify ! ( tag2el ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const asn_SEQUENCE_specifics_s ) ) .
                tag2el_count as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! (
                asn_SEQUENCE_specifics_s ) , "::" , stringify ! ( tag2el_count
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const asn_SEQUENCE_specifics_s ) ) . oms as *
                const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! (
                asn_SEQUENCE_specifics_s ) , "::" , stringify ! ( oms ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const asn_SEQUENCE_specifics_s ) ) . roms_count
                as * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! (
                asn_SEQUENCE_specifics_s ) , "::" , stringify ! ( roms_count )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const asn_SEQUENCE_specifics_s ) ) . aoms_count
                as * const _ as usize } , 36usize , concat ! (
                "Alignment of field: " , stringify ! (
                asn_SEQUENCE_specifics_s ) , "::" , stringify ! ( aoms_count )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const asn_SEQUENCE_specifics_s ) ) . ext_after
                as * const _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! (
                asn_SEQUENCE_specifics_s ) , "::" , stringify ! ( ext_after )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const asn_SEQUENCE_specifics_s ) ) . ext_before
                as * const _ as usize } , 44usize , concat ! (
                "Alignment of field: " , stringify ! (
                asn_SEQUENCE_specifics_s ) , "::" , stringify ! ( ext_before )
                ));
}
impl Clone for asn_SEQUENCE_specifics_s {
    fn clone(&self) -> Self { *self }
}
pub type asn_SEQUENCE_specifics_t = asn_SEQUENCE_specifics_s;
extern "C" {
    pub fn SEQUENCE_free(type_descriptor: *mut asn_TYPE_descriptor_s,
                         struct_ptr: *mut ::std::os::raw::c_void,
                         free_contents_only: ::std::os::raw::c_int);
}
extern "C" {
    pub fn SEQUENCE_print(type_descriptor: *mut asn_TYPE_descriptor_s,
                          struct_ptr: *const ::std::os::raw::c_void,
                          level: ::std::os::raw::c_int,
                          callback: asn_app_consume_bytes_f,
                          app_key: *mut ::std::os::raw::c_void)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SEQUENCE_constraint(type_descriptor: *mut asn_TYPE_descriptor_s,
                               struct_ptr: *const ::std::os::raw::c_void,
                               optional_callback: asn_app_constraint_failed_f,
                               optional_app_key: *mut ::std::os::raw::c_void)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SEQUENCE_decode_ber(opt_codec_ctx: *mut asn_codec_ctx_s,
                               type_descriptor: *mut asn_TYPE_descriptor_s,
                               struct_ptr: *mut *mut ::std::os::raw::c_void,
                               buf_ptr: *const ::std::os::raw::c_void,
                               size: usize, tag_mode: ::std::os::raw::c_int)
     -> asn_dec_rval_t;
}
extern "C" {
    pub fn SEQUENCE_encode_der(type_descriptor: *mut asn_TYPE_descriptor_s,
                               struct_ptr: *mut ::std::os::raw::c_void,
                               tag_mode: ::std::os::raw::c_int,
                               tag: ber_tlv_tag_t,
                               consume_bytes_cb: asn_app_consume_bytes_f,
                               app_key: *mut ::std::os::raw::c_void)
     -> asn_enc_rval_t;
}
extern "C" {
    pub fn SEQUENCE_decode_xer(opt_codec_ctx: *mut asn_codec_ctx_t,
                               type_descriptor: *mut asn_TYPE_descriptor_s,
                               struct_ptr: *mut *mut ::std::os::raw::c_void,
                               opt_mname: *const ::std::os::raw::c_char,
                               buf_ptr: *const ::std::os::raw::c_void,
                               size: usize) -> asn_dec_rval_t;
}
extern "C" {
    pub fn SEQUENCE_encode_xer(type_descriptor: *mut asn_TYPE_descriptor_s,
                               struct_ptr: *mut ::std::os::raw::c_void,
                               ilevel: ::std::os::raw::c_int,
                               xer_flags: xer_encoder_flags_e,
                               consume_bytes_cb: asn_app_consume_bytes_f,
                               app_key: *mut ::std::os::raw::c_void)
     -> asn_enc_rval_t;
}
extern "C" {
    pub fn SEQUENCE_decode_uper(opt_codec_ctx: *mut asn_codec_ctx_t,
                                type_descriptor: *mut asn_TYPE_descriptor_s,
                                constraints: *mut asn_per_constraints_t,
                                struct_ptr: *mut *mut ::std::os::raw::c_void,
                                per_data: *mut asn_per_data_t)
     -> asn_dec_rval_t;
}
extern "C" {
    pub fn SEQUENCE_encode_uper(type_descriptor: *mut asn_TYPE_descriptor_s,
                                constraints: *mut asn_per_constraints_t,
                                struct_ptr: *mut ::std::os::raw::c_void,
                                per_output: *mut asn_per_outp_t)
     -> asn_enc_rval_t;
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct PositionOffset {
    pub position_north: ::std::os::raw::c_long,
    pub position_east: ::std::os::raw::c_long,
    pub std_dev_position_north: *mut ::std::os::raw::c_long,
    pub std_dev_position_east: *mut ::std::os::raw::c_long,
    pub _asn_ctx: asn_struct_ctx_t,
}
#[test]
fn bindgen_test_layout_PositionOffset() {
    assert_eq!(::std::mem::size_of::<PositionOffset>() , 56usize , concat ! (
               "Size of: " , stringify ! ( PositionOffset ) ));
    assert_eq! (::std::mem::align_of::<PositionOffset>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( PositionOffset ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const PositionOffset ) ) . position_north as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( PositionOffset ) , "::"
                , stringify ! ( position_north ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const PositionOffset ) ) . position_east as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( PositionOffset ) , "::"
                , stringify ! ( position_east ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const PositionOffset ) ) .
                std_dev_position_north as * const _ as usize } , 16usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( PositionOffset ) , "::"
                , stringify ! ( std_dev_position_north ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const PositionOffset ) ) .
                std_dev_position_east as * const _ as usize } , 24usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( PositionOffset ) , "::"
                , stringify ! ( std_dev_position_east ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const PositionOffset ) ) . _asn_ctx as * const
                _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( PositionOffset ) , "::"
                , stringify ! ( _asn_ctx ) ));
}
impl Clone for PositionOffset {
    fn clone(&self) -> Self { *self }
}
pub type PositionOffset_t = PositionOffset;
extern "C" {
    #[link_name = "asn_DEF_PositionOffset"]
    pub static mut asn_DEF_PositionOffset: asn_TYPE_descriptor_t;
}
extern "C" {
    pub fn __assert_fail(__assertion: *const ::std::os::raw::c_char,
                         __file: *const ::std::os::raw::c_char,
                         __line: ::std::os::raw::c_uint,
                         __function: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn __assert_perror_fail(__errnum: ::std::os::raw::c_int,
                                __file: *const ::std::os::raw::c_char,
                                __line: ::std::os::raw::c_uint,
                                __function: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn __assert(__assertion: *const ::std::os::raw::c_char,
                    __file: *const ::std::os::raw::c_char,
                    __line: ::std::os::raw::c_int);
}
extern "C" {
    pub fn get_asn1c_environment_version() -> ::std::os::raw::c_int;
}
pub type __builtin_va_list = [__va_list_tag; 1usize];
#[repr(C)]
#[derive(Debug, Copy)]
pub struct __va_list_tag {
    pub gp_offset: ::std::os::raw::c_uint,
    pub fp_offset: ::std::os::raw::c_uint,
    pub overflow_arg_area: *mut ::std::os::raw::c_void,
    pub reg_save_area: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout___va_list_tag() {
    assert_eq!(::std::mem::size_of::<__va_list_tag>() , 24usize , concat ! (
               "Size of: " , stringify ! ( __va_list_tag ) ));
    assert_eq! (::std::mem::align_of::<__va_list_tag>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( __va_list_tag ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __va_list_tag ) ) . gp_offset as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( __va_list_tag ) , "::"
                , stringify ! ( gp_offset ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __va_list_tag ) ) . fp_offset as * const
                _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( __va_list_tag ) , "::"
                , stringify ! ( fp_offset ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __va_list_tag ) ) . overflow_arg_area as
                * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( __va_list_tag ) , "::"
                , stringify ! ( overflow_arg_area ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __va_list_tag ) ) . reg_save_area as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( __va_list_tag ) , "::"
                , stringify ! ( reg_save_area ) ));
}
impl Clone for __va_list_tag {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct __locale_data {
    pub _address: u8,
}
impl Clone for __locale_data {
    fn clone(&self) -> Self { *self }
}
