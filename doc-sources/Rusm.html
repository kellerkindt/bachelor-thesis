<!DOCTYPE html>
<html class="sidebar-visible light" lang="en"><head>
        <meta charset="UTF-8">
        <title>Test Organization - The Rust Programming Language</title>
        <meta content="text/html; charset=UTF-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="rgb(255, 255, 255)">

        <!-- base href="https://doc.rust-lang.org/book/second-edition/ch11-03-test-organization.html" -->

        <link rel="stylesheet" href="Rusm-Dateien/book.css">
        <link href="Rusm-Dateien/css.css" rel="stylesheet" type="text/css">
        <link href="Rusm-Dateien/css_002.css" rel="stylesheet" type="text/css">

        <link rel="shortcut icon" href="https://doc.rust-lang.org/book/second-edition/favicon.png">

        <!-- Font Awesome -->
        <link rel="stylesheet" href="Rusm-Dateien/font-awesome.css">

        <link rel="stylesheet" href="Rusm-Dateien/highlight.css">
        <link rel="stylesheet" href="Rusm-Dateien/tomorrow-night.css">
        <link rel="stylesheet" href="Rusm-Dateien/ayu-highlight.css">

        <!-- Custom theme -->
        

        

        <!-- Fetch Clipboard.js from CDN but have a local fallback -->
        <script src="Rusm-Dateien/clipboard_002.js"></script>
        <script>
            if (typeof Clipboard == 'undefined') {
                document.write(unescape("%3Cscript src='clipboard.min.js'%3E%3C/script%3E"));
            }
        </script><script src="Rusm-Dateien/clipboard.js"></script>

    </head>
    <body class="light">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { } 
            if (theme === null || theme === undefined) { theme = 'light'; }
            document.body.className = theme;
            document.querySelector('html').className = theme;
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            document.querySelector('html').classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents" aria-hidden="false">
            <ol class="chapter"><li class="affix"><a href="https://doc.rust-lang.org/book/second-edition/foreword.html" tabindex="0">Foreword</a></li><li class="affix"><a href="https://doc.rust-lang.org/book/second-edition/ch00-00-introduction.html" tabindex="0">Introduction</a></li><li><a href="https://doc.rust-lang.org/book/second-edition/ch01-00-getting-started.html" tabindex="0"><strong aria-hidden="true">1.</strong> Getting Started</a></li><li><ol class="section"><li><a href="https://doc.rust-lang.org/book/second-edition/ch01-01-installation.html" tabindex="0"><strong aria-hidden="true">1.1.</strong> Installation</a></li><li><a href="https://doc.rust-lang.org/book/second-edition/ch01-02-hello-world.html" tabindex="0"><strong aria-hidden="true">1.2.</strong> Hello, World!</a></li><li><a href="https://doc.rust-lang.org/book/second-edition/ch01-03-hello-cargo.html" tabindex="0"><strong aria-hidden="true">1.3.</strong> Hello, Cargo!</a></li></ol></li><li><a href="https://doc.rust-lang.org/book/second-edition/ch02-00-guessing-game-tutorial.html" tabindex="0"><strong aria-hidden="true">2.</strong> Programming a Guessing Game</a></li><li><a href="https://doc.rust-lang.org/book/second-edition/ch03-00-common-programming-concepts.html" tabindex="0"><strong aria-hidden="true">3.</strong> Common Programming Concepts</a></li><li><ol class="section"><li><a href="https://doc.rust-lang.org/book/second-edition/ch03-01-variables-and-mutability.html" tabindex="0"><strong aria-hidden="true">3.1.</strong> Variables and Mutability</a></li><li><a href="https://doc.rust-lang.org/book/second-edition/ch03-02-data-types.html" tabindex="0"><strong aria-hidden="true">3.2.</strong> Data Types</a></li><li><a href="https://doc.rust-lang.org/book/second-edition/ch03-03-how-functions-work.html" tabindex="0"><strong aria-hidden="true">3.3.</strong> How Functions Work</a></li><li><a href="https://doc.rust-lang.org/book/second-edition/ch03-04-comments.html" tabindex="0"><strong aria-hidden="true">3.4.</strong> Comments</a></li><li><a href="https://doc.rust-lang.org/book/second-edition/ch03-05-control-flow.html" tabindex="0"><strong aria-hidden="true">3.5.</strong> Control Flow</a></li></ol></li><li><a href="https://doc.rust-lang.org/book/second-edition/ch04-00-understanding-ownership.html" tabindex="0"><strong aria-hidden="true">4.</strong> Understanding Ownership</a></li><li><ol class="section"><li><a href="https://doc.rust-lang.org/book/second-edition/ch04-01-what-is-ownership.html" tabindex="0"><strong aria-hidden="true">4.1.</strong> What is Ownership?</a></li><li><a href="https://doc.rust-lang.org/book/second-edition/ch04-02-references-and-borrowing.html" tabindex="0"><strong aria-hidden="true">4.2.</strong> References &amp; Borrowing</a></li><li><a href="https://doc.rust-lang.org/book/second-edition/ch04-03-slices.html" tabindex="0"><strong aria-hidden="true">4.3.</strong> Slices</a></li></ol></li><li><a href="https://doc.rust-lang.org/book/second-edition/ch05-00-structs.html" tabindex="0"><strong aria-hidden="true">5.</strong> Using Structs to Structure Related Data</a></li><li><ol class="section"><li><a href="https://doc.rust-lang.org/book/second-edition/ch05-01-defining-structs.html" tabindex="0"><strong aria-hidden="true">5.1.</strong> Defining and Instantiating Structs</a></li><li><a href="https://doc.rust-lang.org/book/second-edition/ch05-02-example-structs.html" tabindex="0"><strong aria-hidden="true">5.2.</strong> An Example Program Using Structs</a></li><li><a href="https://doc.rust-lang.org/book/second-edition/ch05-03-method-syntax.html" tabindex="0"><strong aria-hidden="true">5.3.</strong> Method Syntax</a></li></ol></li><li><a href="https://doc.rust-lang.org/book/second-edition/ch06-00-enums.html" tabindex="0"><strong aria-hidden="true">6.</strong> Enums and Pattern Matching</a></li><li><ol class="section"><li><a href="https://doc.rust-lang.org/book/second-edition/ch06-01-defining-an-enum.html" tabindex="0"><strong aria-hidden="true">6.1.</strong> Defining an Enum</a></li><li><a href="https://doc.rust-lang.org/book/second-edition/ch06-02-match.html" tabindex="0"><strong aria-hidden="true">6.2.</strong> The match Control Flow Operator</a></li><li><a href="https://doc.rust-lang.org/book/second-edition/ch06-03-if-let.html" tabindex="0"><strong aria-hidden="true">6.3.</strong> Concise Control Flow with if let</a></li></ol></li><li><a href="https://doc.rust-lang.org/book/second-edition/ch07-00-modules.html" tabindex="0"><strong aria-hidden="true">7.</strong> Modules</a></li><li><ol class="section"><li><a href="https://doc.rust-lang.org/book/second-edition/ch07-01-mod-and-the-filesystem.html" tabindex="0"><strong aria-hidden="true">7.1.</strong> mod and the Filesystem</a></li><li><a href="https://doc.rust-lang.org/book/second-edition/ch07-02-controlling-visibility-with-pub.html" tabindex="0"><strong aria-hidden="true">7.2.</strong> Controlling Visibility with pub</a></li><li><a href="https://doc.rust-lang.org/book/second-edition/ch07-03-importing-names-with-use.html" tabindex="0"><strong aria-hidden="true">7.3.</strong> Referring to Names in Different Modules</a></li></ol></li><li><a href="https://doc.rust-lang.org/book/second-edition/ch08-00-common-collections.html" tabindex="0"><strong aria-hidden="true">8.</strong> Common Collections</a></li><li><ol class="section"><li><a href="https://doc.rust-lang.org/book/second-edition/ch08-01-vectors.html" tabindex="0"><strong aria-hidden="true">8.1.</strong> Vectors</a></li><li><a href="https://doc.rust-lang.org/book/second-edition/ch08-02-strings.html" tabindex="0"><strong aria-hidden="true">8.2.</strong> Strings</a></li><li><a href="https://doc.rust-lang.org/book/second-edition/ch08-03-hash-maps.html" tabindex="0"><strong aria-hidden="true">8.3.</strong> Hash Maps</a></li></ol></li><li><a href="https://doc.rust-lang.org/book/second-edition/ch09-00-error-handling.html" tabindex="0"><strong aria-hidden="true">9.</strong> Error Handling</a></li><li><ol class="section"><li><a href="https://doc.rust-lang.org/book/second-edition/ch09-01-unrecoverable-errors-with-panic.html" tabindex="0"><strong aria-hidden="true">9.1.</strong> Unrecoverable Errors with panic!</a></li><li><a href="https://doc.rust-lang.org/book/second-edition/ch09-02-recoverable-errors-with-result.html" tabindex="0"><strong aria-hidden="true">9.2.</strong> Recoverable Errors with Result</a></li><li><a href="https://doc.rust-lang.org/book/second-edition/ch09-03-to-panic-or-not-to-panic.html" tabindex="0"><strong aria-hidden="true">9.3.</strong> To panic! or Not To panic!</a></li></ol></li><li><a href="https://doc.rust-lang.org/book/second-edition/ch10-00-generics.html" tabindex="0"><strong aria-hidden="true">10.</strong> Generic Types, Traits, and Lifetimes</a></li><li><ol class="section"><li><a href="https://doc.rust-lang.org/book/second-edition/ch10-01-syntax.html" tabindex="0"><strong aria-hidden="true">10.1.</strong> Generic Data Types</a></li><li><a href="https://doc.rust-lang.org/book/second-edition/ch10-02-traits.html" tabindex="0"><strong aria-hidden="true">10.2.</strong> Traits: Defining Shared Behavior</a></li><li><a href="https://doc.rust-lang.org/book/second-edition/ch10-03-lifetime-syntax.html" tabindex="0"><strong aria-hidden="true">10.3.</strong> Validating References with Lifetimes</a></li></ol></li><li><a href="https://doc.rust-lang.org/book/second-edition/ch11-00-testing.html" tabindex="0"><strong aria-hidden="true">11.</strong> Testing</a></li><li><ol class="section"><li><a href="https://doc.rust-lang.org/book/second-edition/ch11-01-writing-tests.html" tabindex="0"><strong aria-hidden="true">11.1.</strong> Writing tests</a></li><li><a href="https://doc.rust-lang.org/book/second-edition/ch11-02-running-tests.html" tabindex="0"><strong aria-hidden="true">11.2.</strong> Running tests</a></li><li><a href="https://doc.rust-lang.org/book/second-edition/ch11-03-test-organization.html" class="active" tabindex="0"><strong aria-hidden="true">11.3.</strong> Test Organization</a></li></ol></li><li><a href="https://doc.rust-lang.org/book/second-edition/ch12-00-an-io-project.html" tabindex="0"><strong aria-hidden="true">12.</strong> An I/O Project: Building a Command Line Program</a></li><li><ol class="section"><li><a href="https://doc.rust-lang.org/book/second-edition/ch12-01-accepting-command-line-arguments.html" tabindex="0"><strong aria-hidden="true">12.1.</strong> Accepting Command Line Arguments</a></li><li><a href="https://doc.rust-lang.org/book/second-edition/ch12-02-reading-a-file.html" tabindex="0"><strong aria-hidden="true">12.2.</strong> Reading a File</a></li><li><a href="https://doc.rust-lang.org/book/second-edition/ch12-03-improving-error-handling-and-modularity.html" tabindex="0"><strong aria-hidden="true">12.3.</strong> Refactoring to Improve Modularity and Error Handling</a></li><li><a href="https://doc.rust-lang.org/book/second-edition/ch12-04-testing-the-librarys-functionality.html" tabindex="0"><strong aria-hidden="true">12.4.</strong> Developing the Library’s Functionality with Test Driven Development</a></li><li><a href="https://doc.rust-lang.org/book/second-edition/ch12-05-working-with-environment-variables.html" tabindex="0"><strong aria-hidden="true">12.5.</strong> Working with Environment Variables</a></li><li><a href="https://doc.rust-lang.org/book/second-edition/ch12-06-writing-to-stderr-instead-of-stdout.html" tabindex="0"><strong aria-hidden="true">12.6.</strong> Writing Error Messages to Standard Error Instead of Standard Output</a></li></ol></li><li><a href="https://doc.rust-lang.org/book/second-edition/ch13-00-functional-features.html" tabindex="0"><strong aria-hidden="true">13.</strong> Functional Language Features: Iterators and Closures</a></li><li><ol class="section"><li><a href="https://doc.rust-lang.org/book/second-edition/ch13-01-closures.html" tabindex="0"><strong aria-hidden="true">13.1.</strong> Closures: Anonymous Functions that Can Capture Their Environment</a></li><li><a href="https://doc.rust-lang.org/book/second-edition/ch13-02-iterators.html" tabindex="0"><strong aria-hidden="true">13.2.</strong> Processing a Series of Items with Iterators</a></li><li><a href="https://doc.rust-lang.org/book/second-edition/ch13-03-improving-our-io-project.html" tabindex="0"><strong aria-hidden="true">13.3.</strong> Improving Our I/O Project</a></li><li><a href="https://doc.rust-lang.org/book/second-edition/ch13-04-performance.html" tabindex="0"><strong aria-hidden="true">13.4.</strong> Comparing Performance: Loops vs. Iterators</a></li></ol></li><li><a href="https://doc.rust-lang.org/book/second-edition/ch14-00-more-about-cargo.html" tabindex="0"><strong aria-hidden="true">14.</strong> More about Cargo and Crates.io</a></li><li><ol class="section"><li><a href="https://doc.rust-lang.org/book/second-edition/ch14-01-release-profiles.html" tabindex="0"><strong aria-hidden="true">14.1.</strong> Customizing Builds with Release Profiles</a></li><li><a href="https://doc.rust-lang.org/book/second-edition/ch14-02-publishing-to-crates-io.html" tabindex="0"><strong aria-hidden="true">14.2.</strong> Publishing a Crate to Crates.io</a></li><li><a href="https://doc.rust-lang.org/book/second-edition/ch14-03-cargo-workspaces.html" tabindex="0"><strong aria-hidden="true">14.3.</strong> Cargo Workspaces</a></li><li><a href="https://doc.rust-lang.org/book/second-edition/ch14-04-installing-binaries.html" tabindex="0"><strong aria-hidden="true">14.4.</strong> Installing Binaries from Crates.io with cargo install</a></li><li><a href="https://doc.rust-lang.org/book/second-edition/ch14-05-extending-cargo.html" tabindex="0"><strong aria-hidden="true">14.5.</strong> Extending Cargo with Custom Commands</a></li></ol></li><li><a href="https://doc.rust-lang.org/book/second-edition/ch15-00-smart-pointers.html" tabindex="0"><strong aria-hidden="true">15.</strong> Smart Pointers</a></li><li><ol class="section"><li><a href="https://doc.rust-lang.org/book/second-edition/ch15-01-box.html" tabindex="0"><strong aria-hidden="true">15.1.</strong> Box<t> Points to Data on the Heap and Has a Known Size</t></a></li><li><a href="https://doc.rust-lang.org/book/second-edition/ch15-02-deref.html" tabindex="0"><strong aria-hidden="true">15.2.</strong> The Deref Trait Allows Access to the Data Through a Reference</a></li><li><a href="https://doc.rust-lang.org/book/second-edition/ch15-03-drop.html" tabindex="0"><strong aria-hidden="true">15.3.</strong> The Drop Trait Runs Code on Cleanup</a></li><li><a href="https://doc.rust-lang.org/book/second-edition/ch15-04-rc.html" tabindex="0"><strong aria-hidden="true">15.4.</strong> Rc<t>, the Reference Counted Smart Pointer</t></a></li><li><a href="https://doc.rust-lang.org/book/second-edition/ch15-05-interior-mutability.html" tabindex="0"><strong aria-hidden="true">15.5.</strong> RefCell<t> and the Interior Mutability Pattern</t></a></li><li><a href="https://doc.rust-lang.org/book/second-edition/ch15-06-reference-cycles.html" tabindex="0"><strong aria-hidden="true">15.6.</strong> Creating Reference Cycles and Leaking Memory is Safe</a></li></ol></li><li><a href="https://doc.rust-lang.org/book/second-edition/ch16-00-concurrency.html" tabindex="0"><strong aria-hidden="true">16.</strong> Fearless Concurrency</a></li><li><ol class="section"><li><a href="https://doc.rust-lang.org/book/second-edition/ch16-01-threads.html" tabindex="0"><strong aria-hidden="true">16.1.</strong> Threads</a></li><li><a href="https://doc.rust-lang.org/book/second-edition/ch16-02-message-passing.html" tabindex="0"><strong aria-hidden="true">16.2.</strong> Message Passing</a></li><li><a href="https://doc.rust-lang.org/book/second-edition/ch16-03-shared-state.html" tabindex="0"><strong aria-hidden="true">16.3.</strong> Shared State</a></li><li><a href="https://doc.rust-lang.org/book/second-edition/ch16-04-extensible-concurrency-sync-and-send.html" tabindex="0"><strong aria-hidden="true">16.4.</strong> Extensible Concurrency: Sync and Send</a></li></ol></li><li><a href="https://doc.rust-lang.org/book/second-edition/ch17-00-oop.html" tabindex="0"><strong aria-hidden="true">17.</strong> Is Rust an Object-Oriented Programming Language?</a></li><li><ol class="section"><li><a href="https://doc.rust-lang.org/book/second-edition/ch17-01-what-is-oo.html" tabindex="0"><strong aria-hidden="true">17.1.</strong> What Does Object-Oriented Mean?</a></li><li><a href="https://doc.rust-lang.org/book/second-edition/ch17-02-trait-objects.html" tabindex="0"><strong aria-hidden="true">17.2.</strong> Trait Objects for Using Values of Different Types</a></li><li><a href="https://doc.rust-lang.org/book/second-edition/ch17-03-oo-design-patterns.html" tabindex="0"><strong aria-hidden="true">17.3.</strong> Object-Oriented Design Pattern Implementations</a></li></ol></li><li><a href="https://doc.rust-lang.org/book/second-edition/ch18-00-patterns.html" tabindex="0"><strong aria-hidden="true">18.</strong> Patterns Match the Structure of Values</a></li><li><ol class="section"><li><a href="https://doc.rust-lang.org/book/second-edition/ch18-01-all-the-places-for-patterns.html" tabindex="0"><strong aria-hidden="true">18.1.</strong> All the Places Patterns May be Used</a></li><li><a href="https://doc.rust-lang.org/book/second-edition/ch18-02-refutability.html" tabindex="0"><strong aria-hidden="true">18.2.</strong> Refutability: Whether a Pattern Might Fail to Match</a></li><li><a href="https://doc.rust-lang.org/book/second-edition/ch18-03-pattern-syntax.html" tabindex="0"><strong aria-hidden="true">18.3.</strong> All the Pattern Syntax</a></li></ol></li><li><a href="https://doc.rust-lang.org/book/second-edition/ch19-00-advanced-features.html" tabindex="0"><strong aria-hidden="true">19.</strong> Advanced Features</a></li><li><ol class="section"><li><a href="https://doc.rust-lang.org/book/second-edition/ch19-01-unsafe-rust.html" tabindex="0"><strong aria-hidden="true">19.1.</strong> Unsafe Rust</a></li><li><a href="https://doc.rust-lang.org/book/second-edition/ch19-02-advanced-lifetimes.html" tabindex="0"><strong aria-hidden="true">19.2.</strong> Advanced Lifetimes</a></li><li><a href="https://doc.rust-lang.org/book/second-edition/ch19-03-advanced-traits.html" tabindex="0"><strong aria-hidden="true">19.3.</strong> Advanced Traits</a></li><li><a href="https://doc.rust-lang.org/book/second-edition/ch19-04-advanced-types.html" tabindex="0"><strong aria-hidden="true">19.4.</strong> Advanced Types</a></li><li><a href="https://doc.rust-lang.org/book/second-edition/ch19-05-advanced-functions-and-closures.html" tabindex="0"><strong aria-hidden="true">19.5.</strong> Advanced Functions &amp; Closures</a></li></ol></li><li><a href="https://doc.rust-lang.org/book/second-edition/ch20-00-final-project-a-web-server.html" tabindex="0"><strong aria-hidden="true">20.</strong> Final Project: Building a Multithreaded Web Server</a></li><li><ol class="section"><li><a href="https://doc.rust-lang.org/book/second-edition/ch20-01-single-threaded.html" tabindex="0"><strong aria-hidden="true">20.1.</strong> A Single Threaded Web Server</a></li><li><a href="https://doc.rust-lang.org/book/second-edition/ch20-02-multithreaded.html" tabindex="0"><strong aria-hidden="true">20.2.</strong> Turning our Single Threaded Server into a Multithreaded Server</a></li><li><a href="https://doc.rust-lang.org/book/second-edition/ch20-03-graceful-shutdown-and-cleanup.html" tabindex="0"><strong aria-hidden="true">20.3.</strong> Graceful Shutdown and Cleanup</a></li></ol></li><li><a href="https://doc.rust-lang.org/book/second-edition/appendix-00.html" tabindex="0"><strong aria-hidden="true">21.</strong> Appendix</a></li><li><ol class="section"><li><a href="https://doc.rust-lang.org/book/second-edition/appendix-01-keywords.html" tabindex="0"><strong aria-hidden="true">21.1.</strong> A - Keywords</a></li><li><a href="https://doc.rust-lang.org/book/second-edition/appendix-02-operators.html" tabindex="0"><strong aria-hidden="true">21.2.</strong> B - Operators and Symbols</a></li><li><a href="https://doc.rust-lang.org/book/second-edition/appendix-03-derivable-traits.html" tabindex="0"><strong aria-hidden="true">21.3.</strong> C - Derivable Traits</a></li><li><a href="https://doc.rust-lang.org/book/second-edition/appendix-04-macros.html" tabindex="0"><strong aria-hidden="true">21.4.</strong> D - Macros</a></li><li><a href="https://doc.rust-lang.org/book/second-edition/appendix-05-translation.html" tabindex="0"><strong aria-hidden="true">21.5.</strong> E - Translations</a></li><li><a href="https://doc.rust-lang.org/book/second-edition/appendix-06-newest-features.html" tabindex="0"><strong aria-hidden="true">21.6.</strong> F - Newest Features</a></li><li><a href="https://doc.rust-lang.org/book/second-edition/appendix-07-nightly-rust.html" tabindex="0"><strong aria-hidden="true">21.7.</strong> G - How Rust is Made and “Nightly Rust”</a></li></ol></li></ol>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar" class="menu-bar">
                    <div id="menu-bar-sticky-container">
                        <div class="left-buttons">
                            <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar" aria-expanded="true">
                                <i class="fa fa-bars"></i>
                            </button>
                            <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                                <i class="fa fa-paint-brush"></i>
                            </button>
                            <ul id="theme-list" class="theme-popup" aria-label="submenu">
                                <li><button class="theme" id="light">Light <span class="default">(default)</span></button></li>
                                <li><button class="theme" id="rust">Rust</button></li>
                                <li><button class="theme" id="coal">Coal</button></li>
                                <li><button class="theme" id="navy">Navy</button></li>
                                <li><button class="theme" id="ayu">Ayu</button></li>
                            </ul>
                        </div>

                        <h1 class="menu-title">The Rust Programming Language</h1>

                        <div class="right-buttons">
                            <a href="https://doc.rust-lang.org/book/second-edition/print.html" title="Print this book" aria-label="Print this book">
                                <i id="print-button" class="fa fa-print"></i>
                            </a>
                        </div>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <a class="header" href="https://doc.rust-lang.org/book/second-edition/ch11-03-test-organization.html#test-organization" id="test-organization"><h2>Test Organization</h2></a>
<p>As mentioned at the start of the chapter, testing is a complex discipline, and
different people use different terminology and organization. The Rust community
thinks about tests in terms of two main categories: <em>unit tests</em> and
<em>integration tests</em>. Unit tests are small and more focused, testing one module
in isolation at a time, and can test private interfaces. Integration tests are
entirely external to your library and use your code in the same way any other
external code would, using only the public interface and potentially exercising
multiple modules per test.</p>
<p>Writing both kinds of tests is important to ensure that the pieces of your
library are doing what you expect them to separately and together.</p>
<a class="header" href="https://doc.rust-lang.org/book/second-edition/ch11-03-test-organization.html#unit-tests" id="unit-tests"><h3>Unit Tests</h3></a>
<p>The purpose of unit tests is to test each unit of code in isolation from the
rest of the code to quickly pinpoint where code is and isn’t working as
expected. You’ll put unit tests in the <em>src</em> directory in each file with the
code that they’re testing. The convention is to create a module named <code class="hljs">tests</code>
in each file to contain the test functions and to annotate the module with
<code class="hljs">cfg(test)</code>.</p>
<a class="header" href="https://doc.rust-lang.org/book/second-edition/ch11-03-test-organization.html#the-tests-module-and-cfgtest" id="the-tests-module-and-cfgtest"><h4>The Tests Module and <code class="hljs">#[cfg(test)]</code></h4></a>
<p>The <code class="hljs">#[cfg(test)]</code> annotation on the tests module tells Rust to compile and run
the test code only when you run <code class="hljs">cargo test</code>, not when you run <code class="hljs">cargo build</code>.
This saves compile time when you only want to build the library and saves space
in the resulting compiled artifact because the tests are not included. You’ll
see that because integration tests go in a different directory, they don’t need
the <code class="hljs">#[cfg(test)]</code> annotation. However, because unit tests go in the same files
as the code, you’ll use <code class="hljs">#[cfg(test)]</code> to specify that they shouldn’t be
included in the compiled result.</p>
<p>Recall that when we generated the new <code class="hljs">adder</code> project in the first section of
this chapter, Cargo generated this code for us:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playpen"><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button><button class="fa fa-play play-button" title="Run this code" aria-label="Run this code" hidden=""></button><button class="fa fa-expand" title="Show hidden lines" aria-label="Show hidden lines"></button></div><code class="language-rust hljs"><span class="hidden">
<span class="hljs-meta">#![allow(unused_variables)]</span></span><span class="hidden">
<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() {</span>
<span class="hljs-meta">#[cfg(test)]</span>
<span class="hljs-keyword">mod</span> tests {
    <span class="hljs-meta">#[test]</span>
    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">it_works</span></span>() {
        <span class="hljs-built_in">assert_eq!</span>(<span class="hljs-number">2</span> + <span class="hljs-number">2</span>, <span class="hljs-number">4</span>);
    }
}<span class="hidden">
}</span></code></pre></pre>
<p>This code is the automatically generated test module. The attribute <code class="hljs">cfg</code>
stands for <em>configuration</em> and tells Rust that the following item should only
be included given a certain configuration option. In this case, the
configuration option is <code class="hljs">test</code>, which is provided by Rust for compiling and
running tests. By using the <code class="hljs">cfg</code> attribute, Cargo compiles our test code only
if we actively run the tests with <code class="hljs">cargo test</code>. This includes any helper
functions that might be within this module, in addition to the functions
annotated with <code class="hljs">#[test]</code>.</p>
<a class="header" href="https://doc.rust-lang.org/book/second-edition/ch11-03-test-organization.html#testing-private-functions" id="testing-private-functions"><h4>Testing Private Functions</h4></a>
<p>There’s debate within the testing community about whether or not private
functions should be tested directly, and other languages make it difficult or
impossible to test private functions. Regardless of which testing ideology you
adhere to, Rust’s privacy rules do allow you to test private functions.
Consider the code in Listing 11-12 with the private function <code class="hljs">internal_adder</code>:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playpen"><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button><button class="fa fa-play play-button" title="Run this code" aria-label="Run this code" hidden=""></button><button class="fa fa-expand" title="Show hidden lines" aria-label="Show hidden lines"></button></div><code class="language-rust hljs"><span class="hidden">
<span class="hljs-meta">#![allow(unused_variables)]</span></span><span class="hidden">
<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() {</span>
<span class="hljs-keyword">pub</span> <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">add_two</span></span>(a: <span class="hljs-built_in">i32</span>) -&gt; <span class="hljs-built_in">i32</span> {
    internal_adder(a, <span class="hljs-number">2</span>)
}

<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">internal_adder</span></span>(a: <span class="hljs-built_in">i32</span>, b: <span class="hljs-built_in">i32</span>) -&gt; <span class="hljs-built_in">i32</span> {
    a + b
}

<span class="hljs-meta">#[cfg(test)]</span>
<span class="hljs-keyword">mod</span> tests {
    <span class="hljs-keyword">use</span> super::*;

    <span class="hljs-meta">#[test]</span>
    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">internal</span></span>() {
        <span class="hljs-built_in">assert_eq!</span>(<span class="hljs-number">4</span>, internal_adder(<span class="hljs-number">2</span>, <span class="hljs-number">2</span>));
    }
}<span class="hidden">
}</span></code></pre></pre>
<p><span class="caption">Listing 11-12: Testing a private function</span></p>
<p>Note that the <code class="hljs">internal_adder</code> function is not marked as <code class="hljs">pub</code>, but because
tests are just Rust code and the <code class="hljs">tests</code> module is just another module, you can
import and call <code class="hljs">internal_adder</code> in a test just fine. If you don’t think
private functions should be tested, there’s nothing in Rust that will compel
you to do so.</p>
<a class="header" href="https://doc.rust-lang.org/book/second-edition/ch11-03-test-organization.html#integration-tests" id="integration-tests"><h3>Integration Tests</h3></a>
<p>In Rust, integration tests are entirely external to your library. They use your
library in the same way any other code would, which means they can only call
functions that are part of your library’s public API. Their purpose is to test
whether many parts of your library work together correctly. Units of code that
work correctly on their own could have problems when integrated, so test
coverage of the integrated code is important as well. To create integration
tests, you first need a <em>tests</em> directory.</p>
<a class="header" href="https://doc.rust-lang.org/book/second-edition/ch11-03-test-organization.html#the-tests-directory" id="the-tests-directory"><h4>The <em>tests</em> Directory</h4></a>
<p>We create a <em>tests</em> directory at the top level of our project directory, next
to <em>src</em>. Cargo knows to look for integration test files in this directory. We
can then make as many test files as we want to in this directory, and Cargo
will compile each of the files as an individual crate.</p>
<p>Let’s create an integration test. With the code in Listing 11-12 still in the
<em>src/lib.rs</em> file, make a <em>tests</em> directory, create a new file named
<em>tests/integration_test.rs</em>, and enter the code in Listing 11-13:</p>
<p><span class="filename">Filename: tests/integration_test.rs</span></p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-rust ignore hljs"><span class="hljs-keyword">extern</span> <span class="hljs-keyword">crate</span> adder;

<span class="hljs-meta">#[test]</span>
<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">it_adds_two</span></span>() {
    <span class="hljs-built_in">assert_eq!</span>(<span class="hljs-number">4</span>, adder::add_two(<span class="hljs-number">2</span>));
}
</code></pre>
<p><span class="caption">Listing 11-13: An integration test of a function in the
<code class="hljs">adder</code> crate</span></p>
<p>We’ve added <code class="hljs">extern crate adder</code> at the top of the code, which we didn’t need
in the unit tests. The reason is that each test in the <code class="hljs">tests</code> directory is a
separate crate, so we need to import our library into each of them.</p>
<p>We don’t need to annotate any code in <em>tests/integration_test.rs</em> with
<code class="hljs">#[cfg(test)]</code>. Cargo treats the <code class="hljs">tests</code> directory specially and compiles files
in this directory only when we run <code class="hljs">cargo test</code>. Run <code class="hljs">cargo test</code> now:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-text hljs">$ cargo test
   Compiling adder v0.1.0 (file:///projects/adder)
    Finished dev [unoptimized + debuginfo] target(s) in 0.31 secs
     Running target/debug/deps/adder-abcabcabc

running 1 test
test tests::internal ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out

     Running target/debug/deps/integration_test-ce99bcc2479f4607

running 1 test
test it_adds_two ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out

   Doc-tests adder

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre>
<p>The three sections of output include the unit tests, the integration test, and
the doc tests. The first section for the unit tests is the same as we’ve been
seeing: one line for each unit test (one named <code class="hljs">internal</code> that we added in
Listing 11-12) and then a summary line for the unit tests.</p>
<p>The integration tests section starts with the line <code class="hljs">Running target/debug/deps/integration-test-ce99bcc2479f4607</code> (the hash at the end of
your output will be different). Next, there is a line for each test function in
that integration test and a summary line for the results of the integration
test just before the <code class="hljs">Doc-tests adder</code> section starts.</p>
<p>Similarly to how adding more unit test functions adds more result lines to the
unit tests section, adding more test functions to the integration test file
adds more result lines to this integration test file’s section. Each
integration test file has its own section, so if we add more files in the
<em>tests</em> directory, there will be more integration test sections.</p>
<p>We can still run a particular integration test function by specifying the test
function’s name as an argument to <code class="hljs">cargo test</code>. To run all the tests in a
particular integration test file, use the <code class="hljs">--test</code> argument of <code class="hljs">cargo test</code>
followed by the name of the file:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-text hljs">$ cargo test --test integration_test
    Finished dev [unoptimized + debuginfo] target(s) in 0.0 secs
     Running target/debug/integration_test-952a27e0126bb565

running 1 test
test it_adds_two ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre>
<p>This command runs only the tests in the <em>tests/integration_test.rs</em> file.</p>
<a class="header" href="https://doc.rust-lang.org/book/second-edition/ch11-03-test-organization.html#submodules-in-integration-tests" id="submodules-in-integration-tests"><h4>Submodules in Integration Tests</h4></a>
<p>As you add more integration tests, you might want to make more than one file in
the <em>tests</em> directory to help organize them; for example, you can group the
test functions by the functionality they’re testing. As mentioned earlier, each
file in the <em>tests</em> directory is compiled as its own separate crate.</p>
<p>Treating each integration test file as its own crate is useful to create
separate scopes that are more like the way end users will be using your crate.
However, this means files in the <em>tests</em> directory don’t share the same
behavior as files in <em>src</em> do, as you learned in Chapter 7 regarding how to
separate code into modules and files.</p>
<p>The different behavior of files in the <em>tests</em> directory is most noticeable
when you have a set of helper functions that would be useful in multiple
integration test files and you try to follow the steps in the “Moving Modules
to Other Files” section of Chapter 7 to extract them into a common module. For
example, if we create <em>tests/common.rs</em> and place a function named <code class="hljs">setup</code> in
it, we can add some code to <code class="hljs">setup</code> that we want to call from multiple test
functions in multiple test files:</p>
<p><span class="filename">Filename: tests/common.rs</span></p>
<pre><pre class="playpen"><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button><button class="fa fa-play play-button" title="Run this code" aria-label="Run this code" hidden=""></button><button class="fa fa-expand" title="Show hidden lines" aria-label="Show hidden lines"></button></div><code class="language-rust hljs"><span class="hidden">
<span class="hljs-meta">#![allow(unused_variables)]</span></span><span class="hidden">
<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() {</span>
<span class="hljs-keyword">pub</span> <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">setup</span></span>() {
    <span class="hljs-comment">// setup code specific to your library's tests would go here</span>
}<span class="hidden">
}</span></code></pre></pre>
<p>When we run the tests again, we’ll see a new section in the test output for the
<em>common.rs</em> file, even though this file doesn’t contain any test functions nor
did we call the <code class="hljs">setup</code> function from anywhere:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-text hljs">running 1 test
test tests::internal ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out

     Running target/debug/deps/common-b8b07b6f1be2db70

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out

     Running target/debug/deps/integration_test-d993c68b431d39df

running 1 test
test it_adds_two ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out

   Doc-tests adder

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre>
<p>Having <code class="hljs">common</code> appear in the test results with <code class="hljs">running 0 tests</code> displayed for
it is not what we wanted. We just wanted to share some code with the other
integration test files.</p>
<p>To avoid having <code class="hljs">common</code> appear in the test output, instead of creating
<em>tests/common.rs</em>, we’ll create <em>tests/common/mod.rs</em>. In the “Rules of Module
Filesystems” section of Chapter 7, we used the naming convention
<em>module_name/mod.rs</em> for files of modules that have submodules. We don’t have
submodules for <code class="hljs">common</code> here, but naming the file this way tells Rust not to
treat the <code class="hljs">common</code> module as an integration test file. When we move the <code class="hljs">setup</code>
function code into <em>tests/common/mod.rs</em> and delete the <em>tests/common.rs</em> file,
the section in the test output will no longer appear. Files in subdirectories
of the <em>tests</em> directory don’t get compiled as separate crates or have sections
in the test output.</p>
<p>After we’ve created <em>tests/common/mod.rs</em>, we can use it from any of the
integration test files as a module. Here’s an example of calling the <code class="hljs">setup</code>
function from the <code class="hljs">it_adds_two</code> test in <em>tests/integration_test.rs</em>:</p>
<p><span class="filename">Filename: tests/integration_test.rs</span></p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-rust ignore hljs"><span class="hljs-keyword">extern</span> <span class="hljs-keyword">crate</span> adder;

<span class="hljs-keyword">mod</span> common;

<span class="hljs-meta">#[test]</span>
<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">it_adds_two</span></span>() {
    common::setup();
    <span class="hljs-built_in">assert_eq!</span>(<span class="hljs-number">4</span>, adder::add_two(<span class="hljs-number">2</span>));
}
</code></pre>
<p>Note that the <code class="hljs">mod common;</code> declaration is the same as the module declarations
we demonstrated in Listing 7-4. Then in the test function, we can call the
<code class="hljs">common::setup()</code> function.</p>
<a class="header" href="https://doc.rust-lang.org/book/second-edition/ch11-03-test-organization.html#integration-tests-for-binary-crates" id="integration-tests-for-binary-crates"><h4>Integration Tests for Binary Crates</h4></a>
<p>If our project is a binary crate that only contains a <em>src/main.rs</em> file and
doesn’t have a <em>src/lib.rs</em> file, we can’t create integration tests in the
<em>tests</em> directory and use <code class="hljs">extern crate</code> to import functions defined in the
<em>src/main.rs</em> file. Only library crates expose functions that other crates can
call and use; binary crates are meant to be run on their own.</p>
<p>This is one of the reasons Rust projects that provide a binary have a
straightforward <em>src/main.rs</em> file that calls logic that lives in the
<em>src/lib.rs</em> file. Using that structure, integration tests <em>can</em> test the
library crate by using <code class="hljs">extern crate</code> to exercise the important functionality.
If the important functionality works, the small amount of code in the
<em>src/main.rs</em> file will work as well, and that small amount of code doesn’t
need to be tested.</p>
<a class="header" href="https://doc.rust-lang.org/book/second-edition/ch11-03-test-organization.html#summary" id="summary"><h2>Summary</h2></a>
<p>Rust’s testing features provide a way to specify how code should function to
ensure it continues to work as you expect, even as you make changes. Unit tests
exercise different parts of a library separately and can test private
implementation details. Integration tests check that many parts of the library
work together correctly, and they use the library’s public API to test the code
in the same way external code will use it. Even though Rust’s type system and
ownership rules help prevent some kinds of bugs, tests are still important to
reduce logic bugs having to do with how your code is expected to behave.</p>
<p>Let’s combine the knowledge you learned in this chapter and in previous
chapters to work on a project!</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        
                            <a rel="prev" href="https://doc.rust-lang.org/book/second-edition/ch11-02-running-tests.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                        

                        
                            <a rel="next" href="https://doc.rust-lang.org/book/second-edition/ch12-00-an-io-project.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                
                    <a href="https://doc.rust-lang.org/book/second-edition/ch11-02-running-tests.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                

                
                    <a href="https://doc.rust-lang.org/book/second-edition/ch12-00-an-io-project.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
                
            </nav>

        </div>


        <!-- Local fallback for Font Awesome -->
        <script>
            if (getComputedStyle(document.querySelector(".fa")).fontFamily !== "FontAwesome") {
                var link = document.createElement('link');
                link.rel = 'stylesheet';
                link.type = 'text/css';
                link.href = '_FontAwesome/css/font-awesome.css';
                document.head.insertBefore(link, document.head.firstChild)
            }
        </script>

        

        

        

        

        <script src="Rusm-Dateien/highlight.js"></script>
        <script src="Rusm-Dateien/book.js"></script>

        <!-- Custom JS script -->
        

    

</body></html>