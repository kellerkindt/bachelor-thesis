
			
\chapter{Auswertung}

In diesem Kapitel wird die Implementation des MECViewServers in Rust mit der Referenzimplementation in C++ verglichen.

test für durchsatz nur bedingt aussagekräftig

gleicher dummy alg

\subsection{Vorgehen und Testumgebung}

Alle Tests sind auf der gleichen Hardware ausgeführt worden.
Es handelt sich um einen Server mit zwei Intel Xeon CPUs (E5-2620 v4 @ 2.10GHz).
Ubuntu Linux
Govenor performance.

Jede Kombination von Sensoren, Fahrzeugen und einer Serverimplementation sind in 10 Test-Durchläufen gemessen worden.
Es ist immer nur ein Test-Durchlauf gleichzeitig auf dem System ausgeführt worden.
Durch die Nutzung der Loopback-Netzwerkschnittstelle soll der Einfluss der 

\begin{itemize}
	\item Server starten, Log-Ausgabe ist auf das \enquote{info}-Level beschränkt
	\item Geforderte Anzahl an Sensoren starten
	\item Eine kurze Pause (2s) für Verbindungsaufbau der Sensoren einräumen
	\item Geforderte Anzahl an Fahrzeugen starten. Nach einer kurzen Pause (5s) nach dem Verbindungsaufbau, fordern die Fahrzeuge das Umgebungsmodell für 60s an.
	\item Nachdem die Fahrzeuginstanzen beendet wurden, werden alle Sensoren gestoppt
	\item Kurze Pause (2s) vor erneutem Test-Durchlauf einräumen
\end{itemize}

\subsection{Ergebnisse}

\newcommand{\makeDias}[3]{
	\begin{figure}[H]
		\centering
		\begin{subfigure}{.75\textwidth}
			\centering
			\begin{tikzpicture}
			\begin{axis}[ymin=0, ymax=#2, xmin=0, xmax=#3, width=\textwidth, height=20em, xlabel={Anzahl der Nachrichten}, ylabel={Durchschnittliche Latenz in ms}]
			
			\addplot gnuplot [raw gnuplot,id=bal,mark=none,very thick,color=brown!30]{
				set xrange [1:#3];
				f(x)=a*x+b;
				fit f(x) "data/rust_times_for_#1.dat" via a,b;
				plot f(x)};
			\addplot plot
			[only marks,mark=o,thick,color=brown] 
			file {data/rust_times_for_#1.dat};
			
			\addplot gnuplot [raw gnuplot,id=bal,mark=none,very thick,color=blue!30]{
				set xrange [1:#3];
				f(x)=a*x+b;
				fit f(x) "data/cpp_times_for_#1.dat" via a,b;
				plot f(x)};
			\addplot plot
			[only marks,mark=x,thick,color=blue] 
			file {data/cpp_times_for_#1.dat};
			
			
			\end{axis}
			\end{tikzpicture}
			\caption{Latenz-Nachrichtenanzahl Diagramm}
			\label{#1} 
		\end{subfigure}%
		\begin{subfigure}{.25\textwidth}
			\centering
			\begin{tikzpicture}
			\begin{axis}[
			ymin=0, ymax=#2,
			boxplot/draw direction=y,
			xtick={1,2},
			xticklabels={Rust,C++},
			width=\textwidth,
			height=20em
			]
			\addplot+[
			boxplot={average=auto},color=brown!80
			] table {data/rust_times_for_#1.dat}
			\printboxplotdata;
			
			\addplot+[
			boxplot={average=auto},color=blue!80
			] table {data/cpp_times_for_#1.dat}
			\printboxplotdata;
			
			\end{axis}
			\end{tikzpicture}
			\caption{Boxplot für\\die Latenz}
			\label{#1_boxplot}
		\end{subfigure}
	\end{figure}
}

\makeDias{1x25_60s}{3.5}{52000}

Ln(x) aus \autoref{1x25} vmtl weil \enquote{unterfordert} und Thread dauernd pausiert, bei vielen Nachrichten weniger pausiert, weniger overhead zum wecken?

\makeDias{2x25_60s}{4.1}{120000}
\makeDias{3x25_60s}{4.5}{200000}
\makeDias{4x25_60s}{4.5}{270000}
\makeDias{5x25_60s}{5.0}{370000}

	
\todo{rust graphs}