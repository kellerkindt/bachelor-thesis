
\chapter{Anforderungen}

\section{Funktionale Anforderungen}

\requirement{com:tcp}{TCP Server}{Auf Port \todo{...} sollen neue TCP-Verbindungen angenommen werden. Jeder Client soll einer eigenen TCP Verbindung zugewiesen sein.}

\requirement{com:asn}{Kommunikationsprotokoll ist ASN.1/UPER}{Das Protokoll für die Kommunikation zwischen dem Server und den Clients soll ASN.1 mit der Encodierung uPER sein. Es werden sollen die bereits definierten Nachrichten verwendet und keine neuen Nachrichten definiert werden. Das Kommunikationsverhalten soll die Anforderungen der C++ Referenzimplementation erfüllen, sprich den Clients soll nicht ersichtlich sein, ob die Rust oder die Referenzimplementation des Servers ausgeführt wird.}

\requirement{client:sensor}{Client als Sensor}{Ein Client soll sich nach dem Verbindungsaufbau als Sensor registrieren können. Ein Client soll sich nicht mehrmals registrieren können. Vor einer Registrierung soll der Typ der Clients unbekannt sein und er soll nicht als Sensor gewertet werden.}

\requirement{client:car}{Client als Fahrzeug}{Ein Client soll sich nach dem Verbindungsaufbau als Fahrzeug registrieren können. Ein Client soll sich nicht mehrmals registrieren können. Vor einer Registrierung soll der Typ der Clients unbekannt sein und er soll nicht als Fahrzeug gewertet werden.}

\requirement{client:sectors}{Sektoren übertragen}{Der Server soll dem Fahrzeug nach Registrierung alle bekannten Sektoren übermitteln.}

\requirement{sensor:pause}{Sensoren abonnieren}{Sensoren sollen bei verbunden Fahrzeugen abonniert werden.}

\requirement{sensor:resume}{Sensoren deabonnieren}{Sensoren sollen bei keinen verbunden Fahrzeugen deabonniert werden.}

\requirement{impl:algorithmus:to}{Sensordaten weitergeben}{Empfangene Sensordaten sollen dekodiert und an den Fusions-Algorithmus übergeben werden.}

\requirement{impl:algorithmus:from}{Ergebnisse weitergeben}{Ergebnisse des Fusions-Algorithmus sollen enkodiert un an die verbundenen Fahrzeuge versendet werden.}

\requirement{impl:algorithmus}{Fusions-Algorithmus}{Für den Testbetrieb soll der Fusions-Algorithmus aus der C++ Referenzimplementierung (\enquote{SampleAlgorithm}) auch in Rust umgesetzt werden. Dieser Fusions-Algorithmus ist eine \enquote{dummy} Implementation, d.h. eingehende Daten werden nach einem einfachen Schema wieder verschickt. Ob die Einbindung einer externen Bibliothek als Fusions-Algorithmus möglich ist, soll überprüft werden.}

\requirement{impl:roadclearance}{Road-Clearance}{\todo{...}}

\requirement{impl:config}{Konfigurationsdateien}{\todo{/etc/MECViewServer/...}}

\requirement{impl:args}{Startparameter}{\todo{sample: send\_delay\_ms, sensor\_timeout\_ms, environment\_frame\_file, ...}}

\requirement{dos:sensor}{Widerstand gegen Sensor DOS}{Die Funktionalität des Servers gegenüber anderen Clients soll durch eine Überflutung von Daten eines Sensors nicht beeinträchtigt werden. \todo{optional? relevant?}}

\requirement{dos:car}{Widerstand gegen Nachrichtenrückstau}{Die Funktionalität des Servers gegenüber anderen Clients soll durch Fahrzeuge, für die sich ein \todo{Nachrichtenrückstau} gebildet hat und von einzelnen langsamen Verbindungen, nicht beeinträchtigt werden. \todo{optional? relevant?}}


\section{Nichtfunktionale Anforderungen}

\requirement{exec:mec}{Plattform MEC}{Die Implementation des Servers muss in compilierter Form auf einem MEC Server mit dem Betriebssystem \todo{Ubuntu 16.04 LTS Server} und der Architektur \todo{x86-64} lauffähig sein.}

\requirement{exec:time}{Reaktionszeit des Servers}{Die Implementation des Servers muss Nachrichten von \todo{20} gleichzeitigen Sensoren und \todo{50} gleichzeitigen Fahrzeugen innerhalb von \todo{10ms} beantworten.
	Dies umfasst Nachricht dekodieren, Fusions-Algorithmus darbieten, Resultat enkodieren und versenden.
	Die Bearbeitungszeit des Fusions-Algorithmus zählt nicht dazu.}

\requirement{exec:realtime}{Kein Echtzeitsystem}{Trotz Anforderung \reqNumberForLabel{exec:time} wird das System nicht als hartes Echtzeitsystem gewertet. Eine Analyse für die maximale Reaktionszeit ist nicht verlangt. Stattdessen wird das System als weiches Echtzeitsystem gewertet, weswegen die durchschnittliche Reaktionszeit die Anforderung \reqNumberForLabel{exec:time} erfüllen muss.}

\requirement{nfktl:rust}{Implementation in Rust}{Die Implementation wird in der Programmiersprache Rust vorgenommen.}

\requirement{nfktl:speed}{Möglichst schnell}{Der Server soll auf Sensordaten und Algorithmusergebnisse schnell reagieren.}

\requirement{nfktl:styleguide}{Einhaltung des Styleguides}{Der Quellcode der Serverimplementation soll sich weitestgehend an den Styleguide (siehe \autoref{rust:styleguide}) halten.}