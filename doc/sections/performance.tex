
\chapter{Hochperformante, serverbasierte Kommunikationsplattform}
\label{com_plattform}

Dieses Kapitel erläutert den Begriff \enquote{hochperformante, serverbasierte Kommunikationsplattform} und vermittelt Basiswissen hierzu.

\section{Echtzeitsysteme}
Echtzeitsysteme zeichnen sich im allgemeinen dadurch aus, eine Aufgabe in einem zuvor vorgegebenen Zeitraum bearbeiten zu können.
Es existiert zu einer Aufgabe also immer eine Frist.
Bei der Bewertung der Richtigkeit eines Systems, wird die Fähigkeit, eine Frist einhalten zu können, auch bewertet \cite[2]{perf:buttazzo2006soft}.
Je nach Art des Echtzeitsystems, wird diese First jedoch unterschiedlich gewichtet:

\begin{itemize}
	\item Bei einem harten Echtzeitsystem kann eine Überschreitung der Frist einen katastrophalen Ausgang haben.
	Selbst im schlimmsten Fall darf diese Frist nicht überschritten werden.
	Deswegen wird in einem harten Echtzeitsystem die im maximale Reaktionszeit dem Zeitraum bis zur Frist gegenübergestellt \cite[75]{douglass2003real}.
	Ein Ergebnis nach Ablauf der Frist wird als nutzlos gewertet \cite[2]{perf:wang2017real}.
	
	Zum Beispiel könnte eine zu späte Auswertung von Beschleunigungsdaten in einem Flugzeug zu einer verzögerten und mittlerweile falschen Reaktion und daraufhin zu einem Absturz führen \cite[5]{perf:laplante2004real}.
	
	\item Bei einem weichen Echtzeitsystem resultiert die Überschreitung des vorgegebenes Zeitraums nicht in eine Katastrophe.
	Es wird die durchschnittliche Reaktionszeit dem Zeitraum bis zur Frist gegenübergestellt, eine seltene und unter last auftretende Überschreitung wird in kauf genommen \cite[76]{douglass2003real}.
	Das System führt in so einem Fall weiterhin seine Aufgaben aus, die Performance wird aber \todo{abgewertet} eingestuft.
	Weiche Echtzeitsysteme können sogar überhaupt keine Frist haben, sondern die Aufgabe, die Antwortzeit so gering wie möglich zu gehalten \cite[4]{perf:buttazzo2006soft}.
\end{itemize}

\section{Mobile Edge Computing}

\todo{..}
Als Mobile Edge Computing (\gls{mec}) werden Recheneinheiten bezeichnet, die eine Cloudähnliche Umgebung am Rande des Mobilfunknetzes schaffen \cite[4]{etsi:mec}.
Wenn in dieser Arbeit auf MEC Bezug genommen wird, sind damit explizit nahe Funkmasten montierte Recheneinheiten gemeint.
Dadurch, dass die Recheneinheiten direkt an eine Antenne angeschlossen sind, können sie Anfragen aus dem Abdeckungsbereich der Antenne deutlich schneller beantworten (Latenz kleiner 20ms) als Cloudlösungen (Latenz ca 100ms) \cite[2]{perf:mec:fraunhofer}.
Hierfür werden die Anfragen aus dem Mobilfunknetz direkt an die Recheneinheit geroutet, anstatt über einen Provider eine Internetverbindung zu einer Cloudlösung aufzubauen.

\todo{direkt am Funkmast, TCP, nichts erst via Internet -> niedrige Latenz, VMs}


\section{Architekturmuster? oder erst während der Implementation?}



			
			
		\subsection{Was ist dann ein hochperformantes System}
		\subsection{Low-Latency + Entwurfsmuster + Patterns? + Algorithmen?}
			\todo{Hochperformant -> parallel?}
			
			\todo{Design Pattern, Gamma et al, four important aspects}
			
			\todo{Real Time Design Patterns Buch: Ab Seite 141, verschiedene Systempatterns, microkernel \cite[151]{douglass2003real}? channel architektur pattern \cite[167]{douglass2003real}?}
			
			\todo{Message Queuing Pattern \cite[207]{douglass2003real}}
			
			\todo{Clean Architecture / Clean Code}
			
	\section{Serverbasierte Kommunikationsplattform: MEC}
	
		
		
	\input{sections/asn}
	
	
\section{Funktionale Sicherheit}
\label{com:safety}

\enquote{Sicherheit} ist im Deutschen kein eindeutiger Begriff.
Sowohl \enquote{Sichersein vor Gefahr oder Schaden} (\textit{to be safe}), \enquote{Freisein von Fehlern oder Irrtümern} (\textit{to be confident}) oder \enquote{Schutz vor Gefahren, die von außen auf Systeme oder Personen einwirken} (\textit{security}) könnte mit \enquote{sicher sein} gemeint sein \cite[5-6]{safety}.
Deswegen ist es wichtig, beim Begriff funktionale Sicherheit auf einen gemeinsamen Nenner zu bringen.

Bei funktionaler Sicherheit (\textit{safety}) geht es um die Betriebssicherheit, eine \enquote{Freiheit von unvertretbaren Risiken} \cite[6]{safety}.
Unvertretbare Risiken sind in erster Linie Personenschäden, weswegen einheitliche Regularien in Normen wie der IEC 61508 bzw der DIN EN 61508 festgehalten sind.
Für den Automobilbereich wurde die Norm in der ISO 26262 angepasst, um u.a. eine Einzelabnahme eines jeden Fahrzeuges durch eine Gesamtabnahme des Produktes zu ermöglichen \cite[14]{safety}.

\todo{such shiat argument, arguem more rust -> f. safety}
Obwohl funktionale Sicherheit für das Forschungsprojekt \gls{mec}-View eine nicht irrelevante Rolle spielt, wird in dieser Bachelorarbeit keine Entwicklung nach ISO 26262 vorgenommen.
Zum einen sollen die Garantien von Rust (siehe \autoref{rust:guarantees}) viele mögliche Fehlerquellen generell ausschließen, zum anderen soll durch die Test-getriebene Entwicklung (siehe \autoref{tdd}) die Fehlerwahrscheinlichkeit weiter reduziert werden.
Zuletzt ist anzumerken, dass das System nicht für einen Endanwender konzipiert ist, sondern nur durch entsprechendes Fachpersonal betrieben und in Notfallsituationen abgebrochen wird.

	
\section{Test-Driven Development}
\label{tdd}

\begin{quotation}
	\textit{\enquote{Failure is progress.}}
	\cite[5]{tdd}
\end{quotation}
\begin{quotation}
	\textit{\enquote{Make it run, make it good.}}
	\cite[24]{tdd}
\end{quotation}

Bei der Test-getriebenen Entwicklung werden Tests in den Vordergrund gestellt.
Die Implementierung einer neuen Funktionalität wird durch neue Tests, die die Anforderung repräsentieren, eingeleitet.
Erst nachdem ein Test erfolgreich feststellt, dass die geforderte Funktionalität noch nicht vorhanden ist, wird mit der Implementierung begonnen.
Eine schnelle Implementierung hat hierbei die höchste Priorität und erlaubt temporär auch eine limitierende, stinkende und naive Vorgehensweise \cite[7]{tdd}.
%Der neue Code, der den Test zufriedenstellt, darf hierbei kurzzeitig \enquote{stinken} \todo{cite} und Qualitätsstandards verletzten.
Direkt im Anschluss wird ein Refactoring\footnote{Verbesserung des Codes und der Struktur ohne Änderung der Funktionalität} durchgeführt, um die Qualitätsstandards wieder einzuhalten.
Diese drei Phasen werden \enquote{red/green/refactor} bezeichnet:

\begin{itemize}
	\item \textbf{red}: Ein neuer Test wird erstellt, dieser stellt erfolgreich die Abwesenheit der Funktionalität fest, eine rote Fehlermeldung ist zu sehen.
	\item \textbf{green}: Der Test wird durch neuen Code zufriedengestellt; eine positive Ausgabe bestätigt dies. Eine schnelle Implementierung wird hierbei temporär einer hochwertigen bevorzugt \cite[24]{tdd}, da ein erfolgreicher Test das Selbstvertrauen beim Refactorn stärke und helfen würde, Fehlerhafte Tests zu finden \cite[152]{tdd}.
	\item \textbf{refactor}: Der neue Code wird aufgeräumt und verbessert um den Qualitätsstandards gerecht zu werden. Ein andauernder Testdurchlauf versichert dabei keine Regression der Funktionalität.
\end{itemize}

\todo{.. clarify}
Die Testgröße und der daraus resultierende Umfang der neuen Funktionalität, wird durch die Zuversichtlichkeit des Entwicklers gesteuert \cite[42]{tdd}.
Eine hohe Zuversichtlichkeit führt zu größeren Tests, während eine hohe Unsicherheit zu vielen kleinen Tests führt.
Dementsprechend sind komplexe Anforderungen mit vielen Tests abgesichert.
Bei Änderungen kann man sich deshalb auf das Sicherheitsnetz aus Tests verlassen, die einen Defekt umgehend detektieren.

%\todo{manchmal stellt man beim erstellen des tests fest, dass die Anforderung blöd ist}
Test-getriebene Entwicklung verändert auch die Vorgehensweise bei der Implementation von Anforderungen. Anstatt zu fragen \enquote{Wie würde ich das Implementieren?}, wird überlegt \enquote{Wie würde ich das Testen?} \cite[39]{tdd}, womit auch implizit gefragt wird, wie die äußeren Schnittstelle idealerweise aussehen sollen \cite[4]{tdd}.


%\todo{p.11, shift of practice in p.13, \enquote{Make it run, make it good} p.24, no changes unless enough motivation p.34, tests run -> not broken anything p.37, never interrupt an interruption p.41, TDD is a steering process, unsure -> smaller steps, sure -> bigger steps p.42, Test First can reduce stress p.127}

%\todo{mention stress reduction?}
	
	\section{Sensordaten?}
	
	\section{TCP?}
	
	\todo{Kommunikation als Socket, FiFo, Fehlerkorrektur, erneutes senden bei Fehlern, richtige Reiehenfolge...}