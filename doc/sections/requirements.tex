
\chapter{Anforderungen}

In diesem Kapitel sind die Anforderungen an das umzusetzende System gelistet.
Die Anforderungen sind dabei in funktionale und nichtfunktionale Anforderungen sortiert.
Funktionale Anforderungen beschreiben das gewünschte Verhalten des Systems, nichtfunktionale Anforderungen zeigen dagegen Rahmenbedingungen bei der Umsetzung auf \cite[155]{goll2012methoden}.

\section{Funktionale Anforderungen}

\requirement{com:tcp}{TCP Server}{Auf Port 2000 sollen neue TCP-Verbindungen angenommen werden. Jedem Client soll eine eigenen TCP Verbindung zugewiesen sein.}

\requirement{client:sensor}{Client als Sensor}{Ein Client soll sich nach dem Verbindungsaufbau als Sensor registrieren können. Ein Client soll sich nicht mehrmals registrieren können. Vor einer Registrierung soll der Typ des Clients unbekannt sein und er soll nicht als Sensor agieren können.}

\requirement{client:car}{Client als Fahrzeug}{Ein Client soll sich nach dem Verbindungsaufbau als Fahrzeug registrieren können. Ein Client soll sich nicht mehrmals registrieren können. Vor einer Registrierung soll der Typ des Clients unbekannt sein und er soll nicht als Fahrzeug  agieren können.}

\requirement{client:sectors}{Fahrzeug initialisieren}{Der Server soll dem Fahrzeug nach Registrierung alle bekannten Sektoren übermitteln.}

\requirement{client:defunsub}{Sensor initialisieren}{Der Server soll den Sensor nach Registrierung deabonnieren.}

\requirement{sensor:pause}{Sensoren abonnieren}{Sensoren sollen bei verbunden Fahrzeugen abonniert sein.}

\requirement{sensor:resume}{Sensoren deabonnieren}{Sensoren sollen bei keinen verbunden Fahrzeugen deabonniert sein.}

\requirement{impl:algorithmus:to}{Sensordaten weitergeben}{Empfangene Sensordaten sollen dekodiert und an den Fusions-Algorithmus übergeben werden.}

\requirement{impl:vehicle:subscribe}{Fahrzeug kann Umgebungsmodell abonnieren}{Ein Fahrzeug kann ein Abonnement für Umgebungsmodelle erstellen.}

\requirement{impl:vehicle:unsubscribe}{Fahrzeug kann Abonnement aufkündigen}{Ein Fahrzeug kann ein bestehendes Abonnement für Umgebungsmodelle aufkündigen.}

\requirement{impl:algorithmus:from}{Umgebungsmodell weitergeben}{Ergebnisse des Fusions-Algorithmus sollen enkodiert un an die verbundenen Fahrzeuge mit einem Abonnement versendet werden.}

\requirement{impl:algorithmus}{Fusions-Algorithmus}{Für den Testbetrieb soll der Fusions-Algorithmus aus der C++ Referenzimplementierung (\enquote{SampleAlgorithm}) in Rust nachempfunden werden. Dieser Fusions-Algorithmus ist eine \enquote{Dummy}-Implementation, d.h. eingehende Daten werden nach einem einfachen Schema wieder verschickt: jede empfangende \textit{SensorFrame}-Nachricht (siehe \autoref{msg:sensor_frame}) wird mit einer \textit{EnvironmentFrame}-Nachricht (siehe \autoref{msg:environment_frame}) an alle Fahrzeuge beantwortet. Der Zeitstempel der \textit{SensorFrame}-Nachricht wird hierbei auf die \textit{EnvironmentFrame}-Nachricht übertragen.}

%\requirement{impl:roadclearance}{Road-Clearance}{\todo{...}}

\requirement{impl:config}{\todo{Konfigurationsdateien?}}{\todo{/etc/MECViewServer/...}}

\requirement{impl:args}{\todo{Startparameter?}}{\todo{sample: send\_delay\_ms, sensor\_timeout\_ms, environment\_frame\_file, ...}}

\section{Nichtfunktionale Anforderungen}


\requirement{rust}{Implementation in Rust}{Die Implementation des Servers soll in der Programmiersprache Rust vorgenommen werden.}

\requirement{com:asn}{Kommunikationsprotokoll ist ASN.1/UPER}{Das Protokoll für die Kommunikation zwischen dem Server und den Clients soll ASN.1 mit der Encodierung UPER sein. Es sollen die bereits definierten Nachrichten verwendet und keine neuen Nachrichten definiert werden. Das Kommunikationsverhalten soll die Anforderungen der C++ Referenzimplementation erfüllen, sprich den Clients soll nicht ersichtlich sein, ob die Rust oder die Referenzimplementation des Servers ausgeführt wird.}

\requirement{exec:mec}{Plattform MEC}{Die Implementation des Servers soll in compilierter Form auf einem MEC Server mit dem Betriebssystem Ubuntu 16.04 LTS Server und der Architektur x86-64 ausführbar sein.}

\requirement{exec:time}{Reaktionszeit des Servers}{Die Implementation des Servers soll Nachrichten von 6 Videosensoren mit einem Nachrichtenintervall von 100ms, 7 Lidarsensoren mit einem Nachrichtenintervall von 50ms und zwei gleichzeitig vebundenen Fahreugen 5ms beantworten können.
	Dies umfasst Nachricht dekodieren, Fusions-Algorithmus darbieten, Resultat enkodieren und versenden.
	Die Bearbeitungszeit des Fusions-Algorithmus zählt nicht dazu.}

\requirement{exec:realtime}{Kein Echtzeitsystem}{Trotz vorgegebener Reaktionszeit wird das System nicht als hartes Echtzeitsystem gewertet. Eine Analyse für die maximale Reaktionszeit ist nicht verlangt. Stattdessen soll das System als weiches Echtzeitsystem gewertet werden, weswegen die durchschnittliche Reaktionszeit betrachtet wird.}

\requirement{nfktl:rust}{Implementation in Rust}{Die Implementation soll in der Programmiersprache Rust vorgenommen werden.}

\requirement{nfktl:styleguide}{Einhaltung des Styleguides}{Der Quellcode der Serverimplementation soll sich an den offiziellen Styleguide (siehe \autoref{rust:styleguide}) halten.}

\requirement{dos:sensor}{Widerstand gegen Nachrichtenüberflutung}{Die Funktionalität des Servers gegenüber anderen Clients soll durch eine Überflutung von Daten eines einzelnen Sensors nicht beeinträchtigt werden.}

\requirement{dos:car}{Widerstand gegen Nachrichtenrückstau}{Die Funktionalität des Servers gegenüber anderen Clients soll durch Fahrzeuge, für die sich ein Nachrichtenrückstau gebildet hat oder von einzelnen langsamen Verbindungen, nicht beeinträchtigt werden.}

\requirement{possible:external_algorith}{Ob die Einbindung einer externen C++ Bibliothek als Fusions-Algorithmus möglich ist, soll überprüft werden.}

