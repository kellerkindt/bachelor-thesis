
\chapter{Die Programmiersprache Rust}

Rust ist eine Programmiersprache, die versucht performant -- und daher durch Abstraktionen mit keinem zusätzlichen \enquote{Kosten} \todo{ref zero cost abstractions} -- sichere Programmierung zu ermöglichen.
Ziel ist eine \todo{Systemprogrammiersprache}, die sowohl sicher \todo{cite chapter} als auch performant ist und ohne eine Laufzeit ausgeführt werden kann.
Verschiedene Fehlerquellen -- wie \enquote{dangling pointers}, \enquote{double free} oder \enquote{memory leaks} \todo{ref} --  werden durch Abstraktionen und mit Hilfe des Compilers verhindert.
Anders als Programmiersprachen, die dies mit Hilfe einer Laufzeit ermöglichen (zbsp. Java oder C\#), wird dies in Rust durch eine statische Analyse und einem Eigentümerprinzip bei der Compilation gewährleistet.


\section{Geschichte}
\label{rust:history}

In 2006 \cite{rust:faq} begann Graydon Hoare die Programmiersprache Rust in seiner Freizeit als Hobbyprojekt zu entwickeln.
Als Grund nannte er seine Unzufriedenheit mit der Programmiersprache C++, in der es sehr schwierig sei, fehlerfreien, speichersicheren und nebenläufigen Code zu schreiben.
Zudem beschrieb er C++ als \enquote{ziemlich fehlerträchtig}. \cite{rust:heise_interview_graydon}

Auch Federico Mena-Quintero -- Mitbegründer des Gnome projekts \todo{cite \url{https://people.gnome.org/~federico/} or so} --
äußerte in einem Interview mit Golem im Juli 2017 seine Bedenken an der Verwendung der \enquote{feindseligen} Sprache C \cite{rust:c_is_hostile_golem}.
In Vorträgen \todo{nix mehrzahl?} vermittelt er seither, wie Bibliotheken durch Implementationen in Rust ersetzt werden können \cite{rust:c_is_hostile_mena}.

Ab 2009 begann Mozilla die Weiterentwicklung finanziell zu fördern, als einfache Tests und die Kernprinzipien demonstriert werden konnten.
Die Entwicklung findet dabei öffentlich einsehbar auf GitHub unter \url{https://github.com/rust-lang/rust} statt und wird dabei nicht ausschließlich von Mozilla Angestellten koordiniert.
Die Stabilität des Compilers trotz hoher Flexibilität während der Entwicklung wird durch Unterscheidung von drei Veröffentlichungskanälen -- release, stable und nightly -- in Kombination mit automatisierten Tests \todo{ref?} gewährleistet. \cite{rust:faq}



\todo{hobbyprojekt, mozilla, open-source, Entwicklung auf GitHub - jeder kann sich beteiligen, test(coverage), automatisierte builds, stable/beta/nightly}

\section{Anwendungsgebiet}

Das Ziel von Rust ist es, das Designen und Implementieren von sicheren, nebenläufig und auch praktisch tauglichen Systemen möglich zu machen \cite{rust:faq}.
\todo{intro paragraph}

Da Rust den \gls{llvm}-Compiler nutzt, erbt Rust auch eine große Anzahl der Zielplattformen die \gls{llvm} unterstützt.
Die Zielplattformen sind in drei Stufen unterteilt, bei denen verschieden stark ausgeprägte Garantien vergeben sind. Es wird zwischen
\begin{itemize}
	\item \enquote{Stufe 1: Funktioniert garantiert} (u.a. X86, X86-64),
	\item \enquote{Stufe 2: Compiliert garantiert} (u.a. ARM, PowerPC, PowerPC-64) und
	\item \enquote{Stufe 3} (u. a. Thumb)
\end{itemize}
unterschieden \cite{rust:platform_support}.
Diese Unterscheidung wirkt sich auch auf die Stabilisierungsphase und Implementation neuer Funktionen aus (Beispiel \enquote{128-bit Integer Support} \cite{rust:github:128bit_integer}).

\section{Aufbau eines Projektverzeichnisses}

\subsection{Klassisch}
\label{rust:structure:classic}
\begin{wrapfigure}{l}[-1em]{.5\textwidth}
	\rustcinclude
		{fig:rust:structure:classi}
		{Verzeichnisstruktur des Quelltext-Verzeichnisses}
		{sections/rust.classic.txt}
\end{wrapfigure}

Das Quelldatei-Verzeichnis sollte entweder eine \textit{main.rs} für Ausführbare Programme oder eine \textit{lib.rs} für Bibliotheken enthalten.
Während der Paketmanager Cargo (\autoref{rust:structure:cargo}) eine solche Benennung als Standardkonvention erwartet, kann bei manueller Nutzung des Compilers auch ein anderer Name für die Quelldatei vergeben werden.

Der Compiler startet in der Wurzeldatei und lädt weitere Module, die durch \rustcinline{mod module;} gekennzeichnet sind (ähnlich \ccinline{# include "module.h"} in C/C++).
Ein Modul kann dabei eine weitere Quelldatei oder ganzes Verzeichnis sein.
Ein Verzeichnis wird aber nur als Modul interpretiert, wenn sich eine \textit{mod.rs} Datei darin befindet.
%Module (Verzeichnisse oder Quelldateien) gesucht wird. , in der Module durch \rustcinline{mod module;} und Quelldateien durch \rustcinline{mod functionality;} \enquote{inkludiert} werden können.
%Eine Datei \textit{mod.rs} ist die Wurzeldatei eines Moduls.

\subsection{Mit Cargo}
\label{rust:structure:cargo}

\begin{wrapfigure}{r}{.4\textwidth}
	\rustcincludeml
		{fig:rust:structure:cargo}
		{Vereinfachte Verzeichnisstruktur einer \enquote{crate}}
		{sections/rust.cargo.txt}
\end{wrapfigure}



\todo{text is shit}
Im Gegensatz zu einem klassischen Aufbau (\autoref{rust:structure:classic}) wird von der Rust Gemeinschaft das Werkzeug \enquote{Cargo} (dt. Fracht/Ladung\todo{.}) angeboten.
Mit Cargo können ähnlich wie zum Beispiel mit Maven \todo{cite?} in Java, Abhängigkeiten zu anderen Bibliotheken verwaltet werden.
Ein Cargo Projekt wird dabei als \enquote{Crate} (dt. Kiste/Kasten\todo{.}) bezeichnet.
Eine offizielles Verzeichnis befindet sich auf \url{https://crates.io/}.
Von \url{https://crates.io/} werden standardmäßig Abhängigkeiten nachgeladen.
Jeder kann neue Bibliotheken hochladen/veröffentlichen, für den Namen gilt dabei \enquote{first come, first serve}.


\todo{dependencies}

\todo{Cargo init --bin <name>}

\todo{missing .gitignore / .git mention / git alltogether}

\todo{Cargo.toml}

\todo{[crates.io], Anzahl Pakete}

\todo{Compilierablauf, downloaden, compilieren von crates}

\section{Hello World}


\begin{wrapfigure}{l}{.5\textwidth}
	\rustcinclude
		{fig:rust:hello_world}
		{\enquote{Hello World} in Rust}
		{sections/rust.hello_world.rs}
\end{wrapfigure}

\todo{let, optionaler datentyp, macros, generics}

\todo{official format/naming convetion, use, function, macro}

\todo{Variables, Structs, Enums, Traits}

\clearpage

\section{Standardbibliothek}

Die Rust Community ist darum bemüht, die Standardbibliothek sehr leichtgewichtig zu halten.
Sie wird selbst als eine Crate (siehe \autoref{rust:structure:cargo}) zur Verfügung gestellt, auf die standardmäßige eine Abhängigkeit besteht.
Für die Verwendung von Rust im Embedded Bereich, kann diese Abhängigkeit, die für Microcontroller sehr umfangreich ist, durch \rustcinline{#![no_std]} unterbunden werden.
Daraufhin sind nur noch die in der \rustcinline{core} Crate zur Verfügung gestellten Sprachkonstrukte verwendbar.

\subsection{core}
\label{rust:core}
Die in der \rustcinline{core} Crate zur Verfügung gestellten Sprachkonstrukte sind im wesentlichen die üblichen  Verdächtigen: \rustcinline{bool} für boolische Ausdrücke; \rustcinline{char} für ein einzelnes Unicode Zeichen; \rustcinline{str} für eine Zeichenkette; \rustcinline{u8}, \rustcinline{i8}, \rustcinline{u16}, \rustcinline{i16}, \rustcinline{u32}, \rustcinline{i32}, \rustcinline{u64}, \rustcinline{i64} (und bald \rustcinline{u128}, \rustcinline{i128} \todo{cite}) für ganze Zahlen; \rustcinline{f32}, \rustcinline{f64} für Fließkommazahlen in einfacher und zweifacher Präzision; Arrays und Slices \cite{rust:book:primitives}.

Ganzzahlige primitive Datentypen beginnen mit \rustcinline{u} für vorzeichenlos und \rustcinline{i} für vorzeichenbehaftet gefolgt mit der Größe des Datentyps in Bits.
Dadurch wird eine Verwirrung wie zum Beispiel in C unterbunden, wo die primitiven Datentypen (\ccinline{short}, \ccinline{int}, \ccinline{long}, ..) keine definierte Größe haben, sondern dies abhängig vom eingesetzten Compiler und der Zielplattform ist. \todo{prove? => sizeof?, cite C99/C14 Standard?}

Zahlen können eindeutig einem Datentyp zugewiesen werden, indem dieser angehängt wird.
\rustcinline{4711u16} ist somit vom Datentyp \rustcinline{u16}.
Des weiteren dürfen Ziffern durch beliebiges setzen von \rustcinline{_} getrennt werden, um die Lesbarkeit zu erhöhen: \rustcinline{1_000_000_f32}.

\todo{move to hello world?}
Arrays haben immer eine zur Compilezeit bekannte Größe. Dynamische Arrays gibt es nicht, da diese zu oft die Quelle von Fehlern seien \todo{cite!} (Abhilfe \rustcinline{Vec<_>}, siehe \autoref{rust:std}).
Die Notation ist \rustcinline{[<Füllwert>; <Größe>]}.
\rustcinline{[0_u8; 128]} steht also für ein 128 Byte langes Byte Array, das mit 0-en vom Datentyp \rustcinline{u8} gefüllt ist.
\enquote{Slices} (dt. Scheibe/Stück) bezeichnet Rust Referenzen auf Arrays, die auch nur Teilbereiche umfassen können.
Die Größe einer Slice ist in deren \todo{Fat-Pointer} \todo{explain} enthalten.
Die Notation ähnelt die eines Arrays, aber ohne Größenspezifikation: \rustcinline{[<Datentyp>]}.
Eine Slice kann von einem Array oder einer anderen Slice erzeugt werden, dabei wird der Start- und Endindex des Teilbereiches angegeben.
Falls kein Start- oder Endindex angegeben wurde, wird das jeweilige Limit übernommen (0, max) \todo{shit text}: \rustcinline{let slice : &[u8] = &array[..8];}

Rust kennt \ccinline{null}(-Pointer) nicht, bietet aber in \rustcinline{core} bereits \rustcinline{Option<_>} als Ersatz an.
Für die Fehlerbehandlung wird nicht auf ein Exception-Handling zurückgegriffen, sondern ein eigener Datentyp angeboten, der entweder den Rückgabewert enthält, oder aber einen Fehler: \rustcinline{Result<_, _>}.
Die Funktionsweise und die Vorteile von \rustcinline{Option<_>} und \rustcinline{Result<_, _>} wird in \autoref{rust:no_null} genauer erklärt.

\subsection{std}
\label{rust:std}

Die Crate \rustcinline{std} erweitert \rustcinline{core} um viele \todo{collections etc}.

\todo{core, datatypes, arrays slices, no null  \enquote{billion dollar mistake} }

\todo{std, Vec, str, String, no\_std für embedded}

\todo{println!, writeln! formatting}



\section{Alles hat einen Rückgabewert}

\section{use mod pub}


\section{Eigentümer- und Verleihprinzip}

\section{Scope / Memory Management, Lebenszeit}


\todo{autodrop, auto file close}

\section{Rust als funktionale Programmiersprache}
\todo{functional programming -> no global state, no exceptions, find literature}
\todo{prove via code}

\section{Rust als Objekt-Orientierte Programmiersprache}
\todo{trait}
\todo{prove via design patterns, a few? from faq::  Is Rust object oriented? It is multi-paradigm. Many things you can do in OO languages you can do in Rust, but not everything, and not always using the same abstraction you’re accustomed to.}


\section{Versprechen von Rust}
\label{rust:guarantees}
\subsection{Sichere Nebenläufigkeit}
\todo{Send, Sync, No dataraces weil Ownership, Channel, Mutex, RwLock}
\subsection{Zero Cost Abstraction}
\subsection{Kein undefiniertes Verhalten}
\todo{ref oreilly}
\subsection{Keine vergessene Null-Pointer Prüfung}
\label{rust:no_null}
\todo{explain option}
\subsection{Something with Exception/Result}
\subsection{Kein vergessene Fehlerprüfung}
\todo{explain result}
\subsection{No dangling pointer}
\todo{src https://www.youtube.com/watch?v=d1uraoHM8Gg}
\subsection{Statische Speicher- und Lebenszeitanalyse}
\todo{while compiling, does not compile on error / unprovable code, trait Drop}
\subsection{type safety langauge}





Rust ist...
% \lipsum

\todo{Rust -> MIR -> assembler} \\
\todo{MIR/assemblerbeispiele?} \\
\cite{rust:orly_programming}


\section{Einbinden von Bibliotheken}

\subsubsection{Externe Datentypen}
\label{rust:ffi:datatypes}

Rust bietet durch das \gls{ffi} die Möglichkeit, andere (System-)Bibliotheken einzubinden.
Entsprechende Strukturen und Funktionen werden durch einen \rustcinline{extern}-Block
oder im Falle von Strukturen optional mit einem \rustcinline{#[repr(C)]} gekennzeichnet.

In einem Beispiel, soll die Nutzung von \gls{ffi} demonstriert werden.

\begin{figure}[H]
	\ccinclude
		{fig:rust:ffi:position_offset_c}
		{Ausschnitt von \enquote{PositionOffset} \todo{ref mecview lib} in C}
		{sections/rust.position_offset.c}
	
\end{figure}

Die Struktur in \autoref{fig:rust:ffi:position_offset_c} muss zur Nutzung in Rust zuerst bekannt gemacht werden.
Dabei gibt es mehrere Möglichkeiten:
\begin{enumerate}
	\item Falls Inhalt der Struktur nicht von Bedeutung ist, kann es ausreichen, den neuen Typ lediglich bekannt zu machen: \rustcinline{#[repr(C)] struct PositionOffset;} \label{rust:ffi:example:enumerate:repr}
	
	\item Der Inhalt ist wie bei \autoref{rust:ffi:example:enumerate:repr} unbedeutend, es soll aber ausdrücklich auf einen externen Typ hingewiesen werden: \rustcinline{extern \{ type PositionOffset; \}} \cite{rust:github:extern_type} (\todo{nightly})
	
	\item Der Inhalt der Struktur ist von Bedeutung, da darauf zugegriffen werden soll oder in Rust eine Instanz erzeugbar sein soll. In diesem Fall muss die Struktur wiedergegeben werden:
	\begin{figure}[H]
		\rustcinclude
			{fig:rust:ffi:position_offset_rust}
			{Ausschnitt von \enquote{PositionOffset} \todo{ref mecview lib} in Rust}
			{sections/rust.position_offset.rs}
	\end{figure}
	
	In \autoref{fig:rust:ffi:position_offset_rust} ist die Struktur \enquote{PositionOffset} definiert,
	die durch das Attribut \rustcinline{#repr(C)} wie eine C-Struktur im Speicher organisiert wird.
	Somit ist sie kompatibel zu der C-Struktur aus \autoref{fig:rust:ffi:position_offset_c}.
	
	Da auf eine C-Struktur zugegriffen wird, sollten auch, wie in \autoref{fig:rust:ffi:position_offset_rust} zu sehen, spezielle Datentypen (\rustcinline{c_long}, \rustcinline{c_void}, \rustcinline{c_char}, ...) verwendet werden, um die Kompatibilität mit verschiedenen Systemen und C-Compilern zu wahren. \todo{u32 immer 32bit, aber int nicht immer gleich (Beispiel!?) --> Probleme}
	
%	\rustcinline{*mut c_long} entspricht dabei dem C-Pointer für \rustcinline{&mut c_long}, also \ccinline{long*}, ein C-Pointer für \rustcinline{&c_long} entspricht \rustcinline{*const c_long}.
	
%	C-Pointer werden in Rust \enquote{Raw-Pointer} genannt und \rustcinline{*mut c_long} für  \rustcinline{&mut c_long} bzw. \rustcinline{*const c_long} für \rustcinline{&c_long} geschrieben.
	
	Ein C-Pointer \ccinline{*long} wird in Rust \enquote{Raw-Pointer} genannt und entweder als \rustcinline{*mut c_long} oder als \rustcinline{*const c_long} geschrieben. Der Unterschied ist wie zwischen \rustcinline{&mut c_long} und \rustcinline{&c_long} und dient dem \todo{Rusttypsystem!? ref!?} zur Unterscheidung \todo{Erzwinungt im Besitz von entsprechender Mutability zu sein}, während es für die C-Seite keinen Unterschied macht \cite{rust:book:raw_ptr}:
	
	\begin{figure}[H]
		\centering
		\begin{tabular}{c|c|c}
			Referenz in Rust & Raw-Pointer in Rust & C-Pointer \\
			\hline
			\rustcinline{&mut c_long}  &   \rustcinline{*mut   c_long}  &   \ccinline{long*} \\
			\rustcinline{    &c_long}  &   \rustcinline{*const c_long}  &   \ccinline{long*}
		\end{tabular}
		\caption{Vergleich Rust Raw-Pointer und Referenz zu C-Pointer}
	\end{figure}
	
\end{enumerate}

\subsubsection{Externer Funktionsaufruf}
\label{rust:ffi:functioncall}

Während eine Struktur, die eine externe Struktur darstellen soll, optional in einem \rustcinline{extern {}} Block definiert sein kann, ist das für externe Funktionen zwingend:

\begin{figure}[H]
	\rustcinclude
		{fig:rust:ffi:uper_encode_to_buffer}
		{Externe Funktionsdefinition der ASN.1 Funktion zum Enkodieren}
		{sections/rust.uper_encode_to_buffer.rs}
\end{figure}

Wie in \autoref{fig:rust:ffi:uper_encode_to_buffer} zu sehen ist, können auch \rustcinline{extern \{\}} Blöcke mit Attributen versehen werden. Zwingend ist bei der Verwendung eines \rustcinline{#[link(..)]} Attributes der Name der Bibliothek, auf die sich der im \rustcinline{extern \{\}} Block stehende Code bezieht. Optional kann auch wie in \autoref{fig:rust:ffi:uper_encode_to_buffer} die Art der \todo{Linkung} (dylib, static) angegeben werden.

Die Art der Definition einer externen Funktion unterscheidet sich nicht von einer normalen Funktionsdefinition. Es sollten aber, wie in \autoref{rust:ffi:datatypes} beschrieben, zu C bzw. der externen Sprache kompatiblen Datentypen verwendet werden.
 

\section{Warum Rust?}

\begin{quotation}
	\textit{\enquote{[..]Leute, die [..] sichere Programmierung haben wollen, [..] können das bei Rust haben, ohne die [von D] undeterministischen Laufzeiten oder Abstraktionskosten schlucken zu müssen. }}
	\cite{rust:fefe}
\end{quotation}




\begin{quotation}
	\textit{\enquote{It’s not bad programmers, it’s that C is a hostile language}} 
	(Seite 54, \cite{rust:c_is_hostile_mena})
\end{quotation}

\begin{quotation}
	\textit{\enquote{I’m thinking that C is actively hostile to writing and maintaining reliable code}} 
	(Seite 129, \cite{rust:c_is_hostile_mena})
\end{quotation}

\begin{quotation}
	\textit{\enquote{[..] Rust makes it safe, and  provides nice tools}} 
	(Seite 130, \cite{rust:c_is_hostile_mena})
\end{quotation}


\begin{quotation}
	\textit{\enquote{Rust hilft beim Fehlervermeiden}} 
	\cite{rust:c_is_hostile_golem}
\end{quotation}

\begin{quotation}
	\textit{\enquote{Rust is [..] a language that cares about very tight control}}
	\cite{rust:tight_control}
\end{quotation}

\todo{unused orly rust} \cite{rust:orly_y_rust}

\section{Kernfeatures}

https://www.youtube.com/watch?v=d1uraoHM8Gg \\
\todo{no need for a runtime, all static analytics} \\
\todo{memory safety} \\
\todo{data-race freedom} \\
\todo{active community} \\
\todo{concurrency: no undefined behavior} \\
\todo{ffi binding} \gls{ffi} \\
\todo{zero cost abstraction} \\
\todo{package manager: cargo} \\

https://www.youtube.com/watch?v=-Tj8Q12DaEQ \\
\todo{static type system with local type inference } \\
\todo{explicit notion of mutability } \\
\todo{zero-cost abstraction *(do not introduce new cost through implementation of abstraction)} \\
\todo{errors are values not exceptions}
\todo{no null} \\
\todo{"static automatic memory management" - no garbage collection } \\
\todo{often compared to GO and D (~44min)} \\


\section{Schwächen}

https://www.youtube.com/watch?v=-Tj8Q12DaEQ \\
\todo{compile-times} \\
\todo{Rust is a vampire language, it does not reflect at all!} \\
\todo{depending on the field -> majority of libraries?} \\


\section{Performance Fallstricke}

\todo{\cite{rust:performance_pitfalls}}

\section{Beispiele von Verwendung von Rust}

\todo{firefox} \\

https://www.youtube.com/watch?v=-Tj8Q12DaEQ \\
\todo{GTK binding heavily to rust} \\

\todo{unstable}
\todo{ffi}
